---
phase: 84-animation-panel-independence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAnimationTimer.ts
  - src/App.tsx
  - src/components/AnimationPanel/AnimationPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Animated tiles on map canvas continue animating when the right sidebar is collapsed"
    - "Animated tiles render correctly when user opens a map with animations and immediately collapses sidebar"
    - "Animation frame counter pauses when browser tab is hidden (Page Visibility API)"
    - "Animation frame counter pauses when no animated tiles are visible in any viewport"
    - "AnimationPanel preview tiles stay in sync with map canvas animations when panel is visible"
  artifacts:
    - path: "src/hooks/useAnimationTimer.ts"
      provides: "Global animation RAF loop with Page Visibility API and hasVisibleAnimated check"
      exports: ["useAnimationTimer"]
    - path: "src/App.tsx"
      provides: "Always-mounted animation timer via useAnimationTimer hook call"
      contains: "useAnimationTimer()"
    - path: "src/components/AnimationPanel/AnimationPanel.tsx"
      provides: "Animation preview panel without RAF loop ownership"
  key_links:
    - from: "src/hooks/useAnimationTimer.ts"
      to: "Zustand advanceAnimationFrame"
      via: "useEditorStore selector"
      pattern: "advanceAnimationFrame"
    - from: "src/App.tsx"
      to: "src/hooks/useAnimationTimer.ts"
      via: "hook call in App component body"
      pattern: "useAnimationTimer\\(\\)"
    - from: "src/core/canvas/CanvasEngine.ts"
      to: "Zustand animationFrame"
      via: "subscribe callback (unchanged, decoupled consumer)"
      pattern: "state\\.animationFrame !== prevState\\.animationFrame"
---

<objective>
Decouple the animation RAF loop from AnimationPanel so animated tiles render on the map canvas regardless of whether the right sidebar panel is visible.

Purpose: When users collapse the right sidebar, AnimationPanel unmounts and its RAF loop is cleaned up, freezing all animated tiles on the map canvas. Moving the animation loop to an always-mounted hook in App.tsx ensures animations persist through panel visibility changes.

Output: `src/hooks/useAnimationTimer.ts` custom hook called from App.tsx; AnimationPanel cleaned of RAF loop ownership while retaining animation preview rendering.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/84-animation-panel-independence/84-RESEARCH.md
@src/components/AnimationPanel/AnimationPanel.tsx
@src/App.tsx
@src/core/editor/slices/globalSlice.ts
@src/core/canvas/CanvasEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAnimationTimer hook and wire into App.tsx</name>
  <files>src/hooks/useAnimationTimer.ts, src/App.tsx</files>
  <action>
Create `src/hooks/useAnimationTimer.ts` — a custom React hook that owns the global animation RAF loop. Extract the following logic verbatim from AnimationPanel.tsx:

1. **hasVisibleAnimated computation** (AnimationPanel.tsx lines 39-66): Subscribe to `documents` from Zustand via `useEditorStore`. Use `useMemo` to check if any open document has animated tiles (bit 15 set, `& 0x8000`) in its viewport. Use the exact same viewport math: `tilePixels = TS * viewport.zoom`, `tilesX = Math.ceil(1920 / tilePixels) + 1`, `tilesY = Math.ceil(1080 / tilePixels) + 1`, start/end clamped to MAP_SIZE=256. Import `ANIMATED_FLAG` from `@core/map`.

2. **Page Visibility API** (AnimationPanel.tsx lines 69-80): `isPausedRef` updated by `visibilitychange` event listener. Use a ref (not state) since only the RAF loop reads it — no React re-render needed.

3. **RAF loop** (AnimationPanel.tsx lines 82-109): `requestAnimationFrame` loop with 150ms `FRAME_DURATION`. Only call `advanceAnimationFrame()` when `!isPausedRef.current && hasVisibleAnimatedRef.current` and `timestamp - lastFrameTimeRef.current >= FRAME_DURATION`. Cleanup via `cancelAnimationFrame` in useEffect return.

4. **Ref pattern for hasVisibleAnimated**: Use a `useRef` that mirrors the `useMemo` value (set `ref.current = memoValue` on every render), so the RAF callback reads fresh values without closure staleness. This is the same pattern as AnimationPanel lines 87-88.

Export: `export function useAnimationTimer(): void`

Then modify `src/App.tsx`:
- Add import: `import { useAnimationTimer } from '@/hooks/useAnimationTimer';`
- Call `useAnimationTimer();` at the top of the App component body (after the existing useState declarations, before the useEditorStore selectors). This ensures the hook runs for the entire app lifetime since App never unmounts.
- Remove the `advanceAnimationFrame` import from AnimationPanel if it was re-exported (it's not — AnimationPanel imports it directly from Zustand, so no change needed here).
  </action>
  <verify>
Run `npm run typecheck` — no TypeScript errors. Verify `src/hooks/useAnimationTimer.ts` exists and exports `useAnimationTimer`. Verify `src/App.tsx` calls `useAnimationTimer()` in the component body.
  </verify>
  <done>
useAnimationTimer hook exists with RAF loop, Page Visibility API, and hasVisibleAnimated check. App.tsx calls the hook, ensuring animation runs regardless of AnimationPanel mount state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove RAF loop ownership from AnimationPanel</name>
  <files>src/components/AnimationPanel/AnimationPanel.tsx</files>
  <action>
Remove the animation loop ownership from AnimationPanel.tsx while keeping everything else intact:

1. **Remove these lines/blocks:**
   - Lines 32: `const advanceAnimationFrame = useEditorStore(...)` — no longer needed since AnimationPanel doesn't call it
   - Lines 37-66: The entire `hasVisibleAnimated` useMemo block — moved to useAnimationTimer hook
   - Lines 68-80: The `isPaused` state and `visibilitychange` useEffect — moved to hook
   - Lines 82-109: The RAF loop useEffect (`lastFrameTimeRef`, `isPausedRef`, `hasVisibleAnimatedRef`, `animate` function) — moved to hook
   - The `FRAME_DURATION` constant (line 19) — moved to hook (only used by RAF loop)

2. **Keep these unchanged:**
   - Line 30: `const animationFrame = useEditorStore((state) => state.animationFrame);` — still needed for preview rendering
   - Lines 111-119: `getAnimations` and `canvasHeight` — panel display logic
   - Lines 121-181: `staticDrawnRef`, `drawStatic` — panel rendering
   - Lines 183-218: `updateAnimatedPreviews` — uses `animationFrame` for preview tile cycling
   - Lines 220-231: Full redraw and animation tick useEffects — react to `animationFrame` changes for preview updates
   - Lines 233-392: All mouse handlers, controls, JSX — unchanged

3. **Remove unused imports:**
   - After removing the RAF/visibility code, check if `useState` is still needed (yes — for `selectedAnimId`, `hoveredAnimId`, `placementMode`, `offsetError`).
   - Check if `useMemo` is still needed (yes — for `canvasHeight`). Actually `hasVisibleAnimated` was the only useMemo, and `canvasHeight` is also useMemo. Keep `useMemo`.
   - The `advanceAnimationFrame` selector removal means fewer Zustand subscriptions for this component.

The key insight: AnimationPanel still subscribes to `animationFrame` from Zustand (line 30) to drive preview rendering. The global RAF loop in useAnimationTimer increments this counter. AnimationPanel is now a pure consumer — it reacts to frame changes but doesn't drive them. This is exactly how CanvasEngine already works.
  </action>
  <verify>
Run `npm run typecheck` — no TypeScript errors. Verify AnimationPanel.tsx has NO `requestAnimationFrame`, NO `cancelAnimationFrame`, NO `advanceAnimationFrame`, NO `visibilitychange` listener. Verify it still has `animationFrame` subscription (line 30) and `updateAnimatedPreviews` callback.
  </verify>
  <done>
AnimationPanel is a pure consumer of the global animationFrame counter. It renders previews based on frame changes but does not own or drive the animation loop. Collapsing the sidebar unmounts AnimationPanel but the RAF loop in App.tsx (via useAnimationTimer) continues running, keeping map canvas animations alive.
  </done>
</task>

</tasks>

<verification>
1. **Sidebar collapse test**: Place animated tiles on map, collapse right sidebar, verify animated tiles continue cycling on map canvas.
2. **Startup test**: Open a map with animated tiles, immediately collapse sidebar before animations start, verify map canvas shows animated tiles cycling.
3. **Page Visibility test**: Switch to another browser tab, verify animationFrame counter stops incrementing (check DevTools Zustand state). Switch back, verify it resumes.
4. **Preview sync test**: With sidebar expanded, verify AnimationPanel previews cycle in sync with map canvas animated tiles (same frame shown simultaneously).
5. **No animated tiles test**: Open a map with no animated tiles, verify RAF loop does not call advanceAnimationFrame (hasVisibleAnimated is false).
6. **TypeScript**: `npm run typecheck` passes with zero errors.
</verification>

<success_criteria>
- Animated tiles on map canvas keep animating when AnimationPanel is unmounted (sidebar collapsed)
- Animation previews in AnimationPanel stay synchronized with map canvas when panel is visible
- Page Visibility API pauses animations when tab is hidden
- No TypeScript errors
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/84-animation-panel-independence/84-01-SUMMARY.md`
</output>
