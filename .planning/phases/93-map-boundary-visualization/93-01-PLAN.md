---
phase: 93-map-boundary-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/styles/variables.css
  - src/core/canvas/CanvasEngine.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Area outside 256x256 map renders in a distinct color visually different from DEFAULT_TILE (tile 280) in all three themes"
    - "A border line marks the exact edge of the map at tile coordinates (0,0)-(256,256) on the UI canvas overlay"
    - "Boundary color and border update correctly when user switches themes without manual canvas refresh"
    - "At all zoom levels (0.25x to 4x), boundary remains correctly aligned with the map edge"
  artifacts:
    - path: "src/styles/variables.css"
      provides: "Theme-aware CSS tokens for out-of-map fill and map border"
      contains: "--canvas-out-of-map-bg"
    - path: "src/core/canvas/CanvasEngine.ts"
      provides: "Out-of-map fill rendering in blitToScreen"
      contains: "canvas-out-of-map-bg"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Border line in drawUiLayer + MutationObserver for theme-change refresh"
      contains: "canvas-map-border"
  key_links:
    - from: "src/core/canvas/CanvasEngine.ts"
      to: "src/styles/variables.css"
      via: "getComputedStyle reads --canvas-out-of-map-bg at draw time"
      pattern: "getComputedStyle.*canvas-out-of-map-bg"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/styles/variables.css"
      via: "getComputedStyle reads --canvas-map-border at draw time"
      pattern: "getComputedStyle.*canvas-map-border"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "MutationObserver triggers drawMapLayerRef (which calls blitToScreen) on theme change"
      pattern: "MutationObserver.*data-theme"
---

<objective>
Render the 256x256 map boundary so users can see where the editable area ends.

Purpose: When editing near tile row/column 255, users currently cannot distinguish the map edge from empty space. This adds a visible out-of-map fill color and a border line at the map boundary, themed for all three color schemes.

Output: Three files modified — CSS tokens for boundary colors, out-of-map fill in CanvasEngine.blitToScreen(), border line in MapCanvas drawUiLayer, and a MutationObserver to refresh canvas on theme switches.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-map-boundary-visualization/93-RESEARCH.md
@src/styles/variables.css
@src/core/canvas/CanvasEngine.ts
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSS tokens and out-of-map fill in CanvasEngine</name>
  <files>src/styles/variables.css, src/core/canvas/CanvasEngine.ts</files>
  <action>
**1. CSS tokens in variables.css:**

Add two new tokens to each of the three theme blocks in `src/styles/variables.css`:

In `:root` (light theme), after the `--canvas-checker-bg` line (around line 200):
```css
--canvas-out-of-map-bg: oklch(82% 0.008 250);
--canvas-map-border: rgba(100, 120, 160, 0.6);
```

In `[data-theme="dark"]`, after the `--canvas-checker-bg` line (around line 279):
```css
--canvas-out-of-map-bg: oklch(10% 0.015 260);
--canvas-map-border: rgba(120, 160, 220, 0.5);
```

In `[data-theme="terminal"]`, after the `--canvas-checker-bg` line (around line 365):
```css
--canvas-out-of-map-bg: oklch(3% 0.01 160);
--canvas-map-border: oklch(45% 0.08 160);
```

These colors must be visually distinct from DEFAULT_TILE (tile 280, which renders transparent — the container CSS background shows through). The out-of-map fill is a slightly different shade from the container background in each theme.

**2. Out-of-map fill in CanvasEngine.blitToScreen:**

At the END of the `blitToScreen()` method in `src/core/canvas/CanvasEngine.ts`, AFTER the `this.lastBlitVp = ...` assignment (line 229), add four non-overlapping `fillRect` strips that cover the screen canvas area outside the 256x256 map region:

```typescript
// Fill out-of-map regions with theme-aware color (CNVS-01)
const outOfMapColor = getComputedStyle(document.documentElement)
  .getPropertyValue('--canvas-out-of-map-bg').trim()
  || 'oklch(10% 0.01 260)';

screenCtx.fillStyle = outOfMapColor;

const tilePixels = TILE_SIZE * viewport.zoom;
const mapLeft   = (0 - viewport.x) * tilePixels;
const mapTop    = (0 - viewport.y) * tilePixels;
const mapRight  = (MAP_WIDTH - viewport.x) * tilePixels;
const mapBottom = (MAP_HEIGHT - viewport.y) * tilePixels;
const stripL = Math.max(0, mapLeft);
const stripR = Math.min(canvasWidth, mapRight);

// Left strip (full height, from screen left to map left edge)
if (mapLeft > 0)
  screenCtx.fillRect(0, 0, mapLeft, canvasHeight);
// Right strip (full height, from map right edge to screen right)
if (mapRight < canvasWidth)
  screenCtx.fillRect(mapRight, 0, canvasWidth - mapRight, canvasHeight);
// Top strip (between map left and right only, above map top)
if (mapTop > 0 && stripR > stripL)
  screenCtx.fillRect(stripL, 0, stripR - stripL, mapTop);
// Bottom strip (between map left and right only, below map bottom)
if (mapBottom < canvasHeight && stripR > stripL)
  screenCtx.fillRect(stripL, mapBottom, stripR - stripL, canvasHeight - mapBottom);
```

CRITICAL: The fill MUST come AFTER `drawImage` and AFTER `lastBlitVp` assignment. If placed before `drawImage`, `clearRect` at the top of `blitToScreen` erases it. The four strips are non-overlapping: left and right strips span full canvas height; top and bottom strips span only the horizontal extent between map edges (clamped to canvas bounds).

Also add the same out-of-map fill logic to the end of `blitDirtyRect()` — NO, do NOT. `blitDirtyRect` only updates a sub-rectangle for animated tiles. The out-of-map fill from the full `blitToScreen` call is still intact. Only `blitToScreen` (which calls `clearRect` on the full canvas) needs the fill.
  </action>
  <verify>
Run `npm run typecheck` — no type errors. Visually inspect: open the app, scroll to the bottom-right corner of the map (tile 255,255). The area beyond the map should show a distinct fill color, not the container CSS background.
  </verify>
  <done>
Two CSS tokens (`--canvas-out-of-map-bg`, `--canvas-map-border`) defined in all three theme blocks. CanvasEngine.blitToScreen fills the out-of-map area with the theme-aware color using four non-overlapping fillRect strips. The fill is visible at all zoom levels and correctly clamped at viewport extremes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add border line in drawUiLayer and MutationObserver for theme refresh</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
**1. Border line in drawUiLayer:**

In `src/components/MapCanvas/MapCanvas.tsx`, inside the `drawUiLayer` callback, RIGHT AFTER `ctx.clearRect(0, 0, canvas.width, canvas.height);` (line 294) and BEFORE the outlined stroke helpers setup (line 296), add the map boundary border line:

```typescript
// Map boundary border line (CNVS-01)
{
  const borderTilePixels = TILE_SIZE * vp.zoom;
  const borderMapLeft   = (0 - vp.x) * borderTilePixels;
  const borderMapTop    = (0 - vp.y) * borderTilePixels;
  const borderMapRight  = (MAP_WIDTH - vp.x) * borderTilePixels;
  const borderMapBottom = (MAP_HEIGHT - vp.y) * borderTilePixels;

  const borderColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--canvas-map-border').trim()
    || 'rgba(120, 160, 220, 0.5)';

  ctx.save();
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1;
  ctx.setLineDash([]);
  // 0.5px offset for crisp 1px line on pixel boundary
  ctx.strokeRect(
    borderMapLeft + 0.5, borderMapTop + 0.5,
    borderMapRight - borderMapLeft, borderMapBottom - borderMapTop
  );
  ctx.restore();
}
```

Use a block scope (`{ ... }`) to avoid variable name collisions with `tilePixels` declared later in the function (line 321). Use `ctx.save()/restore()` to isolate stroke settings from the rest of drawUiLayer. Draw BEFORE all other overlays so the border sits behind cursors, selection, and tool previews.

The 0.5px offset is the standard Canvas API technique for crisp 1px lines — without it, the line renders spanning two pixels at 50% opacity each.

**2. MutationObserver for theme-change refresh:**

Add a new `useEffect` in MapCanvas.tsx. Place it AFTER the ResizeObserver effect (around line 2597) and BEFORE the `const scrollMetrics = getScrollMetrics();` line (line 2599). This observer detects when `data-theme` changes on `<html>` and triggers a full canvas redraw:

```typescript
// Theme-change observer: redraw canvas layers when theme switches (CNVS-01)
useEffect(() => {
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
        drawMapLayerRef.current();
        drawGridLayerRef.current();
        drawUiLayerRef.current();
        break;
      }
    }
  });
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });
  return () => observer.disconnect();
}, []);
```

This triggers all three layer redraws: map layer (picks up new `--canvas-out-of-map-bg`), grid layer (may have theme-dependent grid color), and UI layer (picks up new `--canvas-map-border`). The effect has empty deps — the observer stays connected for the component's lifetime and uses stable refs that always point to current draw functions.

Note: Also include `drawGridLayerRef.current()` in the observer callback because the grid layer reads `gridColor` from state which may be theme-relative. This is a bonus fix — the research didn't mention it but it ensures full theme consistency.
  </action>
  <verify>
Run `npm run typecheck` — no type errors. Open the app, scroll to a map edge. Verify the border line is visible at the exact map boundary. Switch themes via View > Theme — verify the border color and out-of-map fill update immediately without any user interaction. Test at zoom 0.25x and 4x — border stays aligned with tile grid.
  </verify>
  <done>
A 1px border line renders at the exact (0,0)-(256,256) map boundary on the UI overlay canvas, drawn before all other overlays. A MutationObserver on `data-theme` triggers full canvas redraw on theme switch so both the out-of-map fill and border line update to new theme colors automatically.
  </done>
</task>

</tasks>

<verification>
1. **Out-of-map fill:** Open app, scroll viewport so map edge is visible (e.g., scroll right past tile column 255). Area beyond map shows distinct fill color, different from tile 280 background.
2. **Border line:** A thin border line marks the exact map edge at (0,0) to (256,256). Visible when scrolling near any map edge.
3. **Theme switching:** Switch between Light, Dark, and Terminal themes via View > Theme. Both the fill color and border color update immediately without needing to pan or zoom.
4. **Zoom alignment:** At 0.25x zoom (entire map visible), the border and fill surround the full map correctly. At 4x zoom near a corner, the border aligns exactly with the tile grid.
5. **No regression:** Drawing tools (pencil, eraser, wall, etc.) still function correctly. Selection, paste preview, ruler, and line tools render on top of the border line.
6. **Type check:** `npm run typecheck` passes with no errors.
</verification>

<success_criteria>
- The out-of-map area renders a distinct color in all three themes (Light, Dark, Terminal)
- A border line marks the exact 256x256 map boundary on the UI overlay
- Theme switching updates both fill and border colors immediately
- Boundary alignment is correct at all zoom levels (0.25x to 4x)
- No new type errors
</success_criteria>

<output>
After completion, create `.planning/phases/93-map-boundary-visualization/93-01-SUMMARY.md`
</output>
