---
phase: 07-batch-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.ts
  - electron/preload.ts
  - src/vite-env.d.ts
  - src/core/patches.ts
  - src/core/export/batchRenderer.ts
autonomous: true

must_haves:
  truths:
    - "Batch renderer can sequentially render a map with every bundled patch to PNG files"
    - "Directory picker dialog lets user choose output folder"
    - "Each PNG is written to disk with the patch name as filename"
    - "Memory does not grow unbounded during batch (single reusable canvas)"
  artifacts:
    - path: "src/core/patches.ts"
      provides: "Shared BUNDLED_PATCHES constant"
      exports: ["BUNDLED_PATCHES"]
    - path: "src/core/export/batchRenderer.ts"
      provides: "Self-contained batch render function"
      exports: ["executeBatchRender"]
    - path: "electron/main.ts"
      provides: "dialog:selectDirectory IPC handler"
      contains: "dialog:selectDirectory"
    - path: "electron/preload.ts"
      provides: "selectDirectory exposed to renderer"
      contains: "selectDirectory"
    - path: "src/vite-env.d.ts"
      provides: "selectDirectory type declaration"
      contains: "selectDirectory"
  key_links:
    - from: "src/core/export/batchRenderer.ts"
      to: "src/core/patches.ts"
      via: "import BUNDLED_PATCHES"
      pattern: "import.*BUNDLED_PATCHES.*from.*patches"
    - from: "src/core/export/batchRenderer.ts"
      to: "window.electronAPI.writeFile"
      via: "IPC call for PNG write"
      pattern: "window\\.electronAPI\\.writeFile"
    - from: "src/core/export/batchRenderer.ts"
      to: "canvas.toBlob"
      via: "PNG conversion"
      pattern: "toBlob"
---

<objective>
Build the batch rendering infrastructure: IPC directory picker, shared patch list, and self-contained batch renderer that can sequentially render a map with all 44 bundled patches to PNG files.

Purpose: Provides the core engine that Plan 02 will wire into the UI. This plan contains no UI -- it is pure infrastructure.
Output: `src/core/export/batchRenderer.ts` with `executeBatchRender()`, `src/core/patches.ts` with `BUNDLED_PATCHES`, and `dialog:selectDirectory` IPC channel.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:/newmapeditor/.planning/phases/07-batch-rendering/07-RESEARCH.md
@E:/newmapeditor/electron/main.ts
@E:/newmapeditor/electron/preload.ts
@E:/newmapeditor/src/vite-env.d.ts
@E:/newmapeditor/src/core/canvas/CanvasEngine.ts
@E:/newmapeditor/src/core/map/types.ts
@E:/newmapeditor/src/core/map/AnimationDefinitions.ts
@E:/newmapeditor/src/components/TilesetPanel/TilesetPanel.tsx
@E:/newmapeditor/src/adapters/electron/ElectronFileService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPC directory picker + shared patch constant</name>
  <files>
    electron/main.ts
    electron/preload.ts
    src/vite-env.d.ts
    src/core/patches.ts
    src/components/TilesetPanel/TilesetPanel.tsx
  </files>
  <action>
1. Add `dialog:selectDirectory` IPC handler to `electron/main.ts`:
   ```typescript
   ipcMain.handle('dialog:selectDirectory', async () => {
     const result = await dialog.showOpenDialog(mainWindow!, {
       properties: ['openDirectory', 'createDirectory'],
       title: 'Select Output Directory for Batch Render'
     });
     if (result.canceled || result.filePaths.length === 0) return null;
     return result.filePaths[0];
   });
   ```
   Place it after the existing `dialog:openPatchFolder` handler.

2. Add `selectDirectory` to the preload bridge in `electron/preload.ts`:
   - In the `contextBridge.exposeInMainWorld` block, add: `selectDirectory: () => ipcRenderer.invoke('dialog:selectDirectory'),`
   - In the `ElectronAPI` interface, add: `selectDirectory: () => Promise<string | null>;`

3. Add `selectDirectory` to the `ElectronAPI` interface in `src/vite-env.d.ts`:
   `selectDirectory: () => Promise<string | null>;`

4. Create `src/core/patches.ts` -- extract the `BUNDLED_PATCHES` array from `src/components/TilesetPanel/TilesetPanel.tsx`:
   ```typescript
   /**
    * Canonical list of all bundled patch names.
    * Single source of truth -- used by TilesetPanel dropdown and batch renderer.
    */
   export const BUNDLED_PATCHES: readonly string[] = [
     'AC Default',
     'Apple',
     // ... all 44 entries exactly as they appear in TilesetPanel.tsx
   ] as const;
   ```

5. Update `src/components/TilesetPanel/TilesetPanel.tsx` to import from the shared module:
   - Remove the local `BUNDLED_PATCHES` array definition
   - Add: `import { BUNDLED_PATCHES } from '@core/patches';`
   - Everything else in the component stays the same
  </action>
  <verify>
    Run `npx tsc --noEmit` from the project root -- no type errors.
    Grep for `BUNDLED_PATCHES` in both `src/core/patches.ts` and `src/components/TilesetPanel/TilesetPanel.tsx` to confirm the array exists only in `patches.ts` and TilesetPanel imports it.
    Grep for `selectDirectory` in `electron/main.ts`, `electron/preload.ts`, and `src/vite-env.d.ts` to confirm the IPC channel is wired end-to-end.
  </verify>
  <done>
    `dialog:selectDirectory` IPC handler exists in main.ts, is exposed in preload.ts, and is typed in vite-env.d.ts.
    `BUNDLED_PATCHES` lives in `src/core/patches.ts` as the single source of truth, imported by TilesetPanel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Self-contained batch renderer</name>
  <files>
    src/core/export/batchRenderer.ts
  </files>
  <action>
Create `src/core/export/batchRenderer.ts` with a self-contained `executeBatchRender` async function. This module must NOT import CanvasEngine or any React/Zustand code. It is a pure function that takes data in and produces files.

**Exports:**
```typescript
export interface BatchRenderProgress {
  current: number;      // 0-based index of patch being rendered
  total: number;        // total number of patches
  patchName: string;    // name of current patch
}

export interface BatchRenderResult {
  rendered: number;
  failed: number;
  total: number;
  errors: string[];     // patch names that failed
}

export async function executeBatchRender(
  mapTiles: Uint16Array,
  outputDir: string,
  onProgress: (progress: BatchRenderProgress) => void,
  signal?: AbortSignal
): Promise<BatchRenderResult>;
```

**Implementation details:**

1. Import `BUNDLED_PATCHES` from `@core/patches`.
2. Import `MAP_WIDTH`, `MAP_HEIGHT`, `TILE_SIZE`, `ANIMATION_DEFINITIONS` from `@core/map` and `@core/map/AnimationDefinitions`.
3. Constants: `TILES_PER_ROW = 40`, `DEFAULT_TILE = 280`.

4. Helper: `loadPatchTileset(patchName: string): Promise<HTMLImageElement>` -- loads `./assets/patches/${encodeURIComponent(patchName)}/imgTiles.png` via `new Image()` with onload/onerror promise.

5. Helper: `renderExportTile(ctx, tilesetImg, tile, destX, destY)` -- renders a single tile to canvas context at native 16x16 size. Handles animated tiles (0x8000 flag) by resolving to frame 0 using ANIMATION_DEFINITIONS. Skips DEFAULT_TILE (280) to leave transparent. Falls back to purple `#4a4a6a` fill for unknown animated tiles.

6. Helper: `canvasToBlob(canvas): Promise<Blob>` -- wraps `canvas.toBlob('image/png')` in a promise.

7. Helper: `writePngToFile(blob, outputDir, patchName): Promise<void>` -- converts blob to base64 via `blob.arrayBuffer()` then btoa loop (same pattern as ElectronFileService.arrayBufferToBase64), then calls `window.electronAPI.writeFile(filePath, base64)`. Sanitize filename: `patchName.replace(/[^a-zA-Z0-9_\- ]/g, '_')` + `.png`.

8. Main function `executeBatchRender`:
   - Create ONE reusable off-screen canvas (4096x4096), get 2d context, set `imageSmoothingEnabled = false`.
   - Loop through `BUNDLED_PATCHES`:
     a. Check `signal?.aborted` -- if so, break out of loop.
     b. Call `onProgress({ current: i, total, patchName })`.
     c. `await new Promise(r => setTimeout(r, 0))` -- yield to UI.
     d. Try: load tileset, clearRect the canvas, render all 65536 tiles, toBlob, writePngToFile, cleanup tileset (`img.src = ''`).
     e. Catch: push patchName to errors array, increment failed.
   - After loop: cleanup canvas (`canvas.width = 0; canvas.height = 0`).
   - Return `{ rendered, failed, total: BUNDLED_PATCHES.length, errors }`.

**Anti-patterns to avoid (per research):**
- Do NOT create a new canvas per patch -- reuse one with clearRect.
- Do NOT import CanvasEngine -- the renderer must be fully self-contained.
- Do NOT use toDataURL -- use toBlob for memory efficiency.
- Do NOT render in parallel -- strictly sequential.
  </action>
  <verify>
    Run `npx tsc --noEmit` from the project root -- no type errors.
    Confirm the file exports `executeBatchRender`, `BatchRenderProgress`, and `BatchRenderResult` by grepping for them.
    Check that the file does NOT import from `CanvasEngine`, `EditorState`, `zustand`, or `react`.
  </verify>
  <done>
    `src/core/export/batchRenderer.ts` exists with a fully self-contained `executeBatchRender` function that sequentially renders all 44 patches to PNG files via IPC, uses a single reusable canvas, yields to the UI between patches, supports AbortSignal cancellation, and has no dependencies on React/Zustand/CanvasEngine.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `selectDirectory` IPC is wired: main.ts handler -> preload.ts bridge -> vite-env.d.ts type
- `BUNDLED_PATCHES` exists only in `src/core/patches.ts`, TilesetPanel imports from there
- `batchRenderer.ts` exports `executeBatchRender` and has no React/Zustand/CanvasEngine imports
</verification>

<success_criteria>
All export infrastructure is in place: directory picker IPC, shared patch constant, and self-contained batch renderer that can be called from any UI trigger. TypeScript compiles cleanly. No runtime testing needed -- Plan 02 will wire UI and enable end-to-end testing.
</success_criteria>

<output>
After completion, create `.planning/phases/07-batch-rendering/07-01-SUMMARY.md`
</output>
