---
phase: 37-render-state-performance
plan: 03
type: execute
wave: 2
depends_on: [37-01, 37-02]
files_modified:
  - src/App.tsx
  - src/components/Minimap/Minimap.tsx
autonomous: false

must_haves:
  truths:
    - "App.tsx does not subscribe to map at root level"
    - "Map changes do not trigger full component tree re-renders"
    - "Minimap tile color computation does not block main thread"
    - "App remains responsive during tileset load"
    - "Entire app renders idle at <1% CPU"
  artifacts:
    - path: "src/App.tsx"
      provides: "App root without map subscription"
      not_contains: "const map = useEditorStore.*state\\.map"
      min_lines: 200
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "Deferred minimap computation"
      contains: "requestIdleCallback"
      min_lines: 150
  key_links:
    - from: "src/App.tsx"
      to: "MapCanvas"
      via: "Props without map (uses documentId subscription internally)"
      pattern: "<MapCanvas.*documentId"
    - from: "src/components/Minimap/Minimap.tsx"
      to: "requestIdleCallback"
      via: "Idle-time tile color computation"
      pattern: "requestIdleCallback.*buildMinimapCache"
---

<objective>
Remove root-level map subscription and defer minimap computation to idle periods.

Purpose: App.tsx subscribes to `state.map` to pass to children, causing full tree re-renders on every map change (tile placement, undo/redo). Minimap computes 1024-tile color cache synchronously on tileset load, freezing UI for 100-300ms. This plan eliminates both sources of lag.

Output: App.tsx with no map subscription + Minimap with deferred computation + human verification of performance gains.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:\NewMapEditor\.planning\PROJECT.md
@E:\NewMapEditor\.planning\ROADMAP.md
@E:\NewMapEditor\.planning\STATE.md
@E:\NewMapEditor\.planning\phases\37-render-state-performance\37-RESEARCH.md
@E:\NewMapEditor\.planning\phases\37-render-state-performance\37-01-SUMMARY.md
@E:\NewMapEditor\.planning\phases\37-render-state-performance\37-02-SUMMARY.md
@E:\NewMapEditor\src\App.tsx
@E:\NewMapEditor\src\components\Minimap\Minimap.tsx
</context>

<tasks>

<task type="auto">
  <name>Remove root-level map subscription from App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Eliminate `const map = useEditorStore((state) => state.map)` from App.tsx (line 23):

**Step 1 — Remove the subscription:**
- Delete line 23: `const map = useEditorStore((state) => state.map);`

**Step 2 — Fix usages (3 locations per planning context):**

1. **handleSaveMap (line 87):**
   - BEFORE: `if (!map) return;` and `await mapService.saveMap(map, map.filePath);`
   - AFTER: `const map = useEditorStore.getState().map;` (use getState() for one-time read in handler)
   - Full pattern: `const map = useEditorStore.getState().map; if (!map) return; await mapService.saveMap(map, map.filePath);`

2. **handleCursorMove (line 102):**
   - BEFORE: `if (map && x >= 0 && y >= 0 && x < MAP_WIDTH && y < MAP_WIDTH) { setCursorTileId(map.tiles[y * MAP_WIDTH + x]); }`
   - AFTER: Same getState() pattern: `const map = useEditorStore.getState().map; if (map && ...) { setCursorTileId(map.tiles[...]); }`
   - Reason: handleCursorMove is event handler (not reactive), getState() is correct pattern

3. **windowTitle selector (line 152):**
   - BEFORE: Already uses inline selector `useEditorStore((state) => { ... doc.map ... })`
   - AFTER: No changes needed (already correct — subscribes internally)

**Step 3 — Verify Workspace component:**
- Workspace likely expects map prop — check Workspace.tsx
- If Workspace uses map, migrate to documentId prop (subscribe internally like MapCanvas does)
- Pattern: `<Workspace documentId={activeDocumentId} />` instead of `<Workspace map={map} />`

**Step 4 — Verify no other map usages:**
- Search App.tsx for `map.` or `{map}` or `map?.`
- Ensure all usages either removed or migrated to getState()

CRITICAL: Do NOT pass map as prop to children. Children subscribe to activeDocumentId and fetch map internally. This prevents cascading re-renders.

Pattern from research (37-RESEARCH.md lines 506-521): getState() for event handlers, internal subscription for components.
  </action>
  <verify>
Run `npm run typecheck` — zero errors.

Grep verification:
```bash
grep -n "const map = useEditorStore" src/App.tsx
```
Should return ZERO matches (no map subscription).

Manual test with React DevTools Profiler:
1. Record interaction: place a tile on canvas
2. Profiler shows MapCanvas rendered (map changed)
3. Profiler does NOT show App, Toolbar, StatusBar, TilesetPanel, AnimationPanel rendered
4. Before fix: entire tree re-renders on tile placement
5. After fix: only MapCanvas + Minimap re-render
  </verify>
  <done>
- App.tsx has no map subscription
- handleSaveMap uses getState() for map access
- handleCursorMove uses getState() for map access
- npm run typecheck passes
- Profiler shows scoped re-renders (not full tree)
  </done>
</task>

<task type="auto">
  <name>Defer minimap tile color computation to idle callback</name>
  <files>src/components/Minimap/Minimap.tsx</files>
  <action>
Replace synchronous tile color computation (lines 51-194) with requestIdleCallback:

**Step 1 — Extract computation into standalone function:**
```typescript
const buildTileColorCache = useCallback((tilesetImg: HTMLImageElement): Uint8Array | null => {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = TILE_SIZE;
  tempCanvas.height = TILE_SIZE;
  const tempCtx = tempCanvas.getContext('2d');
  if (!tempCtx) return null;

  const totalTiles = Math.floor(tilesetImg.height / TILE_SIZE) * TILES_PER_ROW;
  const colorCache = new Uint8Array(totalTiles * 3);

  // All existing logic from lines 64-88 (sampling 256 pixels per tile)
  for (let tileId = 0; tileId < totalTiles; tileId++) {
    // ... existing code (clearRect, drawImage, getImageData, averaging, etc.)
  }

  return colorCache;
}, []);
```

**Step 2 — Wrap in requestIdleCallback:**
Replace useEffect at lines 51-194 with:
```typescript
useEffect(() => {
  if (!tilesetImage || lastTilesetRef.current === tilesetImage) return;
  lastTilesetRef.current = tilesetImage;

  const idleCallbackId = requestIdleCallback((deadline) => {
    // Build cache during idle time
    if (deadline.timeRemaining() > 0 || deadline.didTimeout) {
      const colorCache = buildTileColorCache(tilesetImage);
      if (colorCache) {
        tileColorCacheRef.current = colorCache;
        // Force redraw after cache built (optional — minimap already redraws on map change)
      }

      // Build special color map (lines 93-194)
      const specialColors = new Map<number, [number, number, number]>();
      // ... existing special color logic
      specialColorMapRef.current = specialColors;

      // Build anim color cache (lines 149-194)
      // ... existing anim color logic
      animColorCacheRef.current = animCache;
    }
  }, { timeout: 2000 }); // Fallback: execute within 2s even if not idle

  return () => cancelIdleCallback(idleCallbackId);
}, [tilesetImage, buildTileColorCache]);
```

**Step 3 — Handle missing cache gracefully:**
In draw function, check if cache exists:
```typescript
if (!tileColorCacheRef.current) {
  // Show placeholder or skip rendering until cache ready
  ctx.fillStyle = '#808080';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.font = '10px sans-serif';
  ctx.fillText('Loading...', 40, 64);
  return;
}
```

**Alternative if requestIdleCallback causes issues:** Use setTimeout with 0ms delay to yield to main thread:
```typescript
setTimeout(() => {
  const colorCache = buildTileColorCache(tilesetImage);
  // ... rest of logic
}, 0);
```

Pattern from research (37-RESEARCH.md lines 314-326, 558-566): requestIdleCallback with timeout fallback for deferred non-critical work.
  </action>
  <verify>
Run `npm run typecheck` — zero errors.

Manual test:
1. Open app, load tileset.png
2. Check console for "Loading..." text in minimap (brief flash)
3. Minimap renders color preview after ~100-500ms (depends on idle time)
4. During load, try panning canvas → should be responsive (not frozen)

Performance test:
1. Open DevTools Performance tab
2. Record session, reload app (Ctrl+R)
3. Stop recording after 3 seconds
4. Check for long tasks (>50ms) in main thread
5. Before fix: getImageData loop shows as 100-300ms blocking task
6. After fix: no blocking task (computation in idle callback)
  </verify>
  <done>
- Minimap computation wrapped in requestIdleCallback
- Draw function handles missing cache gracefully (shows placeholder)
- npm run typecheck passes
- Performance tab shows no blocking tasks >50ms during tileset load
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete phase 37 performance optimizations: conditional animation loop, granular state sync, split selectors, decoupled canvas layers, removed root map subscription, deferred minimap computation.
  </what-built>
  <how-to-verify>
**Idle CPU Test:**
1. Open AC Map Editor
2. Create new map (File > New or toolbar New button)
3. Don't interact — wait 10 seconds
4. Open Task Manager (Ctrl+Shift+Esc)
5. Find "AC Map Editor" process
6. CPU usage should be 0-1% (not 3-8%)

**Animation Pause Test:**
1. Place animated tile (open Animation panel, click any animation, click canvas)
2. Scroll animated tile off-screen (pan viewport so tile not visible)
3. Task Manager: CPU should drop to 0-1%
4. Scroll tile back on-screen → CPU increases slightly (animation running)
5. Switch to different tab (e.g., browser)
6. Return to AC Map Editor tab
7. Animation should have paused (check Zustand DevTools: animationFrame stopped incrementing while tab hidden)

**Re-render Scope Test:**
1. Open React DevTools (F12 > Components tab > Profiler)
2. Click "Record" (red circle)
3. Place one tile on canvas (Pencil tool, single click)
4. Stop recording
5. Profiler flamegraph should show ONLY MapCanvas + Minimap rendered
6. Should NOT show: App, Toolbar, TilesetPanel, AnimationPanel, StatusBar
7. Before fix: entire tree re-renders on tile placement
8. After fix: scoped to MapCanvas + Minimap

**Minimap Load Test:**
1. Reload app (Ctrl+R)
2. Watch minimap area (bottom-right panel)
3. Should briefly show "Loading..." placeholder
4. Should render colored minimap within 0.5-2 seconds
5. During load, try panning canvas → should be responsive (not frozen)
6. Open DevTools Performance tab, record reload, check for long tasks
7. Should see NO blocking tasks >50ms (computation in idle callback)

**Expected Results:**
- Idle CPU: 0-1% (was 3-8%)
- Animation pauses when tiles off-screen or tab hidden
- Tile placement re-renders 2 components (was 10+)
- Minimap loads without freezing UI

**If any test fails:**
Describe which test failed and observed behavior (e.g., "Idle CPU still at 5%", "Animation doesn't pause when tab hidden").
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues if any test fails</resume-signal>
</task>

</tasks>

<verification>
**Comprehensive idle test:**
- Open map, don't interact
- Task Manager: CPU at 0-1% (all optimizations combined)
- No animated tiles visible, no selection active
- Profiler: zero commits during 10-second idle period

**Full re-render scope test:**
- Record Profiler session
- Perform: pan viewport, place tile, change tool, create selection
- Each action shows ONLY relevant components rendered:
  - Pan viewport: MapCanvas + Minimap (not Toolbar, TilesetPanel, etc.)
  - Place tile: MapCanvas + Minimap (not entire tree)
  - Change tool: Toolbar + MapCanvas overlay (not static layers)
  - Create selection: MapCanvas overlay only (not static/anim/grid layers)

**Startup responsiveness test:**
- Reload app
- Immediately try panning canvas after tileset loads
- Should be responsive (not frozen during minimap computation)
</verification>

<success_criteria>
- [ ] App renders idle at <1% CPU (PERF-01)
- [ ] Animation loop pauses when no animated tiles visible (PERF-02)
- [ ] Canvas layers redraw independently (PERF-03)
- [ ] Store operations don't cause cascading re-renders (PERF-04)
- [ ] MapCanvas re-renders scoped to changed data (PERF-05)
- [ ] Minimap computation doesn't block main thread (PERF-06)
- [ ] npm run typecheck passes with zero errors
- [ ] All human verification tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/37-render-state-performance/37-03-SUMMARY.md`
</output>
