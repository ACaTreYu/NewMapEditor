---
phase: 37-render-state-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/AnimationPanel/AnimationPanel.tsx
  - src/core/editor/EditorState.ts
autonomous: true

must_haves:
  truths:
    - "Animation loop only runs when animated tiles visible on any active viewport"
    - "Animation loop pauses when window is in background (tab hidden)"
    - "Store operations only sync fields that actually changed, not all 8+ fields"
    - "Idle app renders at <1% CPU usage"
  artifacts:
    - path: "src/components/AnimationPanel/AnimationPanel.tsx"
      provides: "Conditional animation loop with visibility detection"
      contains: "hasVisibleAnimatedTiles"
      min_lines: 100
    - path: "src/core/editor/EditorState.ts"
      provides: "Granular state sync (per-field, not blanket)"
      contains: "setViewport.*set\\(\\{ viewport:"
      min_lines: 600
  key_links:
    - from: "src/components/AnimationPanel/AnimationPanel.tsx"
      to: "advanceAnimationFrame"
      via: "Conditional call in RAF loop"
      pattern: "if.*hasVisibleAnimatedTiles.*advanceAnimationFrame"
    - from: "src/core/editor/EditorState.ts"
      to: "setViewportForDocument"
      via: "Granular sync (viewport only)"
      pattern: "setViewportForDocument.*set\\(\\{ viewport:"
---

<objective>
Eliminate idle CPU waste from perpetual animation loop and cascading state syncs.

Purpose: Animation loop currently runs 6-8 FPS even with no animated tiles visible, and syncTopLevelFields() updates 8 fields on every action, triggering unrelated re-renders. This plan stops both sources of idle work.

Output: Conditional animation loop that pauses when no work needed + granular state sync that updates only changed fields.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:\NewMapEditor\.planning\PROJECT.md
@E:\NewMapEditor\.planning\ROADMAP.md
@E:\NewMapEditor\.planning\STATE.md
@E:\NewMapEditor\.planning\phases\37-render-state-performance\37-RESEARCH.md
@E:\NewMapEditor\src\components\AnimationPanel\AnimationPanel.tsx
@E:\NewMapEditor\src\core\editor\EditorState.ts
</context>

<tasks>

<task type="auto">
  <name>Conditional animation loop with visibility detection</name>
  <files>src/components/AnimationPanel/AnimationPanel.tsx</files>
  <action>
Replace perpetual RAF loop (lines 42-60) with conditional animation loop:

1. Add hasVisibleAnimatedTiles() function:
   - Subscribe to documents Map from useEditorStore
   - For EACH document in documents.values(), check if animated tiles (bit 15 set) exist in visible viewport
   - Use viewport from each document's state (not top-level viewport)
   - Return true if ANY document has visible animated tiles, false otherwise
   - Visible viewport calculation: getVisibleTiles() equivalent for each document

2. Add Page Visibility API listener:
   - Create isPaused state based on document.hidden
   - Add visibilitychange event listener in useEffect cleanup
   - Pause animation when document.hidden is true

3. Modify RAF loop (line 47-52):
   - Only call advanceAnimationFrame() if: !document.hidden AND hasVisibleAnimatedTiles()
   - Keep RAF running (don't cancel) to avoid startup lag
   - Just skip state update when conditions not met

CRITICAL: Do NOT use top-level state.map or state.viewport — must check all open documents (MDI app). Iterate state.documents.values().

Pattern from research (37-RESEARCH.md lines 97-122): Page Visibility API + hasVisibleAnimatedTiles check inside RAF callback.
  </action>
  <verify>
Run `npm run typecheck` — zero errors.

Manual test:
1. Open map with no animated tiles → Zustand DevTools shows animationFrame NOT incrementing
2. Place animated tile (ID >= 173) on canvas → animationFrame starts incrementing
3. Scroll animated tile off-screen → animationFrame stops incrementing
4. Switch to different tab → animationFrame stops incrementing (Page Visibility API)
5. Return to tab → animationFrame resumes if animated tile visible
  </verify>
  <done>
- AnimationPanel.tsx contains hasVisibleAnimatedTiles() checking all documents
- RAF loop only calls advanceAnimationFrame() when tiles visible AND tab active
- npm run typecheck passes
- Animation pauses when no animated tiles visible on any viewport
  </done>
</task>

<task type="auto">
  <name>Granular state sync — eliminate syncTopLevelFields cascade</name>
  <files>src/core/editor/EditorState.ts</files>
  <action>
Replace blanket syncTopLevelFields() with granular per-field sync in wrapper actions (lines 300+):

**Analyze which actions exist** (grep "set.*: \\(.*\\) => {" to find all wrapper actions calling syncTopLevelFields).

**For EACH wrapper action:**

1. **If action only changes ONE field** (e.g., setViewport only changes viewport):
   - Replace: `set((state) => syncTopLevelFields(state))`
   - With: `const doc = get().documents.get(id); if (doc) { set({ viewport: doc.viewport }); }`
   - Sync ONLY the changed field, not all 8

2. **If action changes MULTIPLE fields** (e.g., undo changes map + undoStack + redoStack):
   - Sync only those 2-3 fields: `set({ map: doc.map, undoStack: doc.undoStack, redoStack: doc.redoStack })`

3. **If action is called in tight loops** (setTile during drag):
   - Consider eliminating top-level sync entirely (components subscribe to active doc directly)
   - Add comment: "// Top-level sync eliminated for performance — components use activeDocumentId subscription"

**Do NOT delete syncTopLevelFields function** — keep for reference, but ensure NO actions call it after refactor.

**Pattern targets** (from planning context):
- setViewport → sync viewport only
- setTile/setTiles → sync map only
- setSelection → sync selection only
- pushUndo/undo/redo → sync map + undoStack + redoStack
- copySelection/cutSelection → sync clipboard only
- setPastePreviewPosition → sync pastePreviewPosition only

**Verify all ~30 wrapper actions** are updated (search for "syncTopLevelFields" — should find ZERO calls after refactor, except in function definition).
  </action>
  <verify>
Run `npm run typecheck` — zero errors.

Grep for syncTopLevelFields calls:
```bash
grep -n "syncTopLevelFields(state)" src/core/editor/EditorState.ts
```
Should return ONLY the function definition line (67), NOT any action calls.

Manual test:
1. Open two documents
2. In document 1, pan viewport → Zustand DevTools shows ONLY viewport updated, not map/selection/undoStack
3. Place a tile → shows ONLY map updated
4. Undo → shows map + undoStack + redoStack updated (but NOT viewport/selection)
  </verify>
  <done>
- All wrapper actions use granular sync (only changed fields)
- Zero calls to syncTopLevelFields() in action bodies
- npm run typecheck passes
- Zustand DevTools shows targeted updates (not cascading 8-field syncs)
  </done>
</task>

</tasks>

<verification>
**Animation loop pause:**
- Place animated tile, open Task Manager → AC Map Editor at 0-1% CPU
- Scroll tile off-screen → CPU drops to 0%
- Switch to different tab → CPU at 0%

**Granular state sync:**
- Open React DevTools Profiler
- Record interaction: pan viewport
- Profiler shows MapCanvas re-rendered (viewport changed), but NOT undo buttons, AnimationPanel, TilesetPanel
- Before fix: all components re-render on viewport change
- After fix: only components subscribed to viewport re-render

**Combined idle test:**
- Open map, don't interact for 10 seconds
- Task Manager: AC Map Editor at 0-1% CPU
- Profiler: zero commits during idle period
</verification>

<success_criteria>
- [ ] Animation loop only runs when animated tiles visible on any active viewport (PERF-02)
- [ ] Animation loop pauses when window backgrounded (PERF-02)
- [ ] Store operations sync only changed fields, not all 8+ (PERF-04)
- [ ] Idle app renders at <1% CPU usage (PERF-01 partial)
- [ ] npm run typecheck passes with zero errors
- [ ] Manual verification shows targeted re-renders (not cascading)
</success_criteria>

<output>
After completion, create `.planning/phases/37-render-state-performance/37-01-SUMMARY.md`
</output>
