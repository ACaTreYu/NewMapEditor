---
phase: 39-minimize-restore-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/types.ts
  - src/core/editor/slices/windowSlice.ts
  - src/core/editor/slices/windowArrangement.ts
  - src/core/editor/EditorState.ts
autonomous: true

must_haves:
  truths:
    - "WindowState type has isMinimized, isMaximized, and savedBounds fields"
    - "Store has minimizeWindow, restoreWindow, maximizeWindow, unmaximizeWindow actions"
    - "Minimizing the active window auto-activates the next topmost non-minimized window"
    - "Restoring a minimized window returns it to its saved position and size"
    - "Maximizing a window saves current bounds and sets position to 0,0 with workspace dimensions"
    - "Unmaximizing a window restores saved bounds"
    - "Window arrangement functions filter out minimized windows"
    - "Closing the active document prefers non-minimized windows for auto-activation"
  artifacts:
    - path: "src/core/editor/slices/types.ts"
      provides: "Extended WindowState with isMinimized, isMaximized, savedBounds"
      contains: "isMinimized"
    - path: "src/core/editor/slices/windowSlice.ts"
      provides: "minimizeWindow, restoreWindow, maximizeWindow, unmaximizeWindow actions"
      contains: "minimizeWindow"
    - path: "src/core/editor/slices/windowArrangement.ts"
      provides: "Minimized window filtering in arrangement algorithms"
      contains: "isMinimized"
    - path: "src/core/editor/EditorState.ts"
      provides: "Updated closeDocument with non-minimized window preference"
      contains: "isMinimized"
  key_links:
    - from: "src/core/editor/slices/windowSlice.ts"
      to: "src/core/editor/slices/types.ts"
      via: "WindowState type import"
      pattern: "import.*WindowState.*from.*types"
    - from: "src/core/editor/EditorState.ts"
      to: "src/core/editor/slices/windowSlice.ts"
      via: "WindowSlice composition"
      pattern: "createWindowSlice"
---

<objective>
Add window state management for minimize, maximize, and restore functionality to the Zustand store.

Purpose: Provides the state foundation for MDI window controls. All minimize/maximize/restore logic lives in the store so UI components can simply call actions and read state.

Output: Extended WindowState type, four new window actions (minimizeWindow, restoreWindow, maximizeWindow, unmaximizeWindow), updated arrangement functions, updated close behavior.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/core/editor/slices/types.ts
@src/core/editor/slices/windowSlice.ts
@src/core/editor/slices/windowArrangement.ts
@src/core/editor/EditorState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend WindowState type and add window control actions</name>
  <files>
    src/core/editor/slices/types.ts
    src/core/editor/slices/windowSlice.ts
  </files>
  <action>
**types.ts** — Extend the `WindowState` interface with three new fields:

```typescript
export interface WindowState {
  x: number;
  y: number;
  width: number;
  height: number;
  zIndex: number;
  title: string;
  isMinimized: boolean;      // Window is minimized to bar
  isMaximized: boolean;      // Window fills workspace
  savedBounds: {             // Restore target when un-minimizing/un-maximizing
    x: number;
    y: number;
    width: number;
    height: number;
  } | null;
}
```

**windowSlice.ts** — Add four new actions to the `WindowSlice` interface and implement them:

1. **minimizeWindow(docId):**
   - Guard: if window doesn't exist or is already minimized, return early
   - If window is maximized, save the savedBounds from the current savedBounds (not the maximized dimensions)
   - Otherwise, save current { x, y, width, height } as savedBounds
   - Set isMinimized = true, isMaximized = false
   - If this was the active document (check state.activeDocumentId === docId), auto-activate the next topmost non-minimized window:
     - Filter windowStates to entries where id !== docId AND !isMinimized
     - Sort by zIndex descending
     - Set activeDocumentId to first match, or null if none
   - Return updated windowStates + activeDocumentId

2. **restoreWindow(docId):**
   - Guard: if window doesn't exist or is NOT minimized, return early
   - Restore position/size from savedBounds (with fallbacks to current values)
   - Set isMinimized = false, isMaximized = false, savedBounds = null
   - Set zIndex = state.nextZIndex (bring to front)
   - Increment nextZIndex
   - Set activeDocumentId = docId
   - Handle z-index normalization if threshold exceeded (same pattern as raiseWindow)

3. **maximizeWindow(docId):**
   - Guard: if window doesn't exist or is already maximized, return early
   - Save current { x, y, width, height } as savedBounds (only if not already minimized)
   - Query workspace dimensions: `document.querySelector('.workspace')?.clientWidth/clientHeight` with 1200/800 fallbacks
   - Set x=0, y=0, width=workspaceWidth, height=workspaceHeight
   - Set isMaximized = true, isMinimized = false
   - Set zIndex = state.nextZIndex (bring to front), increment nextZIndex
   - Set activeDocumentId = docId

4. **unmaximizeWindow(docId):**
   - Guard: if window doesn't exist or is NOT maximized, return early
   - Restore position/size from savedBounds (with fallbacks)
   - Set isMaximized = false, savedBounds = null

Also update **createWindowState** to initialize the new fields: `isMinimized: false, isMaximized: false, savedBounds: null`.

Export types properly so the WindowSlice interface includes all four new action signatures.
  </action>
  <verify>
Run `npm run typecheck` — should pass with zero errors. Verify the WindowSlice interface exports all four new actions.
  </verify>
  <done>
WindowState has isMinimized, isMaximized, savedBounds fields. WindowSlice has minimizeWindow, restoreWindow, maximizeWindow, unmaximizeWindow actions. createWindowState initializes new fields. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update arrangement functions and close behavior</name>
  <files>
    src/core/editor/slices/windowArrangement.ts
    src/core/editor/EditorState.ts
  </files>
  <action>
**windowArrangement.ts** — Update all three arrangement functions (cascadeWindows, tileWindowsHorizontal, tileWindowsVertical) to filter out minimized windows:

- At the start of each function, separate minimized windows from normal windows
- Only arrange non-minimized, non-maximized windows (pass through minimized/maximized windows unchanged)
- Minimized windows should be included in the result Map unchanged (preserving their isMinimized state)
- Maximized windows: unmaximize them as part of the arrangement (set isMaximized = false, restore savedBounds if available)
- Example approach:
  ```typescript
  const minimized: [string, WindowState][] = [];
  const arrangeable: [string, WindowState][] = [];
  for (const [id, state] of windowStates) {
    if (state.isMinimized) {
      minimized.push([id, state]);
    } else {
      // If maximized, restore to saved bounds first
      const restored = state.isMaximized && state.savedBounds
        ? { ...state, ...state.savedBounds, isMaximized: false, savedBounds: null }
        : state;
      arrangeable.push([id, restored]);
    }
  }
  // Arrange only arrangeable windows, then merge minimized back
  ```

**EditorState.ts** — Update the `closeDocument` override to prefer non-minimized windows when auto-activating:

In the closeDocument function, when `state.activeDocumentId === id`, instead of just picking the first remaining document, find the non-minimized window with the highest zIndex:

```typescript
if (state.activeDocumentId === id) {
  // Prefer non-minimized windows
  const windowStates = state.windowStates;
  const candidates = Array.from(newDocs.keys())
    .map(docId => ({ docId, ws: windowStates.get(docId) }))
    .filter(({ ws }) => ws && !ws.isMinimized)
    .sort((a, b) => (b.ws?.zIndex ?? 0) - (a.ws?.zIndex ?? 0));

  newActiveId = candidates.length > 0
    ? candidates[0].docId
    : (newDocs.size > 0 ? (newDocs.keys().next().value as string) : null);
}
```

This ensures closing the active document activates a visible window, only falling back to minimized windows if no normal windows remain.
  </action>
  <verify>
Run `npm run typecheck` — should pass with zero errors. Verify arrangement functions handle the isMinimized/isMaximized fields on WindowState.
  </verify>
  <done>
Arrangement functions skip minimized windows, un-maximize maximized windows during arrangement. closeDocument prefers non-minimized windows for auto-activation. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. WindowState type has isMinimized, isMaximized, savedBounds fields
3. WindowSlice interface declares minimizeWindow, restoreWindow, maximizeWindow, unmaximizeWindow
4. createWindowState initializes isMinimized=false, isMaximized=false, savedBounds=null
5. Arrangement functions filter minimized windows and un-maximize maximized windows
6. closeDocument prefers non-minimized windows when auto-activating
</verification>

<success_criteria>
All state management for minimize/maximize/restore is in place. TypeScript compiles with zero errors. The store exposes all four new actions. Window arrangement and close behavior properly account for minimize/maximize state.
</success_criteria>

<output>
After completion, create `.planning/phases/39-minimize-restore-controls/39-01-SUMMARY.md`
</output>
