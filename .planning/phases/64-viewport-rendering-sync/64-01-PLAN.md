---
phase: 64-viewport-rendering-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Tiles render smoothly during viewport pan drag (no blank regions, no lag-then-snap)"
    - "Ruler measurements and map layer move together during pan (no drift between UI overlay and map)"
    - "Tool drags (pencil, rect, line, selection) render tiles progressively during drag operation"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Immediate viewport updates during pan drag"
      min_lines: 1800
      exports: ["MapCanvas"]
  key_links:
    - from: "handleMouseMove pan drag"
      to: "setViewport()"
      via: "synchronous Zustand commit"
      pattern: "setViewport\\(\\{\\s*x:\\s*newX,\\s*y:\\s*newY\\s*\\}\\)"
    - from: "setViewport()"
      to: "CanvasEngine.blitToScreen()"
      via: "Zustand subscription"
      pattern: "this\\.blitToScreen\\(vp"
---

<objective>
Eliminate viewport rendering desynchronization by replacing CSS transform + deferred redraw pan pattern with immediate viewport updates and subscription-driven canvas blitting.

Purpose: Fix three rendering issues introduced by v2.7/v2.8 hybrid approach: (1) tiles lag during pan drag, (2) ruler overlay drifts from map layer, (3) tool drags don't show tiles progressively. Switch to scrollbar-style immediate updates leveraging v2.8 CanvasEngine's <1ms blit performance.

Output: MapCanvas.tsx with synchronous viewport updates during pan/tool drags, zero CSS transform usage, ruler overlay synchronized with map layer.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:\NewMapEditor\.planning\PROJECT.md
@E:\NewMapEditor\.planning\ROADMAP.md
@E:\NewMapEditor\.planning\STATE.md
@E:\NewMapEditor\.planning\phases\64-viewport-rendering-sync\64-RESEARCH.md
@E:\NewMapEditor\.planning\codebase\ARCHITECTURE.md
@E:\NewMapEditor\.planning\codebase\CONVENTIONS.md

# Prior phase context (v2.8 CanvasEngine architecture)
@E:\NewMapEditor\.planning\phases\48-real-time-pan-rendering\48-01-SUMMARY.md
@E:\NewMapEditor\.planning\phases\50-buffer-zone-over-rendering\50-01-SUMMARY.md
@E:\NewMapEditor\.planning\phases\51-extract-canvasengine-class\51-01-SUMMARY.md
@E:\NewMapEditor\.planning\phases\52-engine-subscribes-to-zustand\52-01-SUMMARY.md

# Critical source file
@E:\NewMapEditor\src\components\MapCanvas\MapCanvas.tsx
@E:\NewMapEditor\src\core\canvas\CanvasEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace CSS transform pan with immediate viewport updates</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
**Remove CSS transform pan pattern (lines 1651-1662):**

Current code applies CSS `translate()` to canvas elements during pan drag:
```typescript
if (isDragging && panStartRef.current) {
  const dx = e.clientX - panStartRef.current.mouseX;
  const dy = e.clientY - panStartRef.current.mouseY;
  const transform = `translate(${dx}px, ${dy}px)`;
  if (mapLayerRef.current) mapLayerRef.current.style.transform = transform;
  if (uiLayerRef.current) uiLayerRef.current.style.transform = transform;
  panDeltaRef.current = { dx, dy };
  requestProgressiveRender();
  return;
}
```

**Replace with immediate viewport update:**
```typescript
if (isDragging && panStartRef.current) {
  // Calculate new viewport from mouse delta
  const dx = e.clientX - panStartRef.current.mouseX;
  const dy = e.clientY - panStartRef.current.mouseY;
  const tilePixels = TILE_SIZE * panStartRef.current.viewportZoom;

  const canvas = uiLayerRef.current;
  const visibleTilesX = canvas ? canvas.width / tilePixels : 10;
  const visibleTilesY = canvas ? canvas.height / tilePixels : 10;
  const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTilesX);
  const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTilesY);

  const newX = Math.max(0, Math.min(maxOffsetX, panStartRef.current.viewportX - dx / tilePixels));
  const newY = Math.max(0, Math.min(maxOffsetY, panStartRef.current.viewportY - dy / tilePixels));

  // Immediate viewport commit (triggers CanvasEngine subscription → blitToScreen)
  setViewport({ x: newX, y: newY });

  // RAF-debounce UI overlay redraw (grid, ruler, cursor only)
  requestUiRedraw();
  return;
}
```

**Simplify commitPan (lines 1226-1262):**

Current commitPan calculates final viewport, pre-renders both layers, clears CSS transforms, then commits to Zustand. New pattern: viewport already committed during drag, just cleanup refs.

Replace commitPan implementation with:
```typescript
const commitPan = useCallback(() => {
  // Viewport already committed during drag (no deferred commit needed)
  // Just clean up drag state
  panStartRef.current = null;
  panDeltaRef.current = null;
}, []);
```

Update handleMouseUp to call simplified commitPan:
```typescript
if (isDragging && panStartRef.current) {
  commitPan();
  setIsDragging(false);
}
```

**Remove requestProgressiveRender infrastructure:**

Delete requestProgressiveRender function (lines ~1205-1224) and all supporting state:
- `rafIdRef` refs
- `panRenderCount` state
- RAF cancellation logic in commitPan

These are no longer needed — CanvasEngine subscriptions handle all map layer rendering.

**Remove setPanRenderCount dependency from drawMapLayer:**

Current drawMapLayer useCallback has `[..., setPanRenderCount]` in deps array. Remove this — no longer triggering React re-renders for scrollbar sync (Zustand viewport updates handle it).

**Keep UI overlay RAF debouncing:**

`requestUiRedraw()` function (RAF-debounced drawUiLayer) should remain unchanged. This continues to throttle grid/ruler/cursor redraws to 60fps (acceptable 1-frame lag for decorative elements).

**Verification points:**
- CSS transform lines removed from handleMouseMove pan drag block
- Immediate `setViewport()` call during pan drag (every mousemove)
- commitPan simplified to ref cleanup only (no viewport calculation, no pre-render, no CSS transform clearing)
- requestProgressiveRender function deleted
- panRenderCount state and setPanRenderCount calls removed
- Tool drag patterns (pencil, line, rect, selection) remain unchanged (already using CanvasEngine immediate rendering)
  </action>
  <verify>
```bash
# Verify CSS transform removed from pan drag
! grep -n "style.transform = transform" src/components/MapCanvas/MapCanvas.tsx

# Verify immediate setViewport during pan
grep -n "setViewport({ x: newX, y: newY })" src/components/MapCanvas/MapCanvas.tsx

# Verify simplified commitPan (no drawMapLayer, no CSS transform clearing)
grep -A 5 "const commitPan = useCallback" src/components/MapCanvas/MapCanvas.tsx | grep -v "drawMapLayer\|style.transform"

# Verify requestProgressiveRender deleted
! grep -n "requestProgressiveRender" src/components/MapCanvas/MapCanvas.tsx

# TypeScript compilation passes
npm run typecheck
```
  </verify>
  <done>
MapCanvas.tsx no longer uses CSS transforms during pan drag. Pan drag updates viewport state immediately on every mousemove. CanvasEngine subscription handles map layer blitting. commitPan simplified to ref cleanup. requestProgressiveRender infrastructure removed. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify blit performance and layer synchronization</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
**Add performance measurement to verify <1ms blit assumption:**

In src/core/canvas/CanvasEngine.ts, add performance logging to viewport subscription (temporary for verification):

```typescript
// In setupSubscriptions(), viewport subscription block (line ~411):
const unsubViewport = useEditorStore.subscribe((state, prevState) => {
  if (!this.screenCtx) return;
  const vp = this.getViewport(state);
  const prevVp = this.getViewport(prevState);
  if (vp !== prevVp) {
    const t0 = performance.now();
    this.blitToScreen(vp, this.screenCtx.canvas.width, this.screenCtx.canvas.height);
    const t1 = performance.now();
    if (t1 - t0 > 2) {
      console.warn(`[CanvasEngine] Slow blit: ${(t1 - t0).toFixed(2)}ms (viewport: ${vp.x.toFixed(1)}, ${vp.y.toFixed(1)}, ${vp.zoom}x)`);
    }
  }
});
```

This logs only if blit takes >2ms (acceptable threshold). No logs during testing = <2ms confirmed.

**Test plan execution:**

1. Open existing map (e.g., test map with content)
2. Pan drag horizontally and vertically across entire map (0,0 to 255,255)
3. Pan at different zoom levels (0.25x, 1x, 4x)
4. Pan quickly with rapid mouse movement
5. Use ruler tool during pan (verify overlay stays aligned with map)
6. Use pencil drag during pan (verify tiles render progressively)
7. Use selection marquee during pan (verify marching ants stay synchronized)

**Success criteria:**
- No blank canvas regions during pan drag
- No visible snap-back when releasing mouse
- Ruler overlay measurements stay aligned with tile grid (no drift)
- Marching ants selection border stays aligned with tiles
- Console shows zero slow blit warnings (or <5 warnings during fast pan across 256x256 map)

**If blit performance >2ms consistently:**

Fall back to RAF throttling for pan only:
1. Restore panDeltaRef tracking
2. Add RAF-debounced viewport update function
3. Call RAF function from handleMouseMove instead of immediate setViewport
4. Document as intentional tradeoff (1-frame lag acceptable for performance)

Do NOT use this fallback unless testing reveals actual performance issues. Research suggests <1ms is achievable.

**Remove performance logging after verification:**

Once testing confirms <2ms blit performance, remove the `performance.now()` logging and console.warn from CanvasEngine viewport subscription. This was temporary verification only.
  </action>
  <verify>
```bash
# Manual testing verification (perform all steps in action section)
# Automated checks:

# Verify performance logging added to CanvasEngine
grep -n "performance.now()" src/core/canvas/CanvasEngine.ts

# Launch app and test pan performance
npm run electron:dev
# (Tester performs manual pan test, checks console for slow blit warnings)

# After testing complete, verify performance logging removed
! grep -n "performance.now()" src/core/canvas/CanvasEngine.ts
```
  </verify>
  <done>
Blit performance verified <2ms at all zoom levels. Pan drag renders tiles smoothly with no blank regions. Ruler overlay and map layer stay synchronized (no drift). Tool drags (pencil, selection) render progressively. Performance logging removed from CanvasEngine. Success criteria met for REND-01 and REND-02.
  </done>
</task>

</tasks>

<verification>
**Manual testing checklist:**
- [ ] Open map with content
- [ ] Pan drag horizontally across map (smooth tile rendering, no blank regions)
- [ ] Pan drag vertically across map (smooth tile rendering)
- [ ] Pan at 0.25x zoom (tiles render correctly at low zoom)
- [ ] Pan at 4x zoom (tiles render correctly at high zoom)
- [ ] Pan quickly with rapid mouse movement (no lag, no snap-back)
- [ ] Use ruler tool during pan (overlay measurements stay aligned with tiles)
- [ ] Draw with pencil during pan (tiles render progressively)
- [ ] Create selection marquee during pan (marching ants stay synchronized)

**Automated checks:**
```bash
# Code verification
! grep -n "style.transform = transform" src/components/MapCanvas/MapCanvas.tsx  # CSS transform removed
grep -n "setViewport({ x: newX, y: newY })" src/components/MapCanvas/MapCanvas.tsx  # Immediate viewport update present
! grep -n "requestProgressiveRender" src/components/MapCanvas/MapCanvas.tsx  # Progressive render infrastructure removed

# TypeScript compilation
npm run typecheck  # Zero errors

# Performance verification
# (Perform manual pan testing, verify console shows zero or minimal slow blit warnings)
```

**Requirements traceability:**
- REND-01: Viewport pan and tool drags render tiles smoothly during drag → Task 1 (immediate viewport updates) + Task 2 (performance verification)
- REND-02: Ruler overlay and map layer stay in sync during viewport panning → Task 1 (synchronous viewport updates eliminate CSS transform drift)
</verification>

<success_criteria>
**Observable behaviors (what must be TRUE):**
1. Tiles render smoothly during viewport pan drag (no blank regions, no lag-then-snap)
2. Ruler measurements and map layer move together during pan (no drift between UI overlay and map)
3. Tool drags (pencil, rect, line, selection) render tiles progressively during drag operation

**Code state (what must EXIST):**
1. MapCanvas.tsx handleMouseMove pan block uses `setViewport({ x, y })` immediately (not CSS transform)
2. commitPan function simplified to ref cleanup only (no drawMapLayer, no CSS transform clearing)
3. requestProgressiveRender function and supporting infrastructure removed
4. CanvasEngine viewport subscription triggers blitToScreen in <2ms
5. TypeScript compilation passes with zero errors

**Key connections (what must be WIRED):**
1. handleMouseMove pan drag → setViewport() → CanvasEngine subscription → blitToScreen() → screen canvas updated
2. UI overlay redraw uses RAF debouncing (1-frame lag acceptable for grid/ruler/cursor)
3. Tool drags continue using CanvasEngine immediate paintTile pattern (no changes needed)
</success_criteria>

<output>
After completion, create `.planning/phases/64-viewport-rendering-sync/64-01-SUMMARY.md`

Document:
- Performance measurements (actual blit times from testing)
- Any fallback decisions (if RAF throttling needed for performance)
- Visual verification results (ruler overlay sync, tile rendering smoothness)
- Deviations from plan (if any performance optimizations required)
</output>
