---
phase: 72-9e-warp-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/map/GameObjectSystem.ts
  - src/core/editor/slices/documentsSlice.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Animated warp (3x3 block) center tile encodes src/dest routing when placed"
    - "Picker tool extracts routing from 0x9E tiles and syncs to Source/Dest dropdowns"
    - "Border tiles of animated warp block have offset=0 (no routing data)"
    - "Single warp (0xFA) placement and picker decoding unchanged (no regression)"
  artifacts:
    - path: "src/core/map/GameObjectSystem.ts"
      provides: "placeAnimatedWarp with src/dest routing signature"
      contains: "placeAnimatedWarp(map: MapData, x: number, y: number, src: number"
    - path: "src/core/editor/slices/documentsSlice.ts"
      provides: "Warp dispatch routing warpSrc/warpDest to animated warp"
      contains: "placeAnimatedWarp(doc.map, x, y, warpSrc, warpDest)"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Picker decodes 0x9E routing alongside 0xFA"
      contains: "animId === 0xFA || animId === 0x9E"
  key_links:
    - from: "src/core/editor/slices/documentsSlice.ts"
      to: "src/core/map/GameObjectSystem.ts"
      via: "placeAnimatedWarp(doc.map, x, y, warpSrc, warpDest)"
      pattern: "placeAnimatedWarp.*warpSrc.*warpDest"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "warp routing decode"
      via: "animId === 0xFA || animId === 0x9E condition"
      pattern: "animId === 0xFA \\|\\| animId === 0x9E"
---

<objective>
Extend warp routing from single-tile 0xFA warps to the center tile (0x9E) of 3x3 animated warp blocks, enabling animated warps to function as gameplay warps with src/dest routing data.

Purpose: Animated warps placed by the warp tool should encode routing data (source/destination) in the center tile, just like single warps do. This completes the warp routing system so both warp variants are fully functional gameplay objects.

Output: Three files surgically modified — GameObjectSystem signature, documentsSlice dispatch, MapCanvas picker condition.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/72-9e-warp-routing/72-RESEARCH.md
@src/core/map/GameObjectSystem.ts
@src/core/editor/slices/documentsSlice.ts
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Route warp src/dest to animated warp placement</name>
  <files>
    src/core/map/GameObjectSystem.ts
    src/core/editor/slices/documentsSlice.ts
  </files>
  <action>
**GameObjectSystem.ts — Change `placeAnimatedWarp` signature and implementation (lines 133-138):**

Replace the current method:
```typescript
placeAnimatedWarp(map: MapData, x: number, y: number, offset: number = 0): boolean {
  const patternWithOffset = ANIMATED_WARP_PATTERN.map(tile =>
    (tile & 0x8000) ? makeAnimatedTile(tile & 0xFF, offset) : tile
  );
  return this.stamp3x3(map, x, y, patternWithOffset);
}
```

With:
```typescript
placeAnimatedWarp(map: MapData, x: number, y: number, src: number = 0, dest: number = 0): boolean {
  const routingOffset = dest * 10 + src;

  const patternWithOffset = ANIMATED_WARP_PATTERN.map((tile, index) => {
    if (!(tile & 0x8000)) return tile;
    const animId = tile & 0xFF;

    if (index === 4 && animId === 0x9E) {
      // Center tile: encode routing
      return makeAnimatedTile(animId, routingOffset);
    } else {
      // Border tiles: no offset (pure animation)
      return makeAnimatedTile(animId, 0);
    }
  });

  return this.stamp3x3(map, x, y, patternWithOffset);
}
```

Key points:
- Signature changes from `offset: number` to `src: number, dest: number` — reflects domain intent (routing, not animation offset)
- Center tile (index 4, animId 0x9E) encodes `dest*10 + src` as offset — identical to 0xFA encoding
- Border tiles (indices 0-3, 5-8) get offset=0 — they are decorative, not functional warps
- `routingOffset` range 0-99 fits safely in 7-bit offset field (max 127)

**documentsSlice.ts — Change animated warp dispatch (around line 843-844):**

Replace:
```typescript
success = gameObjectSystem.placeAnimatedWarp(doc.map, x, y, animationOffsetInput);
```

With:
```typescript
success = gameObjectSystem.placeAnimatedWarp(doc.map, x, y, warpSrc, warpDest);
```

This routes the warp routing state (`warpSrc`/`warpDest` from dropdown controls) instead of the generic animation offset input. Both warp variants (single + animated) now use the same routing state.

Verify that `warpSrc` and `warpDest` are already destructured in scope — they should be, since the single warp variant on the next line uses them.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero new TypeScript errors. Grep for `placeAnimatedWarp` to confirm the old `offset` parameter signature is gone and both call sites use `src/dest` pattern.
  </verify>
  <done>
`placeAnimatedWarp` accepts `src`/`dest` parameters, encodes routing in center tile only, and documentsSlice passes `warpSrc`/`warpDest` from UI state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend picker to decode 0x9E warp routing</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
**MapCanvas.tsx — Extend picker warp routing condition (around line 1963-1965):**

Replace the comment and condition:
```typescript
// Decode warp routing if it's a warp tile (animId 0xFA)
const animId = getAnimationId(pickedTile);
if (animId === 0xFA) {
```

With:
```typescript
// Decode warp routing if it's a warp tile (animId 0xFA or 0x9E)
const animId = getAnimationId(pickedTile);
if (animId === 0xFA || animId === 0x9E) {
```

This is a single-line change. The decoding logic inside the if-block (`offset % 10` for src, `floor(offset / 10)` for dest) is identical for both animation IDs — same encoding scheme, same decode.

Edge case behavior (acceptable):
- Picking a border tile (0x9A-0x9D, 0x9F-0xA2) with offset=0 extracts src=0, dest=0 (resets dropdowns — user learns only center tile has routing)
- Picking an old v3.2 map center tile (0x9E with offset=0) extracts src=0, dest=0 (correct — no routing was encoded)
  </action>
  <verify>
Run `npx tsc --noEmit` — zero new TypeScript errors. Grep for `0x9E` in MapCanvas.tsx to confirm the condition is present.
  </verify>
  <done>
Picker tool decodes warp routing from both 0xFA and 0x9E animation IDs, syncing Source/Dest dropdowns for the inspect-adjust-replace workflow.
  </done>
</task>

</tasks>

<verification>
1. **TypeScript:** `npx tsc --noEmit` passes with zero new errors
2. **Signature check:** `grep -n "placeAnimatedWarp" src/core/map/GameObjectSystem.ts` shows `src: number, dest: number` signature
3. **Dispatch check:** `grep "placeAnimatedWarp" src/core/editor/slices/documentsSlice.ts` shows `warpSrc, warpDest` arguments
4. **Picker check:** `grep "0x9E" src/components/MapCanvas/MapCanvas.tsx` shows `animId === 0xFA || animId === 0x9E`
5. **No regression:** `grep "placeWarp" src/core/editor/slices/documentsSlice.ts` still shows single warp using `warpStyle, warpSrc, warpDest`
</verification>

<success_criteria>
- Animated warp center tile (0x9E) encodes routing data using `dest*10 + src` in offset field
- Animated warp border tiles have offset=0 (decorative, not functional)
- Warp tool animated variant uses `warpSrc/warpDest` state (not `animationOffsetInput`)
- Picker decodes routing from 0x9E tiles identically to 0xFA tiles
- No regression to single warp (0xFA) placement or picking
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/72-9e-warp-routing/72-01-SUMMARY.md`
</output>
