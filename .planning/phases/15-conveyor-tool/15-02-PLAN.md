---
phase: 15-conveyor-tool
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "User can press Escape during any rect drag to cancel placement"
    - "Cancelled drag does not place any tiles and resets drag state"
    - "Live preview during CONVEYOR drag shows actual tile pattern filling the rectangle"
    - "Preview updates as user moves mouse during drag"
    - "Preview shows correct H or V pattern based on selected conveyor direction"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Escape key cancellation and live tile preview for CONVEYOR drag"
      contains: "Escape"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "EditorState.rectDragState"
      via: "setRectDragState to cancel on Escape"
      pattern: "setRectDragState.*active.*false"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "GameObjectData convLrData/convUdData"
      via: "import for live preview tile calculation"
      pattern: "conv(Lr|Ud)Data"
---

<objective>
Add Escape key cancellation for rect drag operations and live tile pattern preview during CONVEYOR tool drag. Currently the rect drag only shows a dashed outline with dimensions. This plan adds: (1) pressing Escape during any rect drag cancels it without placing tiles, and (2) when dragging with the CONVEYOR tool, the actual tile pattern is rendered inside the drag rectangle as a live preview.

Purpose: Escape cancel improves UX for all rect tools (CONV-03). Live preview lets users see exactly what conveyor tiles will look like before releasing (CONV-04).

Output: Enhanced MapCanvas.tsx with Escape handling and conveyor preview rendering.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-conveyor-tool/15-CONTEXT.md
@.planning/phases/15-conveyor-tool/15-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
@src/core/map/GameObjectSystem.ts (placeConveyor method for pattern reference)
@src/core/map/GameObjectData.ts (convLrData, convUdData arrays)
@src/core/map/types.ts (ToolType, RectDragState)
@src/core/editor/EditorState.ts (rectDragState, gameObjectToolState.conveyorDir)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Escape key cancellation for rect drag</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Add a `useEffect` that listens for the Escape key when `rectDragState.active` is true. When Escape is pressed:

1. Call `setRectDragState({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 })` to cancel the drag
2. Prevent default behavior on the event

```tsx
useEffect(() => {
  if (!rectDragState.active) return;
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      setRectDragState({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 });
    }
  };
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [rectDragState.active, setRectDragState]);
```

This handles Escape cancel for ALL rect drag tools (BUNKER, HOLDING_PEN, BRIDGE, CONVEYOR, WALL_RECT).

Also add Escape handling for line state (wall/line tools) for consistency:
```tsx
useEffect(() => {
  if (!lineState.active) return;
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      setLineState({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 });
    }
  };
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [lineState.active]);
```
  </action>
  <verify>
1. Run `npm run typecheck` -- no TypeScript errors
2. Activate CONVEYOR tool, start drag on canvas, press Escape -- drag cancels, no tiles placed
3. Same test with BUNKER, BRIDGE tools -- Escape cancels drag
4. Same test with WALL and LINE tools -- Escape cancels line draw
  </verify>
  <done>
Pressing Escape during any rect drag or line draw operation cancels it without placing tiles. Drag state resets to inactive.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add live tile preview during CONVEYOR drag</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Enhance the rect drag preview rendering in the `draw()` function to show actual conveyor tile patterns when the CONVEYOR tool is active.

**Step 1: Import conveyor data**

Add to imports at top of MapCanvas.tsx:
```ts
import { convLrData, convUdData } from '@core/map/GameObjectData';
```

Also need access to `gameObjectToolState` from the store. Add `gameObjectToolState` to the destructured store values.

**Step 2: Enhance rect drag preview rendering**

In the `draw()` callback, find the section that renders the rect drag outline (the block starting with `if (rectDragState.active)`). BEFORE the dashed outline drawing, add tile pattern preview for CONVEYOR:

```tsx
if (rectDragState.active) {
  const minX = Math.min(rectDragState.startX, rectDragState.endX);
  const minY = Math.min(rectDragState.startY, rectDragState.endY);
  const maxX = Math.max(rectDragState.startX, rectDragState.endX);
  const maxY = Math.max(rectDragState.startY, rectDragState.endY);
  const w = maxX - minX + 1;
  const h = maxY - minY + 1;

  // Live tile preview for CONVEYOR tool
  if (currentTool === ToolType.CONVEYOR && tilesetImage && w >= 2 && h >= 2) {
    const convDir = gameObjectToolState.conveyorDir;
    const convData = convDir === 0 ? convLrData : convUdData;
    if (convData.length > 0 && convData[0][0] !== 0) {
      const data = convData[0];

      // Render conveyor tiles using same algorithm as GameObjectSystem.placeConveyor
      ctx.globalAlpha = 0.7; // Semi-transparent preview

      for (let k = 0; k < h; k++) {
        for (let hh = 0; hh < w; hh++) {
          let tile: number | undefined;

          if (convDir === 1) {
            // UD conveyor
            if (w % 2 !== 0 && hh === w - 1) continue;
            if (k === 0)
              tile = data[hh % 2];
            else if (k === h - 1)
              tile = data[hh % 2 + 6];
            else
              tile = data[(k % 2 + 1) * 2 + hh % 2];
          } else {
            // LR conveyor
            if (h % 2 !== 0 && k === h - 1) continue;
            if (hh === 0)
              tile = data[(k % 2) * 4];
            else if (hh === w - 1)
              tile = data[(k % 2) * 4 + 3];
            else
              tile = data[1 + (k % 2) * 4 + hh % 2];
          }

          if (tile !== undefined) {
            const screenX = (minX + hh - viewport.x) * tilePixels;
            const screenY = (minY + k - viewport.y) * tilePixels;

            // Check if tile is animated
            const isAnim = (tile & 0x8000) !== 0;
            if (isAnim && tilesetImage) {
              const animId = tile & 0xFF;
              const frameOffset = (tile >> 8) & 0x7F;
              const anim = ANIMATION_DEFINITIONS[animId];
              if (anim && anim.frames.length > 0) {
                const frameIdx = (animationFrame + frameOffset) % anim.frameCount;
                const displayTile = anim.frames[frameIdx] || 0;
                const srcX = (displayTile % TILES_PER_ROW) * TILE_SIZE;
                const srcY = Math.floor(displayTile / TILES_PER_ROW) * TILE_SIZE;
                ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE,
                  screenX, screenY, tilePixels, tilePixels);
              }
            } else if (tilesetImage) {
              const srcX = (tile % TILES_PER_ROW) * TILE_SIZE;
              const srcY = Math.floor(tile / TILES_PER_ROW) * TILE_SIZE;
              ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE,
                screenX, screenY, tilePixels, tilePixels);
            }
          }
        }
      }

      ctx.globalAlpha = 1.0; // Restore
    }
  }

  // [Existing validity check and dashed outline code stays here]
  // ...
}
```

**Key details:**
- The tile preview algorithm MUST exactly match `GameObjectSystem.placeConveyor()` logic for LR and UD directions (the skip conditions for odd width/height, the data indexing)
- Use `ctx.globalAlpha = 0.7` for semi-transparent preview so user can see existing tiles underneath
- Restore `ctx.globalAlpha = 1.0` after the preview so the outline and labels render at full opacity
- Handle animated tiles (conveyor tiles typically ARE animated, bit 15 set) by looking up their current frame from ANIMATION_DEFINITIONS
- The dashed outline still draws ON TOP of the tile preview for clear bounds
- Add `gameObjectToolState` to the draw callback's dependency array

**Step 3: Add gameObjectToolState to store destructure and draw deps**

In the store destructure near the top of the component, add:
```ts
gameObjectToolState,
```

In the `draw` useCallback dependency array, add `gameObjectToolState`.

**Performance note:** The preview only renders when rectDragState.active AND currentTool === CONVEYOR, so there is zero performance impact during normal editing. For very large rectangles (50x50+), the tile rendering loop is still fast because it's just drawImage calls with pre-loaded tileset.
  </action>
  <verify>
1. Run `npm run typecheck` -- no TypeScript errors
2. Run `npm run electron:dev` -- app launches
3. Load a custom.dat file (or verify convLrData/convUdData have data)
4. Select CONVEYOR tool, select Horizontal direction
5. Click-drag on canvas to define rectangle -- actual conveyor tile graphics appear semi-transparently inside the drag rectangle
6. Release mouse -- tiles are placed matching the preview
7. Repeat with Vertical direction -- correct UD pattern shown
8. Test with odd-width rectangle (LR dir) -- rightmost column correctly skipped in preview (matching SEdit)
9. Test with odd-height rectangle (UD dir) -- bottom row correctly skipped in preview
  </verify>
  <done>
Live tile pattern preview renders during CONVEYOR drag, showing actual conveyor graphics at 70% opacity. Preview updates as mouse moves and correctly matches the final placement pattern for both H and V directions, including edge-case handling for odd dimensions.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Escape key cancels any rect drag or line draw without placing tiles
3. CONVEYOR drag shows live tile preview matching actual placement result
4. Preview handles animated tiles correctly (shows current frame)
5. Existing rect tools (BUNKER, BRIDGE, HOLDING_PEN, WALL_RECT) still work correctly
6. No performance regression during normal editing
</verification>

<success_criteria>
- Escape cancels drag operations (CONV-03 polish)
- Live tile preview during CONVEYOR drag shows correct pattern (CONV-04 verification)
- Preview matches actual placement for both directions
- No regression in other tools
</success_criteria>

<output>
After completion, create `.planning/phases/15-conveyor-tool/15-02-SUMMARY.md`
</output>
