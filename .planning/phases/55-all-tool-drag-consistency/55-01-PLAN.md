---
phase: 55-all-tool-drag-consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/core/editor/slices/globalSlice.ts
autonomous: true

must_haves:
  truths:
    - "Rect drag (bunker/conveyor/wall_rect/bridge/holding_pen) causes zero React re-renders during mousemove"
    - "Rect drag Escape cancellation works via permanent listener (no listener churn)"
    - "Tool switch during active rect drag cancels the drag and redraws UI"
    - "Component unmount during active rect drag discards pending rectangle"
    - "Wall pencil has inline comment documenting Zustand exception (TOOL-02)"
    - "Selection drag still works correctly (ref-based from Phase 54)"
    - "rectDragState removed from Zustand GlobalSlice (no external consumers)"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "rectDragRef replacing rectDragState, tool switch cleanup, unmount cleanup"
      contains: "rectDragRef"
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "GlobalSlice without rectDragState"
  key_links:
    - from: "MapCanvas handleMouseDown"
      to: "rectDragRef.current"
      via: "direct ref mutation"
      pattern: "rectDragRef\\.current = \\{ active: true"
    - from: "MapCanvas handleMouseMove"
      to: "requestUiRedraw"
      via: "ref mutation + RAF redraw"
      pattern: "rectDragRef\\.current\\.active.*requestUiRedraw"
    - from: "MapCanvas handleMouseUp"
      to: "placeGameObjectRect"
      via: "read from ref, commit to Zustand"
      pattern: "rectDragRef\\.current\\.startX.*placeGameObjectRect"
    - from: "permanent Escape listener"
      to: "rectDragRef"
      via: "ref check and reset"
      pattern: "rectDragRef\\.current\\.active.*active: false"
---

<objective>
Convert rect drag state from Zustand to ref-based pattern, add edge case safety (tool switch, unmount), and remove rectDragState from GlobalSlice.

Purpose: Complete the ref-based drag pattern across all tools — rect drag is the last Zustand-based drag causing React re-renders during mousemove. This is the final phase of the v2.8 Canvas Engine milestone.

Output: Zero React re-renders during any drag operation. All TOOL-01 through TOOL-05 and PERF-04 requirements verified.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-decouple-cursor-ui-overlay/54-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
@src/core/editor/slices/globalSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert rect drag from Zustand to ref + remove from GlobalSlice</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
    src/core/editor/slices/globalSlice.ts
  </files>
  <action>
**In MapCanvas.tsx:**

1. **Add rectDragRef** (after selectionDragRef, line ~57):
   ```typescript
   const rectDragRef = useRef<{ active: boolean; startX: number; startY: number; endX: number; endY: number }>({
     active: false, startX: 0, startY: 0, endX: 0, endY: 0
   });
   ```

2. **Remove rectDragState from Zustand selector** (line ~116-124):
   - Remove `rectDragState: state.rectDragState` from the `useShallow` selector
   - Remove `rectDragState` destructure — keep only `selection`
   - The selector becomes: `const { selection } = useEditorStore(useShallow((state) => ({ selection: doc ? doc.selection : state.selection })));`

3. **Remove setRectDragState action selector** (line ~138):
   - Delete: `const setRectDragState = useEditorStore(state => state.setRectDragState);`

4. **Update drawUiLayer** — replace all `rectDragState` reads with `rectDragRef.current`:
   - Line ~415: `!rectDragState.active` → `!rectDragRef.current.active`
   - Line ~423-427: All `rectDragState.startX/endX/startY/endY` → `rectDragRef.current.startX/endX/startY/endY`
   - Remove `rectDragState` from the drawUiLayer deps array (line ~562). The ref is always current, no dep needed.

5. **Update handleMouseDown** (line ~890):
   - Replace `setRectDragState({ active: true, startX: x, startY: y, endX: x, endY: y })` with:
     ```typescript
     rectDragRef.current = { active: true, startX: x, startY: y, endX: x, endY: y };
     requestUiRedraw();
     ```

6. **Update handleMouseMove** (line ~959-961):
   - Replace `rectDragState.active` check and `setRectDragState({ endX: x, endY: y })` with:
     ```typescript
     } else if (rectDragRef.current.active) {
       const prevRect = rectDragRef.current;
       if (prevRect.endX !== x || prevRect.endY !== y) {
         rectDragRef.current = { ...prevRect, endX: x, endY: y };
         requestUiRedraw();
       }
     ```
   This adds deduplication (skips redraw if tile unchanged) and uses RAF instead of Zustand setState.

7. **Update handleMouseUp** (line ~1034-1038):
   - Replace `rectDragState.active` / `rectDragState.startX` etc with `rectDragRef.current`:
     ```typescript
     if (rectDragRef.current.active) {
       pushUndo();
       placeGameObjectRect(rectDragRef.current.startX, rectDragRef.current.startY,
                           rectDragRef.current.endX, rectDragRef.current.endY);
       commitUndo('Place game object');
       rectDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       requestUiRedraw();
     }
     ```

8. **Update handleMouseLeave** (line ~1095-1096):
   - Replace `rectDragState.active` / `setRectDragState(...)` with:
     ```typescript
     if (rectDragRef.current.active) {
       rectDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       requestUiRedraw();
     }
     ```

9. **Remove old rect drag Escape handler** (lines ~1281-1292):
   - Delete the entire `useEffect` block that handles Escape for rectDragState:
     ```typescript
     // Escape key cancellation for rect drag
     useEffect(() => {
       if (!rectDragState.active) return;
       ...
     }, [rectDragState.active, setRectDragState]);
     ```

10. **Add rect drag to permanent Escape listener** (lines ~1320-1356):
    - Inside the permanent Escape handler, AFTER the selection drag block, add:
      ```typescript
      // Cancel rect drag
      if (rectDragRef.current.active) {
        e.preventDefault();
        rectDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
        requestUiRedraw();
      }
      ```

11. **Update animation-tick useEffect** (line ~654-660):
    - Replace `rectDragState?.active` with `rectDragRef.current?.active`
    - Remove `rectDragState` from deps array

**In globalSlice.ts:**

12. **Remove rectDragState from interface** (line ~27):
    - Delete: `rectDragState: RectDragState;`

13. **Remove setRectDragState from interface** (line ~62):
    - Delete: `setRectDragState: (state: Partial<RectDragState>) => void;`

14. **Remove rectDragState from initial state** (line ~93):
    - Delete: `rectDragState: { active: false, startX: 0, startY: 0, endX: 0, endY: 0 },`

15. **Remove setRectDragState action** (line ~185-187):
    - Delete the entire action definition

16. **Remove RectDragState from import** (line ~6) if no longer used:
    - Check if `RectDragState` is used anywhere else in globalSlice.ts. If not, remove from import.
  </action>
  <verify>
    Run `npm run typecheck` — 0 TypeScript errors.
    Grep for `rectDragState` in all .ts/.tsx files — should only appear in types.ts (type definition) and nowhere in components or slices.
    Grep for `setRectDragState` — zero results (fully removed).
    Grep for `rectDragRef` in MapCanvas.tsx — confirm declaration and usage in mouseDown/mouseMove/mouseUp/mouseLeave/drawUiLayer/Escape handler.
  </verify>
  <done>
    Rect drag state fully migrated from Zustand to ref. Zero React re-renders during rect drag mousemove. Escape cancellation via permanent listener (no listener churn). rectDragState removed from GlobalSlice.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add edge case safety — tool switch, unmount cleanup, wall pencil doc</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
**Tool switch safety (TOOL-03):**

1. Add a `useEffect` that fires when `currentTool` changes, cancelling any active ref-based drags:
   ```typescript
   // Cancel active drags when tool switches (TOOL-03)
   useEffect(() => {
     // Cancel rect drag
     if (rectDragRef.current.active) {
       rectDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       requestUiRedraw();
     }
     // Cancel line preview
     if (lineStateRef.current.active) {
       lineStateRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       requestUiRedraw();
     }
     // Cancel selection drag (in-progress, not committed)
     if (selectionDragRef.current.active) {
       selectionDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       requestUiRedraw();
     }
     // Commit pencil drag if active
     if (engineRef.current?.getIsDragActive()) {
       const tiles = engineRef.current.commitDrag();
       if (tiles && tiles.length > 0) {
         const state = useEditorStore.getState();
         state.setTiles(tiles);
         state.commitUndo('Edit tiles');
       }
     }
   }, [currentTool, requestUiRedraw]);
   ```
   Place this effect near the other Escape/cleanup effects (around line 1280-1290 area, after the now-removed rect drag Escape handler).

   **Important:** This should NOT run on initial render with a stale `currentTool`. The effect only fires on subsequent changes. Since refs start as `{ active: false }`, the initial run is a no-op — safe.

**Unmount cleanup (TOOL-04):**

2. The existing unmount cleanup at line ~1249-1253 handles engine detach (which includes cancelDrag). Add rect drag cleanup to the same or adjacent effect:
   ```typescript
   // Cleanup pending drag state on unmount (TOOL-04)
   useEffect(() => {
     return () => {
       // Rect drag: discard (partial rectangle is meaningless)
       rectDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       // Line preview: discard
       lineStateRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       // Selection drag: discard (not yet committed)
       selectionDragRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0 };
       // Cancel RAF to prevent orphaned callbacks
       if (uiRafIdRef.current !== null) {
         cancelAnimationFrame(uiRafIdRef.current);
         uiRafIdRef.current = null;
       }
     };
   }, []);
   ```
   Check if this RAF cleanup already exists. If it does (from Phase 54), don't duplicate — just add the ref resets to the existing cleanup effect. The pencil drag unmount is already handled by `engineRef.current.detach()` in the engine attach/detach effect.

**Wall pencil documentation (TOOL-02):**

3. Add inline comment above the wall pencil useState declarations (line ~69-70):
   ```typescript
   // Wall pencil uses useState + Zustand per-move because auto-connection (wallSystem.placeWall)
   // reads 8 neighbors from map.tiles — cannot be extracted to ref-based pattern without
   // duplicating entire map in ref. Documented exception per TOOL-02.
   ```

4. Add inline comment in handleMouseMove wall pencil section (line ~968-973):
   ```typescript
   } else if (isDrawingWallPencil && e.buttons === 1) {
     // Wall pencil: Zustand per-move is intentional — placeWall reads neighbors (TOOL-02)
   ```
  </action>
  <verify>
    Run `npm run typecheck` — 0 TypeScript errors.
    Grep for `TOOL-02` in MapCanvas.tsx — should find 2 inline comments (declaration + mousemove).
    Grep for `TOOL-03` in MapCanvas.tsx — should find 1 comment on tool switch effect.
    Grep for `TOOL-04` in MapCanvas.tsx — should find 1 comment on unmount cleanup effect.
    Visual check: No duplicate RAF cleanup effects.
  </verify>
  <done>
    Tool switch cancels all active ref-based drags. Unmount discards pending drag state and cancels RAF. Wall pencil has inline documentation explaining Zustand exception.
  </done>
</task>

</tasks>

<verification>
1. **TypeScript:** `npm run typecheck` passes with 0 errors
2. **No rectDragState in Zustand:** `grep -rn "rectDragState" src/core/editor/` returns only `types.ts` (type definition)
3. **No setRectDragState anywhere:** `grep -rn "setRectDragState" src/` returns 0 results
4. **rectDragRef declared and used:** `grep -n "rectDragRef" src/components/MapCanvas/MapCanvas.tsx` returns declaration + mouseDown/mouseMove/mouseUp/mouseLeave/drawUiLayer/Escape/toolSwitch/unmount
5. **TOOL-01 verified:** selectionDragRef still ref-based (unchanged from Phase 54)
6. **TOOL-02 documented:** `grep -n "TOOL-02" src/components/MapCanvas/MapCanvas.tsx` returns inline comments
7. **TOOL-03 implemented:** useEffect with `[currentTool]` dependency cancels drags
8. **TOOL-04 implemented:** useEffect cleanup resets all refs
9. **TOOL-05 verified:** `isDragActive` guard in CanvasEngine (unchanged from Phase 53)
10. **PERF-04:** No `setState` or `set()` calls in any handleMouseMove drag path except wall pencil (documented exception)
11. **No listener churn:** Old rect drag Escape useEffect removed, rect drag added to permanent listener
</verification>

<success_criteria>
- `npm run typecheck` passes
- Zero Zustand state updates during rect drag mousemove (verified by absence of `setRectDragState` calls)
- Permanent Escape listener handles pencil + line + selection + rect drag cancellation
- Tool switch cleans up all active drags
- Unmount cleans up all pending refs and cancels RAF
- Wall pencil documented as intentional Zustand exception
- GlobalSlice no longer contains rectDragState or setRectDragState
</success_criteria>

<output>
After completion, create `.planning/phases/55-all-tool-drag-consistency/55-01-SUMMARY.md`
</output>
