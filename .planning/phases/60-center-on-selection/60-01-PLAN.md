---
phase: 60-center-on-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.ts
  - src/App.tsx
  - src/components/ToolBar/ToolBar.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger Center on Selection from View menu"
    - "User can trigger Center on Selection with Ctrl+E keyboard shortcut"
    - "Viewport pans to center the selection on screen without changing zoom"
    - "Command is a no-op when no selection exists (no error, no viewport change)"
    - "Viewport clamps to map bounds (never scrolls out of bounds)"
  artifacts:
    - path: "electron/main.ts"
      provides: "View menu with Center on Selection item"
      contains: "center-selection"
    - path: "src/App.tsx"
      provides: "IPC handler for center-selection menu action"
      contains: "center-selection"
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "Ctrl+E keyboard shortcut for center on selection"
      contains: "case 'e'"
  key_links:
    - from: "electron/main.ts"
      to: "src/App.tsx"
      via: "IPC menu-action 'center-selection'"
      pattern: "send\\('menu-action', 'center-selection'\\)"
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "useEditorStore"
      via: "getState().selection + setViewport()"
      pattern: "setViewport"
---

<objective>
Add "Center on Selection" command accessible from View menu (with Ctrl+E accelerator) and keyboard shortcut.

Purpose: Allow users to quickly navigate to their current selection with a single command, completing the viewport navigation feature set for the v2.9 milestone (GRID-04 requirement).

Output: View menu in Electron with Center on Selection item, IPC handler in App.tsx, Ctrl+E shortcut in ToolBar.tsx.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@electron/main.ts
@src/App.tsx
@src/components/ToolBar/ToolBar.tsx
@src/core/editor/slices/types.ts
@src/core/map/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add View menu to Electron and IPC handler in App.tsx</name>
  <files>electron/main.ts, src/App.tsx</files>
  <action>
**electron/main.ts:**

Add a new "View" menu entry to the `menuTemplate` array (insert between "Edit" and "Window" menus, around line 91). The View menu has one submenu item:

```typescript
{
  label: 'View',
  submenu: [
    {
      label: 'Center on Selection',
      accelerator: 'CmdOrCtrl+E',
      click: () => {
        mainWindow?.webContents.send('menu-action', 'center-selection');
      }
    }
  ]
}
```

This follows the exact pattern used by File and Edit menus: `mainWindow?.webContents.send('menu-action', actionName)`.

**src/App.tsx:**

Add a `'center-selection'` case to the existing `menu-action` IPC handler switch statement (around line 285-291). The handler:

1. Reads `selection` and `viewport` from `state` (already available as `const state = useEditorStore.getState()`)
2. Guards: `if (!selection.active) break;` — no-op when no selection
3. Calculates selection center: `selCenterX = (selection.startX + selection.endX) / 2`, same for Y
4. Calculates visible tile dimensions using current zoom: `visibleTilesX = window.innerWidth / (TILE_SIZE * viewport.zoom)`, `visibleTilesY = (window.innerHeight - 100) / (TILE_SIZE * viewport.zoom)` — the `- 100` accounts for toolbar/statusbar, matching Minimap's pattern
5. Calculates new viewport position: `newX = selCenterX - visibleTilesX / 2`, `newY = selCenterY - visibleTilesY / 2`
6. Clamps to map bounds: `Math.max(0, Math.min(MAP_WIDTH - visibleTilesX, newX))`, same for Y using MAP_HEIGHT
7. Calls `state.setViewport({ x: clampedX, y: clampedY })` — no zoom change

Add imports for `TILE_SIZE`, `MAP_HEIGHT` from `@core/map` (MAP_WIDTH is already imported on line 10). Check if TILE_SIZE and MAP_HEIGHT are already imported; if not, add them to the existing import.

**Do NOT:**
- Add smooth animation/transition — interpret "smoothly pans" as "instant pan without glitches"
- Change zoom level — success criteria explicitly says "no zoom change"
- Create a separate keydown listener — ToolBar handles that (Task 2)
  </action>
  <verify>
Run `npm run typecheck` — no type errors. Visually inspect the menu template has View between Edit and Window. Verify the center-selection case exists in App.tsx switch statement.
  </verify>
  <done>
View menu appears in Electron menu bar between Edit and Window. Clicking "Center on Selection" sends IPC to App.tsx which calculates selection center, computes clamped viewport position, and calls setViewport. Command is no-op when selection.active is false.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Ctrl+E keyboard shortcut in ToolBar</name>
  <files>src/components/ToolBar/ToolBar.tsx</files>
  <action>
In the existing `handleKeyDown` function inside the `useEffect` at line 360, add a new case inside the `if (e.ctrlKey || e.metaKey)` switch block (lines 363-411). Add it after the existing `case 'insert':` block (line 409) and before the closing of the switch:

```typescript
case 'e':
  e.preventDefault();
  {
    const st = useEditorStore.getState();
    const { selection, viewport } = st;
    if (!selection.active) break;
    const selCenterX = (selection.startX + selection.endX) / 2;
    const selCenterY = (selection.startY + selection.endY) / 2;
    const visibleTilesX = window.innerWidth / (TILE_SIZE * viewport.zoom);
    const visibleTilesY = (window.innerHeight - 100) / (TILE_SIZE * viewport.zoom);
    const newX = selCenterX - visibleTilesX / 2;
    const newY = selCenterY - visibleTilesY / 2;
    st.setViewport({
      x: Math.max(0, Math.min(MAP_WIDTH - visibleTilesX, newX)),
      y: Math.max(0, Math.min(MAP_HEIGHT - visibleTilesY, newY))
    });
  }
  break;
```

Note: The block scope `{ ... }` around the case body is needed to declare `const` variables inside a switch case without lint errors.

Add imports for `TILE_SIZE`, `MAP_WIDTH`, `MAP_HEIGHT` from `@core/map` if not already imported. Check existing imports at top of file — `MAP_WIDTH` may already be imported. Add what's missing.

Also import `useEditorStore` from `@core/editor` if not already imported (it likely is, since the component uses `undo`, `redo`, etc. from the store — but the center-selection code uses `useEditorStore.getState()` directly).

**Do NOT:**
- Create a separate useEffect or keydown listener — add to the existing one
- Add the shortcut to the dependency array — it uses `useEditorStore.getState()` which is stable and doesn't need to be a dep
- Forget `e.preventDefault()` — without it, Ctrl+E may trigger browser default behavior
  </action>
  <verify>
Run `npm run typecheck` — no type errors. Verify the 'e' case exists in the switch block inside the Ctrl/Meta guard. Verify TILE_SIZE, MAP_WIDTH, MAP_HEIGHT are imported.
  </verify>
  <done>
Pressing Ctrl+E (or Cmd+E on Mac) centers the viewport on the current selection. Shortcut is a no-op when no selection exists. Shortcut uses same centering+clamping math as the menu handler.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. View menu appears in Electron menu bar between Edit and Window menus
3. View > Center on Selection has Ctrl+E accelerator shown
4. With a selection active: clicking menu item centers viewport on selection
5. With a selection active: pressing Ctrl+E centers viewport on selection
6. Without a selection: both commands are no-ops (no error, no viewport change)
7. Selection near map edge (e.g., tile 0,0 or 255,255): viewport clamps to bounds, no black/empty area shown
8. At different zoom levels (0.25x, 1x, 4x): centering works correctly with proper visible area calculation
</verification>

<success_criteria>
- View menu exists with Center on Selection item (accelerator Ctrl+E)
- Menu click and Ctrl+E both center viewport on selection midpoint
- No zoom change occurs
- Command silently does nothing when no selection active
- Viewport never scrolls past map bounds (clamped 0 to MAP_SIZE - visibleTiles)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/60-center-on-selection/60-01-SUMMARY.md`
</output>
