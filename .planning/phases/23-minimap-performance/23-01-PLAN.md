---
phase: 23-minimap-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Minimap/Minimap.tsx
autonomous: true

must_haves:
  truths:
    - "Minimap tile colors are averaged across all 256 pixels of each 16x16 tile, not center-pixel sampled"
    - "Walls, spawns, flags, warps, switches, conveyors show hardcoded distinct colors on minimap"
    - "Animated tiles display their frame 0 averaged color from the tileset (not a flat fallback)"
    - "Minimap draw creates zero temporary canvas elements (only the one-time cache init uses a temp canvas)"
    - "Rapid tile painting triggers a single debounced minimap redraw (~150ms delay)"
    - "Viewport panning/zooming updates the minimap viewport rectangle immediately (no debounce)"
    - "Minimap renders correctly at all zoom levels (0.25x-4x)"
  artifacts:
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "Pre-computed average-color lookup table, special tile overrides, debounced redraw"
      contains: "getImageData.*TILE_SIZE.*TILE_SIZE"
  key_links:
    - from: "src/components/Minimap/Minimap.tsx"
      to: "@core/map (wallSystem, getAnimationById, TileEncoding constants)"
      via: "import and function calls for special tile detection"
      pattern: "wallSystem\\.isWallTile|getAnimationById"
    - from: "src/components/Minimap/Minimap.tsx (cache init useEffect)"
      to: "src/components/Minimap/Minimap.tsx (draw function)"
      via: "tileColorCacheRef shared ref"
      pattern: "tileColorCacheRef\\.current"
    - from: "src/components/Minimap/Minimap.tsx (map change useEffect)"
      to: "src/components/Minimap/Minimap.tsx (draw function)"
      via: "setTimeout debounce with clearTimeout cleanup"
      pattern: "setTimeout.*draw.*DEBOUNCE"
---

<objective>
Optimize minimap rendering by replacing center-pixel sampling with average-color lookup table, adding hardcoded special tile colors, and implementing debounced redraws.

Purpose: Eliminate per-draw computation overhead and improve minimap visual quality with accurate tile color representation and distinct gameplay-significant tile colors.
Output: Fully optimized Minimap.tsx with pre-computed color cache, special tile overrides, and debounced map redraws.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-minimap-performance/23-CONTEXT.md
@.planning/phases/23-minimap-performance/23-RESEARCH.md
@src/components/Minimap/Minimap.tsx
@src/core/map/TileEncoding.ts
@src/core/map/WallSystem.ts
@src/core/map/AnimationDefinitions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Average-color cache with special tile overrides and animated frame 0 lookup</name>
  <files>src/components/Minimap/Minimap.tsx</files>
  <action>
Modify the existing tile color cache initialization useEffect in Minimap.tsx to:

1. **Add imports** at the top of the file:
   - `import { wallSystem, getAnimationById } from '@core/map';`
   - Import the special tile constants: `WARP_ANIM_IDS, FLAG_POLE_IDS, SWITCH_ANIM_ID, NEUTRAL_FLAG_ANIM_ID, POWERUP_TILES` from `@core/map` (they're re-exported from TileEncoding.ts via index.ts)
   - Import `isAnimatedTile, getAnimationId` from `@core/map`

2. **Change temp canvas size** from 1x1 to TILE_SIZE x TILE_SIZE (16x16) in the cache-building useEffect. This is needed to sample all 256 pixels per tile for averaging.

3. **Replace center-pixel sampling with average-pixel sampling**:
   - Current: draws a 1x1 area from tile center, reads 1 pixel
   - New: draw full 16x16 tile area, call `getImageData(0, 0, TILE_SIZE, TILE_SIZE)`, iterate all 256 pixels summing R/G/B, divide by 256 for average
   - Remember to `clearRect` before each `drawImage` to avoid bleed from previous tile

4. **Build a separate special tile color map** as a `Map<number, [number, number, number]>` that overrides averaged colors. Populate it AFTER the average cache is built, in the same useEffect. This map stores hardcoded colors for:

   **Static special tiles (keyed by tile ID):**
   - DEFAULT_TILE (280): `[26, 26, 46]` (dark blue-black, empty space)
   - Wall tiles: iterate `wallSystem` lookup — for all tile IDs where `wallSystem.isWallTile(tileId)` returns true, set `[90, 100, 140]` (steel blue-gray). Since wallSystem checks `(tile & 0x8000) === 0` internally, only iterate static tile range 0 to totalTiles.
   - POWERUP_TILES (36, 37, 38, 39, 76, 77, 78, 79): `[255, 220, 50]` (bright gold)

   Store this map in a separate ref: `specialColorMapRef = useRef<Map<number, [number, number, number]> | null>(null)`.

5. **Build animated tile color cache** as a `Uint8Array` (256 entries * 3 bytes = 768 bytes) for animation IDs 0-255. For each animation ID 0-255:
   - Call `getAnimationById(animId)` to get animation definition
   - If animation exists and has frames, get frame 0 tile ID: `anim.frames[0]`
   - Look up that tile ID's averaged color from the main cache (already computed above)
   - Store in animated cache at `animId * 3`
   - If animation has no frames or frame 0 tile ID is out of cache range, use fallback `[90, 90, 142]` (muted purple-gray)
   - Store in a ref: `animColorCacheRef = useRef<Uint8Array | null>(null)`

6. **Define hardcoded animated special tile color overrides** (keyed by animation ID) — these override the frame-0 lookup for gameplay-significant animated tiles:
   - WARP_ANIM_IDS (0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x9E): `[80, 220, 80]` (bright green — warps)
   - FLAG_POLE_IDS team 0 (0x1C, 0x19, 0x1A, 0x1B, 0x80): `[0, 200, 0]` (green — green team flags)
   - FLAG_POLE_IDS team 1 (0x20, 0x25, 0x22, 0x23, 0x81): `[220, 50, 50]` (red — red team flags)
   - FLAG_POLE_IDS team 2 (0x28, 0x29, 0x2E, 0x2B, 0x82): `[50, 100, 220]` (blue — blue team flags)
   - FLAG_POLE_IDS team 3 (0x3A, 0x3B, 0x3C, 0x41, 0x83): `[220, 220, 50]` (yellow — yellow team flags)
   - SWITCH_ANIM_ID (0x7B): `[220, 180, 100]` (gold — switches)
   - NEUTRAL_FLAG_ANIM_ID (0x8C): `[200, 200, 200]` (light gray — neutral flags)

   Write these overrides directly into the `animColorCacheRef` Uint8Array after the frame-0 averaging loop, overwriting those entries.

The end result: three data structures populated once on tileset load:
- `tileColorCacheRef`: Uint8Array, average color for every static tile ID
- `specialColorMapRef`: Map, hardcoded overrides for walls/empty/powerups (keyed by static tile ID)
- `animColorCacheRef`: Uint8Array, frame-0 averaged color for every anim ID 0-255 (with special overrides for warps/flags/switches)
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Visually inspect that imports resolve correctly and cache arrays are initialized with correct sizes.
  </verify>
  <done>
Color cache useEffect builds three lookup structures: average-color cache (Uint8Array, all static tiles), special static tile overrides (Map), and animated tile color cache (Uint8Array, 256 entries with frame 0 colors and gameplay overrides). Temp canvas is 16x16, created once, garbage collected after init.
  </done>
</task>

<task type="auto">
  <name>Task 2: Optimized draw loop with cache lookups and debounced redraw</name>
  <files>src/components/Minimap/Minimap.tsx</files>
  <action>
Modify the draw() function and redraw useEffect hooks in Minimap.tsx:

1. **Add DEBOUNCE_DELAY constant** at the top of the file (near MINIMAP_SIZE):
   ```
   const DEBOUNCE_DELAY = 150; // ms - debounce map tile redraws
   ```

2. **Rewrite the draw() function's color lookup logic** to use the three caches. Replace the entire inner color determination block (lines ~105-154 in current code) with a clean cache-based lookup:

   For each tile in the 256x256 loop (still sampling every 2nd tile since 256 tiles map to 128 pixels):
   ```
   const tileValue = map.tiles[y * MAP_WIDTH + x];
   let r = 26, g = 26, b = 46; // Default: empty space

   if ((tileValue & 0x8000) !== 0) {
     // Animated tile — look up from animated color cache
     const animId = tileValue & 0xFF;
     if (animColorCacheRef.current) {
       const offset = animId * 3;
       r = animColorCacheRef.current[offset];
       g = animColorCacheRef.current[offset + 1];
       b = animColorCacheRef.current[offset + 2];
     }
   } else {
     // Static tile — check special overrides first, then average cache
     const specialColor = specialColorMapRef.current?.get(tileValue);
     if (specialColor) {
       r = specialColor[0];
       g = specialColor[1];
       b = specialColor[2];
     } else if (tileColorCacheRef.current) {
       const totalTilesInCache = tileColorCacheRef.current.length / 3;
       if (tileValue < totalTilesInCache) {
         const offset = tileValue * 3;
         r = tileColorCacheRef.current[offset];
         g = tileColorCacheRef.current[offset + 1];
         b = tileColorCacheRef.current[offset + 2];
       }
     }
   }
   ```

   This completely removes:
   - The HSL fallback path (30+ lines of math)
   - The hardcoded `tileId < 250` wall heuristic
   - The `tileId >= 4000` special tile heuristic
   - All inline color literals in the draw loop

3. **Remove `tilesetImage` from draw() dependencies.** The draw function no longer accesses tilesetImage directly — it only reads from cache refs. Update the useCallback dependency array to: `[map, viewport, getViewportRect]`. (Remove `tilesetImage` from the array.)

4. **Split the redraw useEffect into two separate hooks:**

   **Hook A — Debounced map redraw:**
   ```
   useEffect(() => {
     const timerId = setTimeout(() => {
       draw();
     }, DEBOUNCE_DELAY);
     return () => clearTimeout(timerId);
   }, [map, draw]);
   ```
   This triggers when `map` object reference changes (tile edits create new references via Zustand immutable updates). The 150ms debounce batches rapid paint/fill operations.

   **Hook B — Immediate viewport redraw:**
   ```
   useEffect(() => {
     draw();
   }, [viewport, draw]);
   ```
   This triggers when viewport changes (pan/zoom). No debounce — viewport rectangle must track immediately for responsive feel.

   **Remove the old combined useEffect** that called `draw()` on `[draw]` dependency.

5. **Also trigger an immediate draw when the cache finishes building.** Add a useEffect that draws once when caches are ready:
   ```
   useEffect(() => {
     if (tileColorCacheRef.current && map) {
       draw();
     }
   }, [tilesetImage, draw, map]);
   ```
   This ensures the minimap renders once tileset loads (the debounce hook won't fire until map changes, so initial render needs this trigger).

6. **Verify viewport rectangle rendering is unchanged.** The viewport rectangle drawing at the bottom of draw() should remain exactly as-is — it uses ctx.strokeRect which is immediate canvas2D rendering, no DOM creation. No changes needed.

7. **Clean up:** Remove any unreferenced variables. The `tilesetImage` prop is still needed for the cache-building useEffect but should NOT appear in the draw() function body or its dependency array.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Run `npm run electron:dev` and:
1. Open a map file — minimap should display with correct tile colors
2. Paint several tiles rapidly — minimap should update once after painting stops (not on every stroke)
3. Pan the map — viewport rectangle should track immediately with no lag
4. Zoom in/out — minimap viewport rectangle adjusts correctly
5. Check browser DevTools console for no errors or warnings
  </verify>
  <done>
Draw loop uses pure cache lookups (zero canvas creation per draw). Map changes debounced at 150ms. Viewport changes immediate. HSL fallback removed. Wall detection uses proper wallSystem.isWallTile(). Animated tiles show frame-0 color with special overrides for gameplay tiles.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. Minimap displays correct tile colors for:
   - Empty space (dark blue-black)
   - Walls (steel blue-gray, consistent for all 15 wall types)
   - Warps (bright green)
   - Flags (team-colored: green/red/blue/yellow)
   - Switches (gold)
   - Powerups (bright gold)
   - Regular tiles (averaged tileset color)
   - Animated tiles (frame 0 averaged color)
3. No temporary canvas elements created during draw (only during one-time init)
4. Rapid painting batches to single redraw (150ms debounce)
5. Viewport panning updates minimap rectangle immediately
6. Minimap click-to-navigate still works
7. Minimap drag-to-navigate still works without crash
</verification>

<success_criteria>
- Tile color lookup table computed once from tileset image at load time using average pixel color
- Minimap draw creates zero temporary canvas elements
- Minimap renders correctly at all zoom levels
- Special tiles (walls, flags, warps, switches, powerups) show distinct hardcoded colors
- Map tile changes trigger debounced minimap redraw (~150ms)
- Viewport changes trigger immediate minimap redraw (no debounce)
</success_criteria>

<output>
After completion, create `.planning/phases/23-minimap-performance/23-01-SUMMARY.md`
</output>
