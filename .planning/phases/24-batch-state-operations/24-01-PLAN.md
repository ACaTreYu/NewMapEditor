---
phase: 24-batch-state-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/map/WallSystem.ts
  - src/components/MapCanvas/MapCanvas.tsx
  - src/core/editor/EditorState.ts
autonomous: true

must_haves:
  truths:
    - "Wall line drawing (10-tile line) triggers single state update instead of 10+ updates"
    - "Wall rectangle drawing triggers single state update instead of per-tile updates"
    - "Wall pencil continues to place walls during drag for immediate visual feedback (no change to existing behavior)"
    - "All batched operations maintain correct wall auto-connection behavior (walls connect to neighbors)"
  artifacts:
    - path: "src/core/map/WallSystem.ts"
      provides: "placeWallBatch method for batched wall placement"
      exports: ["placeWallBatch"]
      min_lines: 40
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Batched wall line operation (wall pencil unchanged)"
      pattern: "wallSystem\\.placeWallBatch\\(map, validTiles\\)"
    - path: "src/core/editor/EditorState.ts"
      provides: "placeGameObjectRect uses batching for WALL_RECT"
      pattern: "wallSystem\\.placeWallBatch"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "wallSystem.placeWallBatch"
      via: "wall line drawing mouseup handler"
      pattern: "wallSystem\\.placeWallBatch\\(map, validTiles\\)"
    - from: "src/core/editor/EditorState.ts"
      to: "wallSystem.placeWallBatch"
      via: "WALL_RECT case in placeGameObjectRect"
      pattern: "case ToolType\\.WALL_RECT"
---

<objective>
Eliminate performance bottleneck from wall operations triggering multiple state updates by batching tile mutations into single transactions.

Purpose: Wall line/rect operations currently trigger cascading state updates (10-tile line = 10+ updates). Each placeWall() call mutates center tile + 4 neighbors, then triggers set({ map: {...map} }). This causes 10+ re-renders for a single user action. Batching collects all affected tiles (placements + neighbor updates) and applies them in one state update.

Output:
- WallSystem.placeWallBatch() method that handles multi-position placement with neighbor updates in single transaction
- MapCanvas wall line handler uses batching
- placeGameObjectRect WALL_RECT case uses batching
- Wall pencil retains existing per-tile behavior for immediate visual feedback
- User-facing: No behavior change for wall pencil, significantly faster line/rect operations
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-batch-state-operations/24-RESEARCH.md

# Current wall system implementation
@src/core/map/WallSystem.ts
@src/components/MapCanvas/MapCanvas.tsx
@src/core/editor/EditorState.ts

# Prior optimization work
Phase 21 established selector patterns and isolated animationFrame subscriptions
Phase 22 implemented layered canvas rendering
Phase 23 optimized minimap with pre-computed color cache
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WallSystem.placeWallBatch for batched placement</name>
  <files>src/core/map/WallSystem.ts</files>
  <action>
Add placeWallBatch method to WallSystem class that accepts array of positions and applies all wall placements + neighbor updates in single transaction:

```typescript
// Add after placeWall method (around line 160)
placeWallBatch(map: MapData, positions: Array<{ x: number; y: number }>): void {
  const affectedTiles = new Map<string, number>();  // "x,y" -> tileId

  // Phase 1: Place all walls and collect affected tiles
  for (const { x, y } of positions) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) continue;

    const connections = this.getConnections(map, x, y);
    const tile = this.getWallTile(this.currentType, connections);
    affectedTiles.set(`${x},${y}`, tile);
  }

  // Phase 2: Update all neighbors (may overlap with phase 1 positions)
  for (const { x, y } of positions) {
    this.collectNeighborUpdate(map, x - 1, y, affectedTiles);
    this.collectNeighborUpdate(map, x + 1, y, affectedTiles);
    this.collectNeighborUpdate(map, x, y - 1, affectedTiles);
    this.collectNeighborUpdate(map, x, y + 1, affectedTiles);
  }

  // Phase 3: Apply all mutations at once
  for (const [key, tile] of affectedTiles) {
    const [x, y] = key.split(',').map(Number);
    map.tiles[y * MAP_WIDTH + x] = tile;
  }

  map.modified = true;
}

// Helper method for collecting neighbor updates without immediate mutation
private collectNeighborUpdate(
  map: MapData,
  x: number,
  y: number,
  affectedTiles: Map<string, number>
): void {
  if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;

  const index = y * MAP_WIDTH + x;
  const currentTile = map.tiles[index];

  // Only update if it's already a wall
  if (!this.isWallTile(currentTile)) return;

  // Find which wall type this neighbor is
  const wallType = this.findWallType(currentTile);
  if (wallType === -1) return;

  // Get current connections and determine new tile
  const connections = this.getConnections(map, x, y);
  const newTile = this.getWallTile(wallType, connections);
  affectedTiles.set(`${x},${y}`, newTile);
}
```

Implementation notes:
- Use Map<string, number> for deduplication (if a position appears in both placement and neighbor update, last write wins)
- getConnections() reads current map state, so it naturally picks up walls placed in same batch
- collectNeighborUpdate is similar to updateNeighbor but stores to Map instead of mutating map directly
- Single map.modified = true at end, no intermediate modifications
  </action>
  <verify>
TypeScript compiles without errors. Verify placeWallBatch signature matches: `placeWallBatch(map: MapData, positions: Array<{ x: number; y: number }>): void`
  </verify>
  <done>
WallSystem.ts exports placeWallBatch method that collects all affected tiles (placements + neighbors) and applies them in single transaction
  </done>
</task>

<task type="auto">
  <name>Task 2a: Refactor wall line and wall pencil in MapCanvas to use batching</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
**MapCanvas.tsx changes:**

1. Update WALL line drawing mouseup handler (line ~854):
Replace the for-loop with clean batched version:

```typescript
pushUndo('Draw line');

if (currentTool === ToolType.WALL) {
  const validTiles = lineTiles.filter(t =>
    t.x >= 0 && t.x < MAP_WIDTH && t.y >= 0 && t.y < MAP_HEIGHT
  );
  wallSystem.placeWallBatch(map, validTiles);
  set({ map: { ...map } });
} else if (currentTool === ToolType.LINE) {
  for (const tile of lineTiles) {
    if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
      setTile(tile.x, tile.y, selectedTile);
    }
  }
}
```

2. Wall pencil - Keep existing per-mousemove placement behavior:
NO CHANGES to wall pencil handlers. Wall pencil already places walls one-at-a-time during drag (calling placeWall per mousemove), which provides essential visual feedback. The batching optimization applies to neighbor reconnection updates (handled internally by placeWall), not the primary placement.

Why: Wall pencil is fundamentally different from line/rect. Line/rect draw preview overlays (user sees nothing until mouseup). Wall pencil draws actual walls during drag (user sees immediate feedback). Batching wall pencil would break this expected behavior.

Implementation notes:
- Wall line now batches all positions on mouseup (single state update)
- Wall pencil continues existing behavior (one placeWall per mousemove, acceptable for single-tile operations)
- Line tool (non-wall) keeps existing loop behavior
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Test wall line drawing in dev mode - draw a 10-tile horizontal line, verify all middle tiles have LEFT+RIGHT connections (not just single-directional). Test wall pencil - verify walls appear immediately during drag (not delayed until mouseup).
  </verify>
  <done>
Wall line drawing uses batched placeWallBatch on mouseup (single state update). Wall pencil retains per-tile placement during drag for visual feedback. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Refactor WALL_RECT in EditorState to use batching</name>
  <files>src/core/editor/EditorState.ts</files>
  <action>
Update placeGameObjectRect WALL_RECT case (line ~598):

```typescript
case ToolType.WALL_RECT: {
  // Collect all rectangle border positions
  const positions: Array<{ x: number; y: number }> = [];
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);

  // Top and bottom edges
  for (let px = minX; px <= maxX; px++) {
    positions.push({ x: px, y: minY });
    positions.push({ x: px, y: maxY });
  }
  // Left and right edges (exclude corners already added)
  for (let py = minY + 1; py < maxY; py++) {
    positions.push({ x: minX, y: py });
    positions.push({ x: maxX, y: py });
  }

  wallSystem.placeWallBatch(map, positions);
  success = true;
  break;
}
```

Implementation notes:
- Collects all border positions first (top/bottom/left/right edges)
- Excludes corner duplicates (already added in top/bottom pass)
- Single placeWallBatch call for entire rectangle border
- Single state update per rectangle operation
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Test wall rectangle in dev mode - draw 5x5 rectangle, verify corner tiles have 2-way connections (e.g., top-left corner connects RIGHT+DOWN).
  </verify>
  <done>
WALL_RECT case in placeGameObjectRect uses batched placeWallBatch call. Rectangle drawing triggers single state update regardless of size.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npm run typecheck`
2. Wall line drawing connects walls correctly:
   - Draw 10-tile horizontal wall line (left-to-right drag)
   - Verify middle tiles have LEFT+RIGHT connections (use tile inspector or check tile IDs match 2-way connection state)
   - Verify end tiles have single-direction connections (left end = RIGHT only, right end = LEFT only)
3. Wall rectangle draws correct border pattern with connected corners:
   - Draw 5x5 wall rectangle
   - Verify corner tiles have 2-way connections (top-left = RIGHT+DOWN, top-right = LEFT+DOWN, etc.)
4. Wall pencil drag shows immediate visual feedback (walls appear during drag, not delayed until mouseup)
5. Chrome DevTools Performance timeline shows single state update per wall line/rect operation (not N updates for N tiles)
6. No visual lag when drawing 20+ tile wall lines at 60fps
</verification>

<success_criteria>
- [ ] WallSystem.placeWallBatch method exists and handles batched placement + neighbor updates
- [ ] Wall line drawing (WALL tool mouseup) uses placeWallBatch
- [ ] Wall rectangle (WALL_RECT in placeGameObjectRect) uses placeWallBatch
- [ ] Wall pencil retains existing per-tile placement behavior (immediate visual feedback during drag)
- [ ] All batched operations maintain wall auto-connection behavior
- [ ] State update count equals 1 per wall line/rect operation (not N for N tiles)
- [ ] No user-facing behavior changes (walls work exactly as before, line/rect operations faster)
</success_criteria>

<output>
After completion, create `.planning/phases/24-batch-state-operations/24-01-SUMMARY.md` documenting:
- placeWallBatch algorithm (3-phase: collect placements, collect neighbors, apply all)
- Performance improvement (10+ state updates â†’ 1 per wall line/rect operation)
- Which operations were converted to batching (wall line, wall rect) vs. kept unchanged (wall pencil)
- Rationale for wall pencil decision (immediate visual feedback requirement)
- Any edge cases or gotchas discovered during implementation
</output>
