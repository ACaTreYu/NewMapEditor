---
phase: 24-batch-state-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/map/WallSystem.ts
  - src/components/MapCanvas/MapCanvas.tsx
  - src/core/editor/EditorState.ts
autonomous: true

must_haves:
  truths:
    - "Wall line drawing (10-tile line) triggers single state update instead of 10+ updates"
    - "Wall rectangle drawing triggers single state update instead of per-tile updates"
    - "Wall pencil drag batches all positions and applies on mouseup instead of per-mousemove updates"
    - "All batched operations maintain correct wall auto-connection behavior (walls connect to neighbors)"
  artifacts:
    - path: "src/core/map/WallSystem.ts"
      provides: "placeWallBatch method for batched wall placement"
      exports: ["placeWallBatch"]
      min_lines: 40
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Batched wall line, rect, and pencil operations"
      contains: "wallPencilAccumulator"
    - path: "src/core/editor/EditorState.ts"
      provides: "placeGameObjectRect uses batching for WALL_RECT"
      pattern: "wallSystem\\.placeWallBatch"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "wallSystem.placeWallBatch"
      via: "wall line drawing mouseup handler"
      pattern: "wallSystem\\.placeWallBatch\\(map, lineTiles\\)"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "wallPencilAccumulator state"
      via: "accumulates positions during drag, flushes on mouseup"
      pattern: "wallPencilAccumulator"
    - from: "src/core/editor/EditorState.ts"
      to: "wallSystem.placeWallBatch"
      via: "WALL_RECT case in placeGameObjectRect"
      pattern: "case ToolType\\.WALL_RECT"
---

<objective>
Eliminate performance bottleneck from wall operations triggering multiple state updates by batching tile mutations into single transactions.

Purpose: Wall line/rect/pencil operations currently trigger cascading state updates (10-tile line = 10+ updates). Each placeWall() call mutates center tile + 4 neighbors, then triggers set({ map: {...map} }). This causes 10+ re-renders for a single user action. Batching collects all affected tiles (placements + neighbor updates) and applies them in one state update.

Output:
- WallSystem.placeWallBatch() method that handles multi-position placement with neighbor updates in single transaction
- MapCanvas wall line/rect/pencil handlers use batching
- placeGameObjectRect WALL_RECT case uses batching
- User-facing: No behavior change, but significantly faster wall operations
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-batch-state-operations/24-RESEARCH.md

# Current wall system implementation
@src/core/map/WallSystem.ts
@src/components/MapCanvas/MapCanvas.tsx
@src/core/editor/EditorState.ts

# Prior optimization work
Phase 21 established selector patterns and isolated animationFrame subscriptions
Phase 22 implemented layered canvas rendering
Phase 23 optimized minimap with pre-computed color cache
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WallSystem.placeWallBatch for batched placement</name>
  <files>src/core/map/WallSystem.ts</files>
  <action>
Add placeWallBatch method to WallSystem class that accepts array of positions and applies all wall placements + neighbor updates in single transaction:

```typescript
// Add after placeWall method (around line 160)
placeWallBatch(map: MapData, positions: Array<{ x: number; y: number }>): void {
  const affectedTiles = new Map<string, number>();  // "x,y" -> tileId

  // Phase 1: Place all walls and collect affected tiles
  for (const { x, y } of positions) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) continue;

    const connections = this.getConnections(map, x, y);
    const tile = this.getWallTile(this.currentType, connections);
    affectedTiles.set(`${x},${y}`, tile);
  }

  // Phase 2: Update all neighbors (may overlap with phase 1 positions)
  for (const { x, y } of positions) {
    this.collectNeighborUpdate(map, x - 1, y, affectedTiles);
    this.collectNeighborUpdate(map, x + 1, y, affectedTiles);
    this.collectNeighborUpdate(map, x, y - 1, affectedTiles);
    this.collectNeighborUpdate(map, x, y + 1, affectedTiles);
  }

  // Phase 3: Apply all mutations at once
  for (const [key, tile] of affectedTiles) {
    const [x, y] = key.split(',').map(Number);
    map.tiles[y * MAP_WIDTH + x] = tile;
  }

  map.modified = true;
}

// Helper method for collecting neighbor updates without immediate mutation
private collectNeighborUpdate(
  map: MapData,
  x: number,
  y: number,
  affectedTiles: Map<string, number>
): void {
  if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;

  const index = y * MAP_WIDTH + x;
  const currentTile = map.tiles[index];

  // Only update if it's already a wall
  if (!this.isWallTile(currentTile)) return;

  // Find which wall type this neighbor is
  const wallType = this.findWallType(currentTile);
  if (wallType === -1) return;

  // Get current connections and determine new tile
  const connections = this.getConnections(map, x, y);
  const newTile = this.getWallTile(wallType, connections);
  affectedTiles.set(`${x},${y}`, newTile);
}
```

Implementation notes:
- Use Map<string, number> for deduplication (if a position appears in both placement and neighbor update, last write wins)
- getConnections() reads current map state, so it naturally picks up walls placed in same batch
- collectNeighborUpdate is similar to updateNeighbor but stores to Map instead of mutating map directly
- Single map.modified = true at end, no intermediate modifications
  </action>
  <verify>
TypeScript compiles without errors. Verify placeWallBatch signature matches: `placeWallBatch(map: MapData, positions: Array<{ x: number; y: number }>): void`
  </verify>
  <done>
WallSystem.ts exports placeWallBatch method that collects all affected tiles (placements + neighbors) and applies them in single transaction
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor wall line, wall rect, and wall pencil to use batching</name>
  <files>
src/components/MapCanvas/MapCanvas.tsx
src/core/editor/EditorState.ts
  </files>
  <action>
**MapCanvas.tsx changes:**

1. Add wallPencilAccumulator state (line ~52):
```typescript
const [wallPencilAccumulator, setWallPencilAccumulator] = useState<Array<{x: number, y: number}>>([]);
```

2. Update WALL_PENCIL mousedown handler (line ~762):
```typescript
} else if (currentTool === ToolType.WALL_PENCIL) {
  // Wall pencil - start accumulating positions
  pushUndo('Draw walls');
  setWallPencilAccumulator([{ x, y }]);
  setIsDrawingWallPencil(true);
  setLastWallPencilPos({ x, y });
```

3. Update WALL_PENCIL mousemove handler (line ~809):
```typescript
} else if (isDrawingWallPencil && e.buttons === 1) {
  // Wall pencil freehand drawing - accumulate positions
  if (x !== lastWallPencilPos.x || y !== lastWallPencilPos.y) {
    setWallPencilAccumulator(prev => [...prev, { x, y }]);
    setLastWallPencilPos({ x, y });
  }
```

4. Update wall pencil mouseup handler (line ~874):
```typescript
// End wall pencil drawing - flush accumulated positions
if (isDrawingWallPencil) {
  if (wallPencilAccumulator.length > 0) {
    wallSystem.placeWallBatch(map, wallPencilAccumulator);
    set({ map: { ...map } });
  }
  setIsDrawingWallPencil(false);
  setLastWallPencilPos({ x: -1, y: -1 });
  setWallPencilAccumulator([]);
}
```

5. Update WALL line drawing mouseup handler (line ~854):
```typescript
for (const tile of lineTiles) {
  if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
    if (currentTool === ToolType.WALL) {
      // Batch all wall placements
      const validTiles = lineTiles.filter(t =>
        t.x >= 0 && t.x < MAP_WIDTH && t.y >= 0 && t.y < MAP_HEIGHT
      );
      wallSystem.placeWallBatch(map, validTiles);
      set({ map: { ...map } });
      break;  // Exit loop after batch
    } else if (currentTool === ToolType.LINE) {
      setTile(tile.x, tile.y, selectedTile);
    }
  }
}
```

Actually, refactor to:
```typescript
pushUndo('Draw line');

if (currentTool === ToolType.WALL) {
  const validTiles = lineTiles.filter(t =>
    t.x >= 0 && t.x < MAP_WIDTH && t.y >= 0 && t.y < MAP_HEIGHT
  );
  wallSystem.placeWallBatch(map, validTiles);
  set({ map: { ...map } });
} else if (currentTool === ToolType.LINE) {
  for (const tile of lineTiles) {
    if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
      setTile(tile.x, tile.y, selectedTile);
    }
  }
}
```

6. Update mouseleave to clear accumulator (line ~897):
```typescript
if (isDrawingWallPencil) {
  if (wallPencilAccumulator.length > 0) {
    wallSystem.placeWallBatch(map, wallPencilAccumulator);
    set({ map: { ...map } });
  }
  setIsDrawingWallPencil(false);
  setLastWallPencilPos({ x: -1, y: -1 });
  setWallPencilAccumulator([]);
}
```

**EditorState.ts changes:**

Update placeGameObjectRect WALL_RECT case (line ~598):
```typescript
case ToolType.WALL_RECT: {
  // Collect all rectangle border positions
  const positions: Array<{ x: number; y: number }> = [];
  const minX = Math.min(x1, x2);
  const minY = Math.min(y1, y2);
  const maxX = Math.max(x1, x2);
  const maxY = Math.max(y1, y2);

  // Top and bottom edges
  for (let px = minX; px <= maxX; px++) {
    positions.push({ x: px, y: minY });
    positions.push({ x: px, y: maxY });
  }
  // Left and right edges (exclude corners already added)
  for (let py = minY + 1; py < maxY; py++) {
    positions.push({ x: minX, y: py });
    positions.push({ x: maxX, y: py });
  }

  wallSystem.placeWallBatch(map, positions);
  success = true;
  break;
}
```

Implementation notes:
- Wall pencil now accumulates positions during drag, applies all on mouseup
- Wall line converts lineTiles array directly to placeWallBatch call
- WALL_RECT collects all border positions then batches
- All three operations now trigger single state update per user action
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Test wall line, wall rect, and wall pencil in dev mode - verify walls connect correctly and operations feel responsive.
  </verify>
  <done>
Wall line drawing, wall rectangle, and wall pencil drag all use batched state updates. Each operation triggers single set({ map: {...map} }) call regardless of number of tiles affected.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npm run typecheck`
2. Wall line drawing connects walls correctly (neighbors auto-connect)
3. Wall rectangle draws correct border pattern with connected corners
4. Wall pencil drag applies all positions on mouseup with correct connections
5. Chrome DevTools Performance timeline shows single state update per wall operation (not N updates for N tiles)
6. No visual lag when drawing 20+ tile wall lines at 60fps
</verification>

<success_criteria>
- [ ] WallSystem.placeWallBatch method exists and handles batched placement + neighbor updates
- [ ] Wall line drawing (WALL tool mouseup) uses placeWallBatch
- [ ] Wall rectangle (WALL_RECT in placeGameObjectRect) uses placeWallBatch
- [ ] Wall pencil drag accumulates positions and flushes on mouseup
- [ ] All batched operations maintain wall auto-connection behavior
- [ ] State update count equals 1 per user action (not N for N tiles)
- [ ] No user-facing behavior changes (walls work exactly as before, just faster)
</success_criteria>

<output>
After completion, create `.planning/phases/24-batch-state-operations/24-01-SUMMARY.md` documenting:
- placeWallBatch algorithm (3-phase: collect placements, collect neighbors, apply all)
- Performance improvement (10+ state updates â†’ 1 per wall operation)
- Which operations were converted to batching
- Any edge cases or gotchas discovered during implementation
</output>
