---
phase: 26-portability-layer
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/core/services/MapService.ts
  - src/App.tsx
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Map load/save logic is extracted from App.tsx into MapService"
    - "App.tsx has zero direct window.electronAPI calls"
    - "FileServiceProvider wraps App in main.tsx with ElectronFileService"
  artifacts:
    - path: "src/core/services/MapService.ts"
      provides: "Map loading and saving business logic using FileService"
      exports: ["MapService"]
    - path: "src/App.tsx"
      provides: "Refactored App consuming FileService via useFileService hook"
      contains: "useFileService"
    - path: "src/main.tsx"
      provides: "Entry point with FileServiceProvider wrapping App"
      contains: "FileServiceProvider"
  key_links:
    - from: "src/core/services/MapService.ts"
      to: "src/core/services/FileService.ts"
      via: "constructor injection"
      pattern: "constructor.*FileService"
    - from: "src/App.tsx"
      to: "src/contexts/FileServiceContext.tsx"
      via: "useFileService hook"
      pattern: "useFileService"
    - from: "src/main.tsx"
      to: "src/contexts/FileServiceContext.tsx"
      via: "FileServiceProvider component"
      pattern: "FileServiceProvider"
    - from: "src/main.tsx"
      to: "src/adapters/electron/ElectronFileService.ts"
      via: "instantiation"
      pattern: "ElectronFileService"
---

<objective>
Extract map load/save logic from App.tsx into a MapService, refactor App.tsx to use FileService via Context, and wire the FileServiceProvider in main.tsx.

Purpose: Complete the portability layer by removing ALL direct `window.electronAPI` calls from components and core, making the app's file I/O go through the adapter interface.

Output: MapService in src/core/services/, refactored App.tsx, and FileServiceProvider-wrapped main.tsx.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-portability-layer/26-01-SUMMARY.md

@src/App.tsx (current implementation with window.electronAPI calls)
@src/main.tsx (current entry point)
@src/core/map/MapParser.ts (serialize/parse methods)
@src/core/map/types.ts (MapData, MapHeader types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MapService and refactor App.tsx</name>
  <files>
    src/core/services/MapService.ts
    src/App.tsx
  </files>
  <action>
**1. Create `src/core/services/MapService.ts`:**

This service extracts the map loading and saving business logic from App.tsx. It takes a FileService as a constructor parameter (dependency injection).

```typescript
import { MapData } from '@core/map/types';
import { mapParser } from '@core/map/MapParser';
import { FileService } from './FileService';
```

**`loadMap()` method** -- extracts logic from App.tsx `handleOpenMap` (lines 67-135):
1. Call `this.fileService.openMapDialog()` -- if canceled, return `{ success: false, error: 'canceled' }`
2. Call `this.fileService.readFile(filePath)` -- if failed, return error
3. Call `mapParser.parse(data, filePath)` -- if failed, return error
4. If v3 map: extract compressed data from buffer at `header.dataOffset + 2`, call `this.fileService.decompress(compressedData)`, copy decompressed tiles to `mapData.tiles = new Uint16Array(decompressedData)`
5. Return `{ success: true, map: mapData, filePath }`

Return type: `Promise<{ success: boolean; map?: MapData; filePath?: string; error?: string }>`

**Critical detail for v3 decompression:** The compressed data starts at `header.dataOffset + 2` bytes into the raw file buffer. Use `new Uint8Array(rawBuffer, compressedStart)` to get the compressed slice, then pass `compressedSlice.buffer.slice(compressedSlice.byteOffset, compressedSlice.byteOffset + compressedSlice.byteLength)` as ArrayBuffer to decompress. This avoids the shared-buffer issue where Uint8Array.buffer returns the full underlying buffer.

**`saveMap(map, filePath?)` method** -- extracts logic from App.tsx `handleSaveMap` (lines 138-194):
1. If no filePath, call `this.fileService.saveMapDialog()` -- if canceled, return error
2. Call `mapParser.serialize(map)` to get header buffer
3. Call `this.fileService.compress(map.tiles.buffer)` -- if failed, return error
4. Combine header bytes + compressed bytes into a single ArrayBuffer
5. Call `this.fileService.writeFile(filePath, fullBuffer)` -- if failed, return error
6. Return `{ success: true, filePath }`

Return type: `Promise<{ success: boolean; filePath?: string; error?: string }>`

**2. Refactor `src/App.tsx`:**

Replace ALL `window.electronAPI` usage with FileService via the `useFileService` hook.

**Changes to make:**

a) Remove the `isElectron` check:
```typescript
// DELETE: const isElectron = typeof window !== 'undefined' && window.electronAPI;
```

b) Add imports:
```typescript
import { useFileService } from '@/contexts/FileServiceContext';
import { MapService } from '@core/services/MapService';
```

c) Inside the component, get the file service and create MapService:
```typescript
const fileService = useFileService();
const mapServiceRef = useRef<MapService | null>(null);
if (!mapServiceRef.current) {
  mapServiceRef.current = new MapService(fileService);
}
const mapService = mapServiceRef.current;
```
Use a ref to avoid recreating MapService on every render.

d) Replace `handleOpenMap` with:
```typescript
const handleOpenMap = useCallback(async () => {
  if (map?.modified) {
    if (!window.confirm('Discard unsaved changes?')) return;
  }
  const result = await mapService.loadMap();
  if (!result.success) {
    if (result.error !== 'canceled') {
      alert(`Failed to open map: ${result.error}`);
    }
    return;
  }
  setMap(result.map!, result.filePath);
}, [map, setMap, mapService]);
```

e) Replace `handleSaveMap` with:
```typescript
const handleSaveMap = useCallback(async () => {
  if (!map) return;
  const result = await mapService.saveMap(map, map.filePath);
  if (!result.success) {
    if (result.error !== 'canceled') {
      alert(`Failed to save map: ${result.error}`);
    }
    return;
  }
  markSaved();
  alert('Map saved successfully!');
}, [map, markSaved, mapService]);
```

f) Remove the `if (!isElectron)` guard from `handleOpenMap` -- the FileService adapter handles platform differences.

**Result:** App.tsx has ZERO references to `window.electronAPI`. All file I/O goes through the FileService adapter.
  </action>
  <verify>
1. Run `npm run typecheck` -- must pass with zero errors
2. Run `grep -r "window.electronAPI" src/` -- must return ZERO matches in src/App.tsx and src/components/ (only src/adapters/ should reference it)
3. Run `grep -r "window.electronAPI" src/core/` -- must return ZERO matches
  </verify>
  <done>
MapService exists in src/core/services/ with loadMap() and saveMap() methods. App.tsx uses useFileService() hook and MapService instead of direct window.electronAPI calls. Zero window.electronAPI references in src/components/ or src/core/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire FileServiceProvider in main.tsx</name>
  <files>
    src/main.tsx
  </files>
  <action>
**Update `src/main.tsx` to wrap App with FileServiceProvider:**

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import { FileServiceProvider } from '@/contexts/FileServiceContext';
import { ElectronFileService } from '@/adapters/electron/ElectronFileService';

const fileService = new ElectronFileService();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <FileServiceProvider service={fileService}>
      <App />
    </FileServiceProvider>
  </React.StrictMode>
);
```

**Key details:**
- Instantiate ElectronFileService directly (this is an Electron app).
- The FileServiceProvider makes the service available to all descendants via useFileService() hook.
- The interface still allows swapping to a different implementation if needed in the future.
  </action>
  <verify>
1. Run `npm run typecheck` -- must pass
2. Run `npm run electron:dev` -- app must launch and file operations (New, Open, Save) must work identically to before the refactor
  </verify>
  <done>
main.tsx wraps App in FileServiceProvider with ElectronFileService. All file operations work unchanged from user's perspective.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `grep -r "window.electronAPI" src/components/ src/core/` returns ZERO matches
3. `window.electronAPI` only appears in:
   - `src/adapters/electron/ElectronFileService.ts` (the adapter)
   - `src/vite-env.d.ts` (type declaration)
   - `electron/preload.ts` (Electron main process)
4. `npm run electron:dev` -- app launches, New/Open/Save all work correctly
5. MapService.loadMap() correctly handles v1, v2, and v3 map formats
6. MapService.saveMap() correctly serializes header + compresses tiles
</verification>

<success_criteria>
- Zero window.electronAPI calls in src/components/ or src/core/
- App.tsx uses FileService via Context for all file I/O
- Map decompression logic extracted from App.tsx into MapService
- All existing functionality preserved (no user-facing changes)
</success_criteria>

<output>
After completion, create `.planning/phases/26-portability-layer/26-02-SUMMARY.md`
</output>
