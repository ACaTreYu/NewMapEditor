---
phase: 26-portability-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/services/FileService.ts
  - src/adapters/electron/ElectronFileService.ts
  - src/contexts/FileServiceContext.tsx
autonomous: true

must_haves:
  truths:
    - "FileService interface defines all file I/O operations needed by the editor"
    - "ElectronFileService wraps window.electronAPI calls behind the interface"
    - "React Context provides dependency injection for FileService"
  artifacts:
    - path: "src/core/services/FileService.ts"
      provides: "Platform-agnostic FileService interface and result types"
      exports: ["FileService", "FileDialogResult", "FileReadResult", "FileWriteResult", "CompressionResult"]
    - path: "src/adapters/electron/ElectronFileService.ts"
      provides: "Electron implementation wrapping window.electronAPI"
      exports: ["ElectronFileService"]
    - path: "src/contexts/FileServiceContext.tsx"
      provides: "React Context provider and useFileService hook"
      exports: ["FileServiceProvider", "useFileService"]
  key_links:
    - from: "src/adapters/electron/ElectronFileService.ts"
      to: "src/core/services/FileService.ts"
      via: "implements FileService"
      pattern: "implements FileService"
    - from: "src/contexts/FileServiceContext.tsx"
      to: "src/core/services/FileService.ts"
      via: "imports FileService type"
      pattern: "import.*FileService.*from"
---

<objective>
Create the FileService adapter interface, Electron implementation, and React Context for dependency injection.

Purpose: Establish the portability layer foundation -- a platform-agnostic interface that abstracts all Electron-specific file I/O behind an implementation that can be swapped at runtime.

Output: FileService interface in src/core/services/, Electron adapter implementation, and a React Context provider/hook for consuming FileService in components.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/vite-env.d.ts (current ElectronAPI type definitions)
@electron/preload.ts (current IPC bridge)
@.planning/phases/26-portability-layer/26-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileService interface and Electron adapter</name>
  <files>
    src/core/services/FileService.ts
    src/adapters/electron/ElectronFileService.ts
  </files>
  <action>
**1. Create `src/core/services/FileService.ts`:**

Define result types and the FileService interface. The interface must cover ALL operations currently used via `window.electronAPI`:
- `openMapDialog()` -- opens file picker for .map/.lvl files
- `saveMapDialog(defaultName?: string)` -- opens save dialog
- `readFile(filePath: string)` -- reads file to ArrayBuffer
- `writeFile(filePath: string, data: ArrayBuffer)` -- writes ArrayBuffer to file
- `compress(data: ArrayBuffer)` -- zlib compress
- `decompress(data: ArrayBuffer)` -- zlib decompress

Result types (all with `success: boolean`):
- `FileDialogResult`: `{ filePath: string | null; canceled: boolean }`
- `FileReadResult`: `{ success: boolean; data?: ArrayBuffer; error?: string }`
- `FileWriteResult`: `{ success: boolean; error?: string }`
- `CompressionResult`: `{ success: boolean; data?: ArrayBuffer; error?: string }`

All methods return Promises (async interface). The interface lives in `src/core/` so it has ZERO Electron or browser dependencies -- purely TypeScript types.

**2. Create `src/adapters/electron/ElectronFileService.ts`:**

Implements `FileService` by wrapping `window.electronAPI` calls. Key implementation details:
- `openMapDialog()`: calls `window.electronAPI.openFileDialog()`, returns `{ filePath, canceled: !filePath }`
- `saveMapDialog()`: calls `window.electronAPI.saveFileDialog()`, returns `{ filePath, canceled: !filePath }`
- `readFile()`: calls `window.electronAPI.readFile(filePath)`, decodes base64 to ArrayBuffer using `atob` + Uint8Array loop (same pattern as current App.tsx lines 87-91)
- `writeFile()`: converts ArrayBuffer to base64 using String.fromCharCode loop + `btoa`, calls `window.electronAPI.writeFile(filePath, base64)`
- `compress()`: converts ArrayBuffer to base64, calls `window.electronAPI.compress(base64)`, decodes result base64 back to ArrayBuffer
- `decompress()`: converts ArrayBuffer to base64, calls `window.electronAPI.decompress(base64)`, decodes result base64 back to ArrayBuffer

This class encapsulates ALL the base64 encode/decode boilerplate currently scattered in App.tsx. Extract a private `arrayBufferToBase64` and `base64ToArrayBuffer` helper methods to avoid repetition.

**Important:** Do NOT include `openDllDialog` in the interface. It is defined in preload.ts but never used in any component code. The custom.dat file is loaded via fetch() in App.tsx, which is already browser-compatible.
  </action>
  <verify>
Run `npm run typecheck` -- both files must compile without errors. ElectronFileService must satisfy the FileService interface (TypeScript will error on missing methods).
  </verify>
  <done>
FileService interface exists in src/core/services/ with all required methods. Electron implementation compiles and satisfies the interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileService React Context</name>
  <files>
    src/contexts/FileServiceContext.tsx
  </files>
  <action>
**1. Create `src/contexts/FileServiceContext.tsx`:**

```typescript
import { createContext, useContext, ReactNode } from 'react';
import type { FileService } from '../core/services/FileService';

const FileServiceContext = createContext<FileService | null>(null);

interface FileServiceProviderProps {
  service: FileService;
  children: ReactNode;
}

export const FileServiceProvider = ({ service, children }: FileServiceProviderProps) => {
  return (
    <FileServiceContext.Provider value={service}>
      {children}
    </FileServiceContext.Provider>
  );
};

export const useFileService = (): FileService => {
  const service = useContext(FileServiceContext);
  if (!service) {
    throw new Error('useFileService must be used within FileServiceProvider');
  }
  return service;
};
```

**2. Verify path aliases** -- existing `@/*` path alias covers `src/*`, so `@/contexts/FileServiceContext` and `@/adapters/electron/ElectronFileService` resolve correctly. No vite.config.ts or tsconfig.json changes needed.
  </action>
  <verify>
Run `npm run typecheck` -- the Context file must compile. Verify that `useFileService` hook correctly types its return value as `FileService`.
  </verify>
  <done>
FileServiceContext.tsx exists with FileServiceProvider component and useFileService hook. Both are properly typed.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `src/core/services/FileService.ts` exists and exports the FileService interface + result types
3. `src/adapters/electron/ElectronFileService.ts` implements FileService
4. `src/contexts/FileServiceContext.tsx` exports FileServiceProvider and useFileService
5. No `window.electronAPI` references in any of the new core/contexts files (only in ElectronFileService adapter)
</verification>

<success_criteria>
- FileService interface is platform-agnostic (no Electron or browser-specific types)
- Electron implementation compiles and satisfies the interface
- React Context provider ready for use in main.tsx (Plan 02 will wire it)
</success_criteria>

<output>
After completion, create `.planning/phases/26-portability-layer/26-01-SUMMARY.md`
</output>
