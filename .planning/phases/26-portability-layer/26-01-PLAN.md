---
phase: 26-portability-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/services/FileService.ts
  - src/adapters/electron/ElectronFileService.ts
  - src/adapters/browser/BrowserFileService.ts
  - src/contexts/FileServiceContext.tsx
autonomous: true

must_haves:
  truths:
    - "FileService interface defines all file I/O operations needed by the editor"
    - "ElectronFileService wraps window.electronAPI calls behind the interface"
    - "BrowserFileService provides browser-native file operations using pako and File API"
    - "React Context provides dependency injection for FileService"
  artifacts:
    - path: "src/core/services/FileService.ts"
      provides: "Platform-agnostic FileService interface and result types"
      exports: ["FileService", "FileDialogResult", "FileReadResult", "FileWriteResult", "CompressionResult"]
    - path: "src/adapters/electron/ElectronFileService.ts"
      provides: "Electron implementation wrapping window.electronAPI"
      exports: ["ElectronFileService"]
    - path: "src/adapters/browser/BrowserFileService.ts"
      provides: "Browser implementation using File API and pako"
      exports: ["BrowserFileService"]
    - path: "src/contexts/FileServiceContext.tsx"
      provides: "React Context provider and useFileService hook"
      exports: ["FileServiceProvider", "useFileService"]
  key_links:
    - from: "src/adapters/electron/ElectronFileService.ts"
      to: "src/core/services/FileService.ts"
      via: "implements FileService"
      pattern: "implements FileService"
    - from: "src/adapters/browser/BrowserFileService.ts"
      to: "src/core/services/FileService.ts"
      via: "implements FileService"
      pattern: "implements FileService"
    - from: "src/contexts/FileServiceContext.tsx"
      to: "src/core/services/FileService.ts"
      via: "imports FileService type"
      pattern: "import.*FileService.*from"
---

<objective>
Create the FileService adapter interface, Electron and Browser implementations, and React Context for dependency injection.

Purpose: Establish the portability layer foundation -- a platform-agnostic interface that abstracts all Electron-specific file I/O behind implementations that can be swapped at runtime.

Output: FileService interface in src/core/services/, two adapter implementations, and a React Context provider/hook for consuming FileService in components.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/vite-env.d.ts (current ElectronAPI type definitions)
@electron/preload.ts (current IPC bridge)
@.planning/phases/26-portability-layer/26-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileService interface and adapter implementations</name>
  <files>
    src/core/services/FileService.ts
    src/adapters/electron/ElectronFileService.ts
    src/adapters/browser/BrowserFileService.ts
  </files>
  <action>
**1. Install pako dependency:**
```bash
npm install pako
npm install --save-dev @types/pako
```

**2. Create `src/core/services/FileService.ts`:**

Define result types and the FileService interface. The interface must cover ALL operations currently used via `window.electronAPI`:
- `openMapDialog()` -- opens file picker for .map/.lvl files
- `saveMapDialog(defaultName?: string)` -- opens save dialog
- `readFile(filePath: string)` -- reads file to ArrayBuffer
- `writeFile(filePath: string, data: ArrayBuffer)` -- writes ArrayBuffer to file
- `compress(data: ArrayBuffer)` -- zlib compress
- `decompress(data: ArrayBuffer)` -- zlib decompress

Result types (all with `success: boolean`):
- `FileDialogResult`: `{ filePath: string | null; canceled: boolean }`
- `FileReadResult`: `{ success: boolean; data?: ArrayBuffer; error?: string }`
- `FileWriteResult`: `{ success: boolean; error?: string }`
- `CompressionResult`: `{ success: boolean; data?: ArrayBuffer; error?: string }`

All methods return Promises (async interface for future Web Worker support). The interface lives in `src/core/` so it has ZERO Electron or browser dependencies -- purely TypeScript types.

**3. Create `src/adapters/electron/ElectronFileService.ts`:**

Implements `FileService` by wrapping `window.electronAPI` calls. Key implementation details:
- `openMapDialog()`: calls `window.electronAPI.openFileDialog()`, returns `{ filePath, canceled: !filePath }`
- `saveMapDialog()`: calls `window.electronAPI.saveFileDialog()`, returns `{ filePath, canceled: !filePath }`
- `readFile()`: calls `window.electronAPI.readFile(filePath)`, decodes base64 to ArrayBuffer using `atob` + Uint8Array loop (same pattern as current App.tsx lines 87-91)
- `writeFile()`: converts ArrayBuffer to base64 using String.fromCharCode loop + `btoa`, calls `window.electronAPI.writeFile(filePath, base64)`
- `compress()`: converts ArrayBuffer to base64, calls `window.electronAPI.compress(base64)`, decodes result base64 back to ArrayBuffer
- `decompress()`: converts ArrayBuffer to base64, calls `window.electronAPI.decompress(base64)`, decodes result base64 back to ArrayBuffer

This class encapsulates ALL the base64 encode/decode boilerplate currently scattered in App.tsx. Extract a private `arrayBufferToBase64` and `base64ToArrayBuffer` helper methods to avoid repetition.

**4. Create `src/adapters/browser/BrowserFileService.ts`:**

Implements `FileService` using browser-native APIs and pako for compression:
- `openMapDialog()`: creates `<input type="file" accept=".map,.lvl">`, clicks it, resolves with file info. Store the File object in a private `lastSelectedFile` field for subsequent `readFile()`.
- `saveMapDialog(defaultName?)`: returns a synthetic file path using the defaultName or a timestamp-based name (browser doesn't have native save dialogs -- the actual download happens in `writeFile`).
- `readFile()`: uses `this.lastSelectedFile.arrayBuffer()` (modern File API, no FileReader wrapper needed). If `lastSelectedFile` is null, return error.
- `writeFile()`: creates Blob from ArrayBuffer, uses `URL.createObjectURL` + anchor click download pattern, then `URL.revokeObjectURL` to clean up.
- `compress()`: uses `pako.deflate(new Uint8Array(data))`, returns `{ success: true, data: compressed.buffer }`. Wrap in try/catch.
- `decompress()`: uses `pako.inflate(new Uint8Array(data))`, returns `{ success: true, data: decompressed.buffer }`. Wrap in try/catch.

Import pako as: `import * as pako from 'pako';`

**Important:** Do NOT include `openDllDialog` in the interface. It is defined in preload.ts but never used in any component code. The custom.dat file is loaded via fetch() in App.tsx, which is already browser-compatible.
  </action>
  <verify>
Run `npm run typecheck` -- all three files must compile without errors. Both ElectronFileService and BrowserFileService must satisfy the FileService interface (TypeScript will error on missing methods).
  </verify>
  <done>
FileService interface exists in src/core/services/ with all required methods. Both Electron and Browser implementations compile and satisfy the interface. pako is installed as a dependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileService React Context and update Vite config</name>
  <files>
    src/contexts/FileServiceContext.tsx
    vite.config.ts
    tsconfig.json
  </files>
  <action>
**1. Create `src/contexts/FileServiceContext.tsx`:**

```typescript
import React, { createContext, useContext, ReactNode } from 'react';
import { FileService } from '@core/services/FileService';

const FileServiceContext = createContext<FileService | null>(null);

interface FileServiceProviderProps {
  service: FileService;
  children: ReactNode;
}

export const FileServiceProvider: React.FC<FileServiceProviderProps> = ({ service, children }) => {
  return (
    <FileServiceContext.Provider value={service}>
      {children}
    </FileServiceContext.Provider>
  );
};

export const useFileService = (): FileService => {
  const service = useContext(FileServiceContext);
  if (!service) {
    throw new Error('useFileService must be used within FileServiceProvider');
  }
  return service;
};
```

**2. Update `vite.config.ts` resolve aliases** -- no changes needed, `@core` alias already maps to `src/core/` and `@/` maps to `src/`. The new `src/contexts/` and `src/adapters/` directories are reachable via `@/contexts/...` and `@/adapters/...`.

**3. Verify `tsconfig.json` paths** -- the existing `@/*` path alias covers `src/*`, so `@/contexts/FileServiceContext` and `@/adapters/electron/ElectronFileService` will resolve correctly. No changes needed.

**4. Ensure the `src/core/services/` directory is exported** -- this is for discoverability but NOT strictly required since consumers import directly from the file path. Do NOT modify `src/core/index.ts` or `src/core/map/index.ts` -- the FileService interface is used by import path, not barrel export.
  </action>
  <verify>
Run `npm run typecheck` -- the Context file must compile. Verify that `useFileService` hook correctly types its return value as `FileService`.
  </verify>
  <done>
FileServiceContext.tsx exists with FileServiceProvider component and useFileService hook. Both are properly typed. No Vite or tsconfig changes were needed (existing aliases cover new paths).
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `src/core/services/FileService.ts` exists and exports the FileService interface + result types
3. `src/adapters/electron/ElectronFileService.ts` implements FileService
4. `src/adapters/browser/BrowserFileService.ts` implements FileService using pako
5. `src/contexts/FileServiceContext.tsx` exports FileServiceProvider and useFileService
6. pako and @types/pako are in package.json
7. No `window.electronAPI` references in any of the new core/contexts files (only in ElectronFileService adapter)
</verification>

<success_criteria>
- FileService interface is platform-agnostic (no Electron or browser-specific types)
- Both implementations compile and satisfy the interface
- React Context provider ready for use in main.tsx (Plan 02 will wire it)
- pako installed for browser-side zlib
</success_criteria>

<output>
After completion, create `.planning/phases/26-portability-layer/26-01-SUMMARY.md`
</output>
