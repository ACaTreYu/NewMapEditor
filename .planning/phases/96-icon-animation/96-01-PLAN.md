---
phase: 96-icon-animation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/globalSlice.ts
  - src/hooks/useAnimationTimer.ts
  - src/components/ToolBar/ToolBar.tsx
  - src/components/ToolBar/ToolBar.css
autonomous: true

must_haves:
  truths:
    - "Hovering a game object tool with multi-frame animation (spawn, flag, conveyor, turret, warp) cycles through animation frames in the icon"
    - "When a game object tool is the active tool and has multi-frame animation, its icon animates continuously"
    - "Moving the mouse away from an idle (non-active) animated tool stops the animation and shows the first frame"
    - "The animation frame rate is driven by the same global animationFrame counter used for map canvas tiles"
    - "Static tools (pole, switch, bunker) are not affected and remain static"
    - "Animation works even when no animated tiles are visible on the map (e.g., empty or static map)"
  artifacts:
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "toolbarAnimationActive boolean state + setToolbarAnimationActive action"
      contains: "toolbarAnimationActive"
    - path: "src/hooks/useAnimationTimer.ts"
      provides: "Extended smart-pause that keeps timer alive when toolbarAnimationActive is true"
      contains: "toolbarAnimationActive"
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "Canvas-rendered animated icons with hover/active state tracking"
      contains: "animationFrame"
    - path: "src/components/ToolBar/ToolBar.css"
      provides: "Canvas icon sizing and pixelated rendering"
      contains: "tileset-tool-icon-canvas"
  key_links:
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "setToolbarAnimationActive(true/false) based on hoveredTool/currentTool"
      pattern: "setToolbarAnimationActive"
    - from: "src/hooks/useAnimationTimer.ts"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "reads toolbarAnimationActive to decide whether to keep advancing frames"
      pattern: "toolbarAnimationActive"
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "subscribes to animationFrame to trigger canvas redraws"
      pattern: "animationFrame"
---

<objective>
Add looping animation to game object tool icons in the toolbar when hovered or actively selected, using the existing global animation timer.

Purpose: Game object tools with multi-frame animations (spawn, flag, conveyor, turret, warp) should visually indicate their animated nature by cycling through frames when the user interacts with them, matching the animation speed used on the map canvas.

Output: Animated toolbar icons driven by the global `animationFrame` counter, with hover/active state tracking and animation timer keepalive.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/96-icon-animation/96-RESEARCH.md
@.planning/phases/95-tileset-rendered-icons/95-01-SUMMARY.md
@src/core/editor/slices/globalSlice.ts
@src/hooks/useAnimationTimer.ts
@src/components/ToolBar/ToolBar.tsx
@src/components/ToolBar/ToolBar.css
@src/core/map/AnimationDefinitions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add toolbarAnimationActive state and extend animation timer keepalive</name>
  <files>
    src/core/editor/slices/globalSlice.ts
    src/hooks/useAnimationTimer.ts
  </files>
  <action>
**globalSlice.ts changes:**

1. Add `toolbarAnimationActive: boolean` to the `GlobalSlice` interface (after `animationFrame: number` around line 31).
2. Add `setToolbarAnimationActive: (active: boolean) => void` to the actions section of the interface (after `advanceAnimationFrame` around line 91).
3. Add initial value `toolbarAnimationActive: false` in the `createGlobalSlice` implementation (after `animationFrame: 0` around line 137).
4. Add the setter action implementation:
   ```typescript
   setToolbarAnimationActive: (active) => set({ toolbarAnimationActive: active }),
   ```
   Place it after the `advanceAnimationFrame` action implementation (around line 209).

**useAnimationTimer.ts changes:**

1. Subscribe to `toolbarAnimationActive` from the store:
   ```typescript
   const toolbarAnimationActive = useEditorStore((state) => state.toolbarAnimationActive);
   ```
   Add this line after the existing `documents` and `advanceAnimationFrame` subscriptions (around line 21).

2. Add a ref to mirror it (same pattern as `hasVisibleAnimatedRef`):
   ```typescript
   const toolbarAnimActiveRef = useRef(toolbarAnimationActive);
   toolbarAnimActiveRef.current = toolbarAnimationActive;
   ```
   Place after the `hasVisibleAnimatedRef` lines (around line 70).

3. Extend the smart-pause condition in the RAF callback (line 81) from:
   ```typescript
   if (!isPausedRef.current && hasVisibleAnimatedRef.current) {
   ```
   to:
   ```typescript
   if (!isPausedRef.current && (hasVisibleAnimatedRef.current || toolbarAnimActiveRef.current)) {
   ```

This ensures the animation timer keeps advancing when toolbar icons need animation, even if no animated tiles are visible on the map canvas.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. The new `toolbarAnimationActive` state and `setToolbarAnimationActive` action should be properly typed and the useAnimationTimer hook should compile with the extended condition.
  </verify>
  <done>
- `toolbarAnimationActive: boolean` exists in GlobalSlice interface and implementation with initial value `false`
- `setToolbarAnimationActive` action exists and sets the boolean
- `useAnimationTimer` reads `toolbarAnimationActive` via ref and keeps RAF loop advancing when it is `true`
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement animated icon rendering with hover/active state in ToolBar</name>
  <files>
    src/components/ToolBar/ToolBar.tsx
    src/components/ToolBar/ToolBar.css
  </files>
  <action>
**ToolBar.tsx changes:**

1. **Define the set of animated icon names** at module scope (after the `toolIcons` map, around line 50):
   ```typescript
   // Icons that have multi-frame animations and should animate on hover/active
   const ANIMATED_ICON_ANIMS: Record<string, number[]> = {
     spawn:    [0xA6],  // Yellow OnMapSpawn, 10 frames
     flag:     [0x1C],  // Green Pad GreenFlag Sec, 4 frames
     conveyor: [0xB7],  // Conveyor right TL, 8 frames
     turret:   [0xBD],  // Turret, 4 frames
     // warp: 3x3 composite with 9 separate animation IDs
     warp:     [0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2],
   };
   const ANIMATED_ICON_NAMES = new Set(Object.keys(ANIMATED_ICON_ANIMS));
   ```

2. **Add hover state** inside the ToolBar component (near the top of the component, around line 130):
   ```typescript
   const [hoveredTool, setHoveredTool] = useState<string | null>(null);
   ```

3. **Subscribe to animationFrame and setToolbarAnimationActive** from the store. Add `animationFrame` into the existing `useShallow` selector:
   ```typescript
   const { currentTool, showGrid, map, gameObjectToolState, animationFrame } = useEditorStore(
     useShallow((state) => ({
       currentTool: state.currentTool,
       showGrid: state.showGrid,
       map: state.map,
       gameObjectToolState: state.gameObjectToolState,
       animationFrame: state.animationFrame,
     }))
   );
   ```
   And add a separate subscription for the setter:
   ```typescript
   const setToolbarAnimationActive = useEditorStore((state) => state.setToolbarAnimationActive);
   ```

4. **Keepalive effect** -- set `toolbarAnimationActive` based on whether any animated icon needs animation:
   ```typescript
   useEffect(() => {
     const isHoverAnimated = hoveredTool !== null && ANIMATED_ICON_NAMES.has(hoveredTool);
     const isActiveAnimated = ANIMATED_ICON_NAMES.has(currentTool);
     setToolbarAnimationActive(isHoverAnimated || isActiveAnimated);
     return () => setToolbarAnimationActive(false);
   }, [hoveredTool, currentTool, setToolbarAnimationActive]);
   ```
   Note: `currentTool` is a ToolType string like 'flag', 'spawn', etc. The icon name in `ANIMATED_ICON_ANIMS` matches the `tool.icon` field which is the same string. Verify that the ToolType enum values match the icon names used in the tool button definitions. If ToolType.FLAG = 'flag', ToolType.SPAWN = 'spawn', etc., then `ANIMATED_ICON_NAMES.has(currentTool)` works. If they differ, map currentTool to icon name using the tool button definitions.

5. **Add canvas refs for animated icons**:
   ```typescript
   const iconCanvasRefs = useRef<Record<string, HTMLCanvasElement | null>>({});
   ```

6. **Canvas drawing effect** -- redraw animated icons when `animationFrame` changes, but ONLY when the icon should be animating (hovered or active):
   ```typescript
   useEffect(() => {
     if (!tilesetImage) return;
     const TILES_PER_ROW = 40;

     for (const [iconName, animIds] of Object.entries(ANIMATED_ICON_ANIMS)) {
       const canvas = iconCanvasRefs.current[iconName];
       if (!canvas) continue;

       // Determine if this icon should show animation or static first frame
       const isHovered = hoveredTool === iconName;
       const isActive = currentTool === iconName;
       const shouldAnimate = isHovered || isActive;

       const ctx = canvas.getContext('2d');
       if (!ctx) continue;
       ctx.imageSmoothingEnabled = false;

       if (animIds.length === 1) {
         // Single-tile icon (spawn, flag, conveyor, turret)
         const anim = ANIMATION_DEFINITIONS[animIds[0]];
         if (!anim || anim.frameCount === 0) continue;
         const frameIdx = shouldAnimate ? (animationFrame % anim.frameCount) : 0;
         const tileId = anim.frames[frameIdx];
         const srcX = (tileId % TILES_PER_ROW) * TILE_SIZE;
         const srcY = Math.floor(tileId / TILES_PER_ROW) * TILE_SIZE;
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, 0, 0, 16, 16);
       } else {
         // 3x3 composite icon (warp) -- 9 animation IDs
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         for (let i = 0; i < 9; i++) {
           const anim = ANIMATION_DEFINITIONS[animIds[i]];
           if (!anim || anim.frameCount === 0) continue;
           const frameIdx = shouldAnimate ? (animationFrame % anim.frameCount) : 0;
           const tileId = anim.frames[frameIdx];
           const srcX = (tileId % TILES_PER_ROW) * TILE_SIZE;
           const srcY = Math.floor(tileId / TILES_PER_ROW) * TILE_SIZE;
           const dx = (i % 3) * TILE_SIZE;
           const dy = Math.floor(i / 3) * TILE_SIZE;
           ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, dx, dy, TILE_SIZE, TILE_SIZE);
         }
       }
     }
   }, [animationFrame, tilesetImage, hoveredTool, currentTool]);
   ```

7. **Update `renderToolButton`** to use `<canvas>` elements for animated icons instead of `<img>`. In the `renderToolButton` function, change the icon rendering logic. Currently (around line 789):
   ```typescript
   {tilesetIcon
     ? <img src={tilesetIcon} width={16} height={16} ... />
     : IconComponent ...}
   ```

   Replace with logic that uses canvas for animated icons and img for static icons:
   ```typescript
   {ANIMATED_ICON_NAMES.has(tool.icon) && tilesetImage
     ? <canvas
         ref={(el) => { iconCanvasRefs.current[tool.icon] = el; }}
         width={tool.icon === 'warp' ? TILE_SIZE * 3 : 16}
         height={tool.icon === 'warp' ? TILE_SIZE * 3 : 16}
         className="tileset-tool-icon-canvas"
         style={tool.icon === 'warp' ? { width: 16, height: 16 } : undefined}
       />
     : tilesetIcon
       ? <img src={tilesetIcon} width={16} height={16} alt={tool.label} className={`tileset-tool-icon${!tilesetIcon.startsWith('data:') ? ' png-tool-icon' : ''}`} draggable={false} />
       : IconComponent
         ? <IconComponent size={16} />
         : tool.label}
   ```

8. **Add hover handlers** to the button element in `renderToolButton`. On the `<button>` element, add:
   ```typescript
   onMouseEnter={() => { if (ANIMATED_ICON_NAMES.has(tool.icon)) setHoveredTool(tool.icon); }}
   onMouseLeave={() => { if (hoveredTool === tool.icon) setHoveredTool(null); }}
   ```

**ToolBar.css changes:**

Add a CSS rule for the canvas icon elements:
```css
/* Animated tileset-rendered tool icons (canvas elements) */
.tileset-tool-icon-canvas {
  display: block;
  image-rendering: pixelated;
}
```

**Important implementation notes:**
- Do NOT animate pole, switch, or bunker -- they are static (1-frame or PNG).
- The `tilesetToolIcons` useMemo should still generate static data URLs for pole, switch, and bunker. The animated icons (spawn, flag, conveyor, turret, warp) will no longer use the useMemo output since they render via canvas. You can either remove those entries from the useMemo or leave them as fallbacks -- leaving them is safer for the case when tilesetImage becomes null temporarily.
- The warp canvas is 48x48 (3x3 tiles at 16px each) with CSS `width: 16px; height: 16px` to scale it down, matching the existing 3x3 composite pattern from Phase 95.
- `animationFrame` in the useShallow selector will cause ToolBar to re-render every 150ms when animation is active. This is acceptable because only the canvas draws change (no DOM mutations for the animated icons). If performance is a concern, the canvas draw could be moved to a useRef callback outside React's render cycle, but this is unlikely to be needed for 5 icons.
  </action>
  <verify>
1. Run `npm run typecheck` to verify TypeScript compilation.
2. Run `npm run electron:dev` and verify:
   - Hover over the spawn tool button: icon should cycle through 10 frames of the Yellow OnMapSpawn animation.
   - Click the spawn tool to make it active, then move the mouse away: icon should continue animating while active.
   - Hover over flag, conveyor, turret: each should animate on hover.
   - Click a non-animated tool (e.g., pencil): the previously active animated tool should stop and show first frame.
   - Hover over pole, switch, bunker: they should NOT animate (static icons).
   - Hover over the warp tool: the 3x3 composite should cycle through its 4-frame animation.
   - Open an empty map (no animated tiles on canvas): hover over spawn -- animation should still work (keepalive ensures timer runs).
  </verify>
  <done>
- spawn, flag, conveyor, turret toolbar icons animate when hovered (cycle through their animation frames)
- warp toolbar icon (3x3 composite) animates when hovered (all 9 tiles cycle through frames)
- Active game object tools animate continuously while selected
- Moving mouse away from an idle tool shows the first frame (static appearance)
- pole, switch, bunker remain static
- Animation matches global animationFrame counter (150ms per frame, synced with map canvas)
- Timer keepalive works: animation runs even with no animated tiles on the map
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. All 5 animated icons (spawn, flag, conveyor, turret, warp) animate on hover
3. Active animated tools animate continuously when selected
4. Moving mouse away from idle animated tools returns to first frame
5. Static tools (pole, switch, bunker) are unaffected
6. Animation timer runs even with empty/static maps (keepalive)
7. Frame rate matches global animation timer (150ms per frame)
</verification>

<success_criteria>
- Game object tool icons with multi-frame animations cycle through frames when hovered or active
- Animation is driven by the same global animationFrame counter used for map canvas tiles
- Static icons (pole, switch, bunker) are not affected
- No TypeScript errors
- No performance degradation from canvas redraws
</success_criteria>

<output>
After completion, create `.planning/phases/96-icon-animation/96-01-SUMMARY.md`
</output>
