---
phase: 66-ui-component-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/AnimationPanel/AnimationPanel.tsx
  - src/components/AnimationPanel/AnimationPanel.css
  - src/components/TilesetPanel/TilesetPanel.tsx
  - src/components/TilesetPanel/TilesetPanel.css
  - src/components/Minimap/Minimap.tsx
autonomous: true

must_haves:
  truths:
    - "Animation panel has a visible scrollbar users can drag to navigate the animation list"
    - "Mouse wheel scrolling still works in the animation panel"
    - "Tile palette and notepad panel have a draggable resize handle between them"
    - "Tile palette remains at least 640px wide (tiles render correctly)"
    - "Minimap viewport indicator rectangle accurately reflects the visible canvas area"
  artifacts:
    - path: "src/components/AnimationPanel/AnimationPanel.tsx"
      provides: "Full-height canvas wrapped in scrollable container"
      contains: "animation-list-container"
    - path: "src/components/AnimationPanel/AnimationPanel.css"
      provides: "Scrollbar styling for animation list"
      contains: "webkit-scrollbar"
    - path: "src/components/TilesetPanel/TilesetPanel.tsx"
      provides: "Resizable panel split between tile palette and notepad"
      contains: "PanelGroup"
    - path: "src/components/TilesetPanel/TilesetPanel.css"
      provides: "Resize handle and updated layout styles"
      contains: "resize-handle-vertical"
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "Accurate viewport rectangle using actual canvas container dimensions"
      contains: "main-area"
  key_links:
    - from: "src/components/AnimationPanel/AnimationPanel.tsx"
      to: "AnimationPanel.css"
      via: "className animation-list-container"
      pattern: "animation-list-container"
    - from: "src/components/TilesetPanel/TilesetPanel.tsx"
      to: "react-resizable-panels"
      via: "PanelGroup/Panel/PanelResizeHandle imports"
      pattern: "import.*PanelGroup.*react-resizable-panels"
    - from: "src/components/Minimap/Minimap.tsx"
      to: "DOM .main-area element"
      via: "querySelector for accurate viewport sizing"
      pattern: "querySelector.*main-area"
---

<objective>
Polish three independent UI components: add visible scrollbar to animation panel, enable independent resize of tile palette and notepad, and fix minimap viewport indicator accuracy.

Purpose: Resolve UI-01, UI-02, UI-03 — the three known UX gaps in v3.1 milestone
Output: All three UI components working correctly and intuitively
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-ui-component-polish/66-RESEARCH.md
@src/components/AnimationPanel/AnimationPanel.tsx
@src/components/AnimationPanel/AnimationPanel.css
@src/components/TilesetPanel/TilesetPanel.tsx
@src/components/TilesetPanel/TilesetPanel.css
@src/components/Minimap/Minimap.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add visible scrollbar to animation panel (UI-01)</name>
  <files>src/components/AnimationPanel/AnimationPanel.tsx, src/components/AnimationPanel/AnimationPanel.css</files>
  <action>
Convert the animation panel from virtual-scroll (canvas renders only visible rows) to a full-height canvas wrapped in a scrollable container div. This gives the browser a native scrollbar to display.

**AnimationPanel.tsx changes:**

1. Remove the `scrollOffset` state entirely (`useState(0)` on line 26). Remove all references to `scrollOffset` including the `setScrollOffset` calls in the toggle button onClick (line 329) and the `handleWheel` handler (lines 280-287).

2. Change `canvasHeight` calculation (line 318) from `VISIBLE_ANIMATIONS * ROW_HEIGHT` to `getAnimations().length * ROW_HEIGHT` — the canvas is now full height showing all animations.

3. In the `draw()` callback (lines 130-207):
   - Remove `startIdx`/`endIdx` slicing (lines 140-141). Instead iterate from 0 to `anims.length`.
   - Change the y calculation (line 145) from `(i - startIdx) * ROW_HEIGHT` to `i * ROW_HEIGHT`.

4. In `handleMouseMove` (lines 215-227): Remove `scrollOffset +` from the idx calculation (line 220). It becomes just `Math.floor(y / ROW_HEIGHT)`.

5. In `handleClick` (lines 235-256): Same change — remove `scrollOffset +` from idx (line 241).

6. In `handleDoubleClick` (lines 259-277): Same change — remove `scrollOffset +` from idx (line 265).

7. Remove the `handleWheel` callback entirely (lines 280-287).

8. Wrap the canvas element (lines 338-348) in a container div:
   ```tsx
   <div className="animation-list-container">
     <canvas
       ref={canvasRef}
       className="animation-canvas"
       width={canvasWidth}
       height={canvasHeight}
       onClick={handleClick}
       onDoubleClick={handleDoubleClick}
       onMouseMove={handleMouseMove}
       onMouseLeave={handleMouseLeave}
     />
   </div>
   ```
   Remove the `onWheel={handleWheel}` from the canvas. The container div handles scrolling natively.

9. Move `canvasHeight` calculation into a `useMemo` that depends on `getAnimations` to avoid recalculating on every render. Compute it as `getAnimations().length * ROW_HEIGHT`.

10. For click/hover coordinate calculations, account for the container's scroll position. In `handleClick`, `handleDoubleClick`, and `handleMouseMove`, after getting `rect` from `getBoundingClientRect()`, the y coordinate is already correct because `getBoundingClientRect()` returns the canvas position relative to the viewport, and the canvas itself is positioned by scroll. So `e.clientY - rect.top` already gives the correct position within the canvas. No scroll offset adjustment needed.

**AnimationPanel.css changes:**

1. Add the scrollable container styles:
   ```css
   .animation-list-container {
     flex: 1;
     min-height: 0;
     overflow-y: auto;
     overflow-x: hidden;

     /* Firefox scrollbar styling */
     scrollbar-width: thin;
     scrollbar-color: var(--border-default) var(--surface);
   }
   ```

2. Add Webkit scrollbar styling:
   ```css
   .animation-list-container::-webkit-scrollbar {
     width: 8px;
   }
   .animation-list-container::-webkit-scrollbar-track {
     background: var(--surface);
   }
   .animation-list-container::-webkit-scrollbar-thumb {
     background: var(--border-default);
     border-radius: var(--radius-sm);
   }
   .animation-list-container::-webkit-scrollbar-thumb:hover {
     background: var(--text-secondary);
   }
   ```

3. Remove `flex-shrink: 0` from `.animation-canvas` (line 47) since the canvas should now be its natural full height inside the scrollable container.

Key constraint: The animation panel parent `.animation-panel` uses `display: flex; flex-direction: column`. The container needs `flex: 1; min-height: 0` to take remaining space between header and controls, and `overflow-y: auto` to enable scrolling when canvas exceeds container height.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Launch dev app with `npm run electron:dev`, open the Animations panel in the right sidebar, and visually confirm:
1. A thin scrollbar appears on the right side of the animation list
2. Dragging the scrollbar navigates through all animations
3. Clicking an animation still selects it correctly
4. The scrollbar thumb size reflects the proportion of visible vs total animations
  </verify>
  <done>Animation panel has a visible, styled scrollbar. Users can drag it to scroll through animations. Mouse clicks on animation rows still select the correct animation.</done>
</task>

<task type="auto">
  <name>Task 2: Enable independent tile palette and notepad resize (UI-02)</name>
  <files>src/components/TilesetPanel/TilesetPanel.tsx, src/components/TilesetPanel/TilesetPanel.css</files>
  <action>
Add a draggable resize handle between the tile palette (left, fixed 640px min) and the notepad panel (right, resizable) using react-resizable-panels which is already installed (v4.5.7).

**TilesetPanel.tsx changes:**

1. Add imports at top:
   ```tsx
   import { Panel, Group as PanelGroup, Separator as PanelResizeHandle } from 'react-resizable-panels';
   ```

2. Replace the `tileset-panel-body` div contents (lines 28-38) with a horizontal PanelGroup:
   ```tsx
   <div className="tileset-panel-body">
     <PanelGroup direction="horizontal">
       <Panel id="tile-palette" defaultSize={65} minSize={40}>
         <div className="tileset-palette-section">
           <TilePalette tilesetImage={tilesetImage} compact fullHeight onTileHover={onTileHover} />
         </div>
       </Panel>

       <PanelResizeHandle className="resize-handle-vertical" />

       <Panel id="ruler-notepad" defaultSize={35} minSize={15}>
         <div className="tileset-freed-section">
           <RulerNotepadPanel />
         </div>
       </Panel>
     </PanelGroup>
   </div>
   ```

Note: react-resizable-panels v2+ uses `direction` prop, not `orientation`. Check the existing usage in App.tsx (line 326) to confirm which API the installed version uses. If App.tsx uses `orientation`, use `orientation="horizontal"`. The App.tsx import on line 6 shows `Group as PanelGroup, Separator as PanelResizeHandle` — follow this exact import pattern.

The tile palette gets `defaultSize={65}` (percentage-based) with `minSize={40}` to ensure it never shrinks below roughly 640px at typical window widths. The notepad gets `defaultSize={35}` with `minSize={15}`.

**TilesetPanel.css changes:**

1. Update `.tileset-panel-body`:
   ```css
   .tileset-panel-body {
     flex: 1;
     overflow: hidden;
   }
   ```
   Remove `display: flex` and `flex-direction: row` — PanelGroup handles the layout.

2. Update `.tileset-palette-section`:
   ```css
   .tileset-palette-section {
     height: 100%;
     overflow-x: auto;
     overflow-y: hidden;
     border-right: 1px solid var(--border-default);
   }
   ```
   Remove `flex: 0 0 640px` — the Panel component controls sizing now.

3. Update `.tileset-freed-section`:
   ```css
   .tileset-freed-section {
     height: 100%;
     min-width: 0;
     background: var(--bg-secondary);
     overflow: hidden;
   }
   ```
   Remove `flex: 1` — Panel controls sizing.

4. Add resize handle styles:
   ```css
   .tileset-panel-body .resize-handle-vertical {
     width: 4px;
     background: var(--border-default);
     cursor: col-resize;
     flex-shrink: 0;
   }
   .tileset-panel-body .resize-handle-vertical:hover,
   .tileset-panel-body .resize-handle-vertical[data-resize-handle-active] {
     background: var(--accent-primary);
   }
   ```

Key constraint: The tile palette must remain at 640px or wider for correct tile rendering (40 tiles x 16px). The minSize percentage should prevent shrinking below this. If the bottom panel is narrow, the palette might hit minSize — this is acceptable as the palette has `overflow-x: auto` for horizontal scrolling.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Launch dev app, and visually confirm:
1. A thin resize handle appears between tile palette and notepad
2. Dragging the handle resizes the notepad panel width
3. Tile palette cannot be shrunk below its minimum (tiles still render correctly)
4. RulerNotepadPanel renders correctly in its resized area
  </verify>
  <done>A draggable resize handle separates tile palette from notepad. Users can independently control how much horizontal space each gets. Tile palette maintains minimum width for correct tile rendering.</done>
</task>

<task type="auto">
  <name>Task 3: Fix minimap viewport indicator accuracy (UI-03)</name>
  <files>src/components/Minimap/Minimap.tsx</files>
  <action>
Replace `window.innerWidth` / `window.innerHeight` with actual canvas container dimensions queried from the DOM. The `.main-area` element in App.tsx wraps the Workspace/MapCanvas and its dimensions accurately reflect the visible canvas area.

**Minimap.tsx changes:**

1. Create a helper function inside the component (or as a module-level utility) to get the actual canvas container size:
   ```tsx
   const getCanvasContainerSize = useCallback(() => {
     const el = document.querySelector('.main-area');
     if (el) {
       return { width: el.clientWidth, height: el.clientHeight };
     }
     // Fallback to window dimensions if element not found
     return { width: window.innerWidth, height: window.innerHeight - 100 };
   }, []);
   ```

2. Update `getViewportRect` (lines 247-257) to use the helper:
   ```tsx
   const getViewportRect = useCallback(() => {
     const container = getCanvasContainerSize();
     const visibleTilesX = container.width / (TILE_SIZE * viewport.zoom);
     const visibleTilesY = container.height / (TILE_SIZE * viewport.zoom);

     return {
       x: viewport.x * SCALE,
       y: viewport.y * SCALE,
       width: Math.min(visibleTilesX, MAP_WIDTH - viewport.x) * SCALE,
       height: Math.min(visibleTilesY, MAP_HEIGHT - viewport.y) * SCALE
     };
   }, [viewport, getCanvasContainerSize]);
   ```
   Note: The old code subtracted 100 from `window.innerHeight` as a toolbar/statusbar estimate. With `.main-area.clientHeight`, this subtraction is unnecessary — the element height already excludes toolbar and statusbar.

3. Update `handleClick` (lines 431-452), specifically lines 446-447 which also use `window.innerWidth/innerHeight`:
   ```tsx
   const container = getCanvasContainerSize();
   const visibleTilesX = container.width / (TILE_SIZE * viewport.zoom);
   const visibleTilesY = container.height / (TILE_SIZE * viewport.zoom);
   ```
   Same pattern — remove the `- 100` hack since container height is already accurate.

The viewport rectangle will now accurately match the actual visible map area regardless of sidebar state, panel sizes, or window dimensions. This fixes the "broken in dev app" issue because `.main-area` dimensions reflect the actual canvas area, not the entire Electron window.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Launch dev app with `npm run electron:dev`, open a map, and visually confirm:
1. Minimap shows a white viewport rectangle
2. The rectangle size accurately matches the visible map area
3. Resizing the window updates the rectangle size
4. Clicking on the minimap navigates to the correct location (viewport centers on click point)
5. Collapsing/expanding the right sidebar changes the rectangle width appropriately
  </verify>
  <done>Minimap viewport indicator rectangle accurately reflects the visible canvas area. Rectangle size updates when window or panel layout changes. Click-to-navigate positions the viewport correctly.</done>
</task>

</tasks>

<verification>
After all three tasks complete:

1. `npm run typecheck` — zero TypeScript errors
2. Animation panel: visible scrollbar, click-to-select works, scrollbar styled to match app theme
3. Tileset panel: drag-to-resize handle between palette and notepad, palette stays >= 640px
4. Minimap: viewport rectangle matches visible area, click-to-navigate accurate

Requirements traceability:
- UI-01: Task 1 (animation scrollbar)
- UI-02: Task 2 (independent resize)
- UI-03: Task 3 (minimap viewport)
</verification>

<success_criteria>
All three UI polish requirements (UI-01, UI-02, UI-03) are satisfied:
1. Animation list has a visible scrollbar that can be dragged (not just mouse wheel)
2. Tile palette and notepad have independent horizontal sizing via drag handle
3. Minimap viewport rectangle accurately shows the visible map area in dev app
4. Zero TypeScript errors, all existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/66-ui-component-polish/66-01-SUMMARY.md`
</output>
