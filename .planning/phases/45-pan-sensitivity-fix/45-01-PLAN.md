---
phase: 45-pan-sensitivity-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/components/MapCanvas/MapCanvas.tsx]
autonomous: true

must_haves:
  truths:
    - "User right-click drags 100px at zoom 0.25x and map moves 100px on screen"
    - "User right-click drags 100px at zoom 1x and map moves 100px on screen"
    - "User right-click drags 100px at zoom 4x and map moves 100px on screen"
    - "Tile under cursor at drag start stays under cursor throughout the entire drag"
    - "All tools (pencil, wall, select) click on correct tile after panning"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Cursor-anchored panning implementation"
      contains: "dragAnchor"
  key_links:
    - from: "handleMouseDown (right-click)"
      to: "dragAnchor state"
      via: "stores tile coordinates under cursor at drag start"
      pattern: "setDragAnchor"
    - from: "handleMouseMove (isDragging)"
      to: "setViewport"
      via: "calculates viewport to keep anchor tile under cursor"
      pattern: "dragAnchor\\.tileX.*tilePixels"
---

<objective>
Implement cursor-anchored panning so the tile under the cursor at drag start stays under the cursor throughout the drag, achieving true 1:1 screen movement at all zoom levels.

Purpose: Current delta-based panning is mathematically correct for 1:1 screen movement but causes cursor drift — the tile the user "grabs" doesn't follow their cursor. This makes panning feel slippery/sticky, especially at non-1x zoom levels. Cursor-anchored panning (used by Figma, Photoshop, Blender) eliminates drift by calculating the viewport position that keeps the anchor tile under the cursor on every mouse move.

Output: Updated MapCanvas.tsx with cursor-anchored panning that replaces the delta-based approach.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-pan-sensitivity-fix/45-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cursor-anchored panning</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Replace the delta-based panning with cursor-anchored panning. This follows the same pattern as the existing zoom-to-cursor code (lines ~1008-1030).

**Step 1: Replace `lastMousePos` state with `dragAnchor` state**

Replace the existing state:
```typescript
const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });
```

With a drag anchor that stores the tile coordinates under the cursor at drag start:
```typescript
const [dragAnchor, setDragAnchor] = useState<{ tileX: number; tileY: number } | null>(null);
```

**Step 2: Update mouseDown handler (right-click/middle-click pan start)**

In handleMouseDown, where `setIsDragging(true)` is called (line ~784), replace:
```typescript
setIsDragging(true);
setLastMousePos({ x: e.clientX, y: e.clientY });
```

With:
```typescript
setIsDragging(true);
const tilePixels = TILE_SIZE * viewport.zoom;
const mouseXLocal = e.clientX - rect.left;
const mouseYLocal = e.clientY - rect.top;
setDragAnchor({
  tileX: mouseXLocal / tilePixels + viewport.x,
  tileY: mouseYLocal / tilePixels + viewport.y
});
```

Note: `rect` is already available at this point in the function (line ~777: `const rect = gridLayerRef.current?.getBoundingClientRect()`).

**Step 3: Update mouseMove handler (pan during drag)**

Replace the existing drag handling block (lines ~856-863):
```typescript
if (isDragging) {
  const dx = (e.clientX - lastMousePos.x) / (TILE_SIZE * viewport.zoom);
  const dy = (e.clientY - lastMousePos.y) / (TILE_SIZE * viewport.zoom);
  setViewport({
    x: Math.max(0, Math.min(MAP_WIDTH - 10, viewport.x - dx)),
    y: Math.max(0, Math.min(MAP_HEIGHT - 10, viewport.y - dy))
  });
  setLastMousePos({ x: e.clientX, y: e.clientY });
}
```

With cursor-anchored calculation:
```typescript
if (isDragging && dragAnchor) {
  const tilePixels = TILE_SIZE * viewport.zoom;
  const mouseXLocal = e.clientX - rect.left;
  const mouseYLocal = e.clientY - rect.top;
  const newViewportX = dragAnchor.tileX - mouseXLocal / tilePixels;
  const newViewportY = dragAnchor.tileY - mouseYLocal / tilePixels;
  setViewport({
    x: Math.max(0, Math.min(MAP_WIDTH - 10, newViewportX)),
    y: Math.max(0, Math.min(MAP_HEIGHT - 10, newViewportY))
  });
}
```

Note: `rect` is already available at the top of handleMouseMove (line ~844).

**Step 4: Update mouseUp handler**

In handleMouseUp, add clearing the drag anchor alongside `setIsDragging(false)`:
```typescript
setIsDragging(false);
setDragAnchor(null);
```

**Step 5: Update mouseLeave handler**

In handleMouseLeave, add clearing the drag anchor alongside `setIsDragging(false)`:
```typescript
setIsDragging(false);
setDragAnchor(null);
```

**Why this works:** On each mouse move during a drag, we calculate what viewport.x/y would need to be to place `dragAnchor.tileX/Y` at the current cursor position. This is the same math as zoom-to-cursor: `viewportX = anchorTileX - mouseX / tilePixels`. Since the anchor tile never changes, it stays under the cursor regardless of zoom level, and the net screen movement equals the mouse movement (1:1).

**What NOT to do:**
- Do NOT remove the zoom factor from the calculation. The division by `tilePixels` (which includes zoom) is essential for correct coordinate conversion.
- Do NOT add `lastMousePos` back as an additional state variable. The anchor-based approach completely replaces delta-based tracking.
  </action>
  <verify>
Run `npm run typecheck` to ensure no TypeScript errors. Verify that `lastMousePos` and `setLastMousePos` are no longer referenced anywhere in the file (they should be fully replaced by `dragAnchor`/`setDragAnchor`). If `lastMousePos` is used elsewhere (not pan-related), keep it; otherwise remove it entirely.
  </verify>
  <done>
MapCanvas.tsx compiles without errors. Pan code uses cursor-anchored approach with dragAnchor state instead of delta-based lastMousePos. The tile under the cursor at drag start stays under the cursor during the entire drag at all zoom levels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify pan behavior and tool accuracy</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
After the implementation, verify:

1. **TypeScript compiles cleanly:** Run `npm run typecheck` — must pass with zero errors.

2. **No stale references:** Search the file for any remaining references to `lastMousePos` or `setLastMousePos`. If found in non-pan contexts (unlikely based on current codebase grep), they should be evaluated and either kept (if genuinely separate) or removed.

3. **Code review checklist:**
   - `dragAnchor` is set in mouseDown for button 1, 2, and Alt+click paths
   - `dragAnchor` is read in mouseMove when `isDragging && dragAnchor`
   - `dragAnchor` is cleared (set to null) in BOTH mouseUp AND mouseLeave
   - `rect` is correctly sourced in both mouseDown and mouseMove (already exists at top of each handler)
   - Viewport clamping bounds are unchanged: `Math.max(0, Math.min(MAP_WIDTH - 10, ...))`
   - No other code paths reference the removed `lastMousePos` state

4. **Coordinate math trace at 3 zoom levels:**
   - At 0.25x zoom: tilePixels = 4, mouse moves 100px right → viewport shifts by 100/4 = 25 tiles left → screen moves 25 * 4 = 100px right (correct)
   - At 1x zoom: tilePixels = 16, mouse moves 100px right → viewport shifts by 100/16 = 6.25 tiles left → screen moves 6.25 * 16 = 100px right (correct)
   - At 4x zoom: tilePixels = 64, mouse moves 100px right → viewport shifts by 100/64 = 1.5625 tiles left → screen moves 1.5625 * 64 = 100px right (correct)

5. **Edge case review:**
   - What if user zooms WHILE panning? Current code: dragAnchor stores tile coords, tilePixels recalculated each move using current viewport.zoom. If zoom changes mid-drag (via scroll wheel), the anchor tile adjusts correctly because tilePixels updates. This is correct behavior.
   - What if user drags to map boundary? Clamping is applied after calculation, so anchor tile may not stay perfectly under cursor at boundaries. This is acceptable (same as current behavior).
  </action>
  <verify>
`npm run typecheck` passes. No references to `lastMousePos` remain (unless used outside pan logic). The coordinate math trace confirms 1:1 movement at all zoom levels.
  </verify>
  <done>
TypeScript compiles cleanly. Code review confirms correct anchor-based panning. Math trace validates 1:1 screen movement at 0.25x, 1x, and 4x zoom. All success criteria from the phase roadmap are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. No `lastMousePos`/`setLastMousePos` references remain in MapCanvas.tsx (assuming pan was the only consumer)
3. Cursor-anchored panning: tile under cursor at drag start stays under cursor throughout drag
4. 1:1 screen movement: dragging 100px moves map 100px at all zoom levels (0.25x, 1x, 4x)
5. Tool accuracy: after panning, pencil/wall/select tools click on the correct tile
6. Zoom-to-cursor still works correctly (unchanged code)
7. Scroll bars still work correctly (unchanged code)
</verification>

<success_criteria>
- Right-click drag at 0.25x zoom: 100px mouse move = 100px screen movement
- Right-click drag at 1x zoom: 100px mouse move = 100px screen movement
- Right-click drag at 4x zoom: 100px mouse move = 100px screen movement
- Tile under cursor follows cursor during entire drag (no drift)
- All tools place on correct tile after panning
</success_criteria>

<output>
After completion, create `.planning/phases/45-pan-sensitivity-fix/45-01-SUMMARY.md`
</output>
