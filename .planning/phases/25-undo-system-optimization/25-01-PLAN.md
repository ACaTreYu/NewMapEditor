---
phase: 25-undo-system-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/EditorState.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Undo entries store only changed tiles as deltas, not full 128KB Uint16Array copies"
    - "Redo stack is bounded to maxUndoLevels (50), same as undo stack"
    - "All existing undo/redo behavior preserved (Ctrl+Z/Ctrl+Y work identically from user perspective)"
    - "Empty operations (no tiles actually changed) do not create undo entries"
    - "Drag operations (pencil, eraser, wall pencil) create exactly one undo entry per mousedown-mouseup cycle"
  artifacts:
    - path: "src/core/editor/EditorState.ts"
      provides: "Delta-based undo/redo system with TileDelta and UndoEntry types"
      contains: "interface TileDelta"
      exports: ["useEditorStore"]
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Updated pushUndo/commitUndo call pattern in mouse handlers"
      contains: "commitUndo"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "pushUndo (snapshot before) + commitUndo (compute deltas after)"
      pattern: "pushUndo.*commitUndo"
    - from: "EditorState.ts pushUndo"
      to: "EditorState.ts commitUndo"
      via: "pendingUndoSnapshot intermediate state"
      pattern: "pendingUndoSnapshot"
    - from: "EditorState.ts undo()"
      to: "map.tiles"
      via: "Apply delta.oldValue for each delta in entry"
      pattern: "delta\\.oldValue"
    - from: "EditorState.ts redo()"
      to: "map.tiles"
      via: "Apply delta.newValue for each delta in entry"
      pattern: "delta\\.newValue"
---

<objective>
Replace the full-snapshot undo system with delta-based undo to reduce memory from ~128KB per entry to ~12-1200 bytes per entry, and bound the redo stack to maxUndoLevels.

Purpose: PERF-10 (delta undo) and PERF-11 (bounded redo stack). Current system copies entire 256x256 tile array (128KB) for every pushUndo call. With 50-entry stack, this wastes up to 12.8MB. Delta-based approach stores only changed tile positions with old/new values.

Output: Refactored EditorState.ts with TileDelta/UndoEntry types, snapshot-then-compare pushUndo/commitUndo pattern, delta-based undo/redo application, and bounded redo stack. Updated MapCanvas.tsx with commitUndo calls after operations complete.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-undo-system-optimization/25-RESEARCH.md
@src/core/editor/EditorState.ts
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Delta-based undo/redo in EditorState.ts</name>
  <files>src/core/editor/EditorState.ts</files>
  <action>
Replace the full-snapshot undo system with delta-based storage. Specific changes:

1. **Replace types** (lines 26-30):
   - Remove `MapAction` interface (has `tiles: Uint16Array`)
   - Add `TileDelta` interface: `{ x: number; y: number; oldValue: number; newValue: number }`
   - Add `UndoEntry` interface: `{ deltas: TileDelta[]; description: string }`

2. **Update EditorState interface** (lines 100-103):
   - Change `undoStack: MapAction[]` to `undoStack: UndoEntry[]`
   - Change `redoStack: MapAction[]` to `redoStack: UndoEntry[]`
   - Add `pendingUndoSnapshot: Uint16Array | null` to state
   - Add `commitUndo: (description: string) => void` to actions (line ~168)

3. **Add pendingUndoSnapshot initial state** (after line 192):
   - `pendingUndoSnapshot: null,`

4. **Rewrite pushUndo** (lines 732-747):
   - Instead of creating full snapshot as undo entry, store snapshot as pending:
   ```typescript
   pushUndo: (description) => {
     const { map } = get();
     if (!map) return;
     // Store snapshot of current tiles for later delta comparison
     set({ pendingUndoSnapshot: new Uint16Array(map.tiles) });
   }
   ```
   - Note: pushUndo no longer clears redoStack or adds to undoStack. That happens in commitUndo.

5. **Add commitUndo action** (after pushUndo):
   ```typescript
   commitUndo: (description) => {
     const { map, pendingUndoSnapshot, undoStack, maxUndoLevels } = get();
     if (!map || !pendingUndoSnapshot) return;

     const deltas: TileDelta[] = [];
     for (let i = 0; i < map.tiles.length; i++) {
       if (map.tiles[i] !== pendingUndoSnapshot[i]) {
         deltas.push({
           x: i % MAP_WIDTH,
           y: Math.floor(i / MAP_WIDTH),
           oldValue: pendingUndoSnapshot[i],
           newValue: map.tiles[i]
         });
       }
     }

     if (deltas.length === 0) {
       // No changes — don't create empty undo entry
       set({ pendingUndoSnapshot: null });
       return;
     }

     const entry: UndoEntry = { deltas, description };
     const newStack = [...undoStack, entry];
     if (newStack.length > maxUndoLevels) {
       newStack.shift();
     }
     set({ undoStack: newStack, redoStack: [], pendingUndoSnapshot: null });
   }
   ```

6. **Rewrite undo** (lines 749-767):
   ```typescript
   undo: () => {
     const { map, undoStack, redoStack, maxUndoLevels } = get();
     if (!map || undoStack.length === 0) return;

     const entry = undoStack[undoStack.length - 1];

     // Create redo entry with swapped old/new values
     const redoDeltas: TileDelta[] = entry.deltas.map(d => ({
       x: d.x,
       y: d.y,
       oldValue: d.newValue,
       newValue: d.oldValue
     }));

     // Apply undo: restore old values
     for (const delta of entry.deltas) {
       map.tiles[delta.y * MAP_WIDTH + delta.x] = delta.oldValue;
     }

     map.modified = true;
     const newRedoStack = [...redoStack, { deltas: redoDeltas, description: entry.description }];
     if (newRedoStack.length > maxUndoLevels) {
       newRedoStack.shift();
     }
     set({
       map: { ...map },
       undoStack: undoStack.slice(0, -1),
       redoStack: newRedoStack
     });
   }
   ```

7. **Rewrite redo** (lines 769-787):
   ```typescript
   redo: () => {
     const { map, undoStack, redoStack, maxUndoLevels } = get();
     if (!map || redoStack.length === 0) return;

     const entry = redoStack[redoStack.length - 1];

     // Create undo entry with swapped old/new values
     const undoDeltas: TileDelta[] = entry.deltas.map(d => ({
       x: d.x,
       y: d.y,
       oldValue: d.newValue,
       newValue: d.oldValue
     }));

     // Apply redo: restore new values (which are stored as newValue in redo entry)
     for (const delta of entry.deltas) {
       map.tiles[delta.y * MAP_WIDTH + delta.x] = delta.newValue;
     }

     map.modified = true;
     const newUndoStack = [...undoStack, { deltas: undoDeltas, description: entry.description }];
     if (newUndoStack.length > maxUndoLevels) {
       newUndoStack.shift();
     }
     set({
       map: { ...map },
       undoStack: newUndoStack,
       redoStack: redoStack.slice(0, -1)
     });
   }
   ```

8. **Update internal callers** (cutSelection, deleteSelection, pasteAt):
   - These call `get().pushUndo(...)` then `get().setTiles(...)`. Add `get().commitUndo(...)` after setTiles:
   - **cutSelection** (line 332): After `get().setTiles(tiles)` on line 345, add `get().commitUndo('Cut selection');`
   - **deleteSelection** (line 358): After `get().setTiles(tiles)` on line 371, add `get().commitUndo('Delete selection');`
   - **pasteAt** (line 394): After `get().setTiles(tiles)` on line 408, add `get().commitUndo('Paste');`
   - For all three: keep the pushUndo call before the operation (it now just snapshots), add commitUndo after.

9. **Update setMap and newMap** to reset pendingUndoSnapshot:
   - In setMap (line 214): add `pendingUndoSnapshot: null` to the set() call
   - In newMap (line 223): add `pendingUndoSnapshot: null` to the set() call

IMPORTANT: The redo entry created during undo() stores deltas with swapped oldValue/newValue. This means when redo() applies it, delta.newValue contains what was originally the "before" value. The naming is relative to the entry's perspective: oldValue = state before this entry's operation, newValue = state after. When we undo, we apply oldValue. When we redo an undo entry, we apply newValue. The swap ensures consistent semantics.
  </action>
  <verify>
Run `npm run typecheck` from E:\NewMapEditor — must pass with zero errors. Verify:
- `TileDelta` and `UndoEntry` interfaces exist
- `MapAction` interface is removed
- `pendingUndoSnapshot` exists in state
- `commitUndo` exists as action
- `undo` and `redo` apply deltas (not full array copies)
- Redo stack bounded with `maxUndoLevels` check in both undo() and redo()
  </verify>
  <done>
EditorState.ts compiles with delta-based undo types, pushUndo stores pending snapshot, commitUndo computes and stores deltas, undo/redo apply sparse delta changes, redo stack bounded to maxUndoLevels, internal callers (cut/delete/paste) call commitUndo after operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MapCanvas.tsx pushUndo/commitUndo call pattern</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Update all external pushUndo call sites in MapCanvas.tsx to add matching commitUndo calls. The pattern is: pushUndo snapshots BEFORE modification, commitUndo computes deltas AFTER modification.

1. **Add commitUndo to action subscriptions** (line ~91-115):
   - Add `commitUndo` to the destructured actions from useEditorStore
   - Add `commitUndo: state.commitUndo` to the useShallow selector object

2. **Click-to-stamp game objects** (lines 751-757):
   Current:
   ```typescript
   pushUndo('Place game object');
   placeGameObject(x - 1, y - 1);
   ```
   Change to:
   ```typescript
   pushUndo('Place game object');
   placeGameObject(x - 1, y - 1);
   commitUndo('Place game object');
   ```
   Same pattern for the warp placement on line 756:
   ```typescript
   pushUndo('Place game object');
   placeGameObject(x, y);
   commitUndo('Place game object');
   ```

3. **Wall pencil mousedown** (line 765):
   Current:
   ```typescript
   pushUndo('Draw walls');
   placeWall(x, y);
   setIsDrawingWallPencil(true);
   ```
   Keep pushUndo here (snapshot before drag starts). Do NOT add commitUndo here — the drag continues in mousemove. CommitUndo will be called in mouseup (see step 6).

4. **Pencil/eraser/fill mousedown** (line 774):
   Current:
   ```typescript
   pushUndo('Edit tiles');
   handleToolAction(x, y);
   ```
   For FILL tool, the operation is instant (single click, no drag). For PENCIL/ERASER, the drag continues in mousemove.
   Keep pushUndo here. Do NOT add commitUndo here — mousemove continues painting. CommitUndo will be called in mouseup (see step 6).

5. **Line/wall-line mouseup** (line 853):
   Current:
   ```typescript
   pushUndo('Draw line');
   // ... line placement code ...
   setLineState({ active: false, ... });
   ```
   Add commitUndo AFTER the line placement code, BEFORE setLineState reset:
   ```typescript
   pushUndo('Draw line');
   if (currentTool === ToolType.WALL) {
     // ... wall line batch placement ...
   } else if (currentTool === ToolType.LINE) {
     // ... tile line placement ...
   }
   commitUndo('Draw line');
   setLineState({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 });
   ```

6. **Rect drag mouseup** (line 875):
   Current:
   ```typescript
   pushUndo('Place game object');
   placeGameObjectRect(...);
   setRectDragState({ active: false, ... });
   ```
   Add commitUndo after placeGameObjectRect:
   ```typescript
   pushUndo('Place game object');
   placeGameObjectRect(rectDragState.startX, rectDragState.startY, rectDragState.endX, rectDragState.endY);
   commitUndo('Place game object');
   setRectDragState({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 });
   ```

7. **Wall pencil mouseup and general drag mouseup** (lines 881-886):
   Add commitUndo calls for wall pencil and general drawing drags. In the handleMouseUp function, BEFORE the `setIsDragging(false)` line at the end:
   ```typescript
   // End wall pencil drawing
   if (isDrawingWallPencil) {
     commitUndo('Draw walls');
     setIsDrawingWallPencil(false);
     setLastWallPencilPos({ x: -1, y: -1 });
   }
   ```
   Also add commitUndo for pencil/eraser drag operations. After the wall pencil block and before setIsDragging(false), add:
   ```typescript
   // Commit undo for pencil/eraser/fill drag operations
   // (pushUndo was called on mousedown, drag painted tiles, now commit the deltas)
   else if (!lineState.active && !rectDragState.active && !selectionDrag.active) {
     commitUndo('Edit tiles');
   }
   ```
   Note: commitUndo is safe to call even if no pending snapshot exists (it early-returns if pendingUndoSnapshot is null). This covers the case where mouseup fires for tools that don't call pushUndo.

8. **Handle mouse leave** — check if there's a mouseLeave handler that should also commit. Look at the handleMouseLeave function. If it ends drag states, add commitUndo calls matching the mouseup pattern for wall pencil and general drawing.
  </action>
  <verify>
Run `npm run typecheck` from E:\NewMapEditor — must pass with zero errors. Then run `npm run electron:dev` and test:
1. Open a map file
2. Draw with pencil tool — Ctrl+Z undoes entire stroke, Ctrl+Y redoes it
3. Draw with wall pencil — Ctrl+Z undoes entire wall drawing session
4. Draw a wall line (click-drag with wall tool) — Ctrl+Z undoes the line
5. Place a game object — Ctrl+Z removes it
6. Use fill tool — Ctrl+Z reverts the fill
7. Cut a selection — Ctrl+Z restores cut tiles
8. Paste tiles — Ctrl+Z removes pasted tiles
9. Undo many times, then redo — all operations restore correctly
10. Verify no empty undo entries (clicking without changing tiles should not add to undo stack)
  </verify>
  <done>
All MapCanvas.tsx pushUndo call sites have matching commitUndo calls. Drag operations (pencil, eraser, wall pencil) commit on mouseup/mouseleave. Instant operations (game object click, fill) commit immediately after placement. Line/rect operations commit on mouseup after drawing completes. All undo/redo behavior preserved from user perspective.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run typecheck` passes with zero errors
2. `MapAction` type no longer exists in EditorState.ts (replaced by TileDelta + UndoEntry)
3. `pendingUndoSnapshot` field exists in state, initialized to null
4. Redo stack has maxUndoLevels bound check in both undo() and redo()
5. All 9 pushUndo call sites have matching commitUndo calls
6. Empty operations (click without tile change) produce no undo entry
</verification>

<success_criteria>
- PERF-10: Undo entries store TileDelta arrays (position + old/new value), not full 128KB Uint16Array copies
- PERF-11: Redo stack bounded to maxUndoLevels (50) with shift() when exceeded
- All existing undo/redo keyboard shortcuts (Ctrl+Z/Ctrl+Y) work identically
- Draw, fill, cut, paste, delete, wall, line, game object — all undoable/redoable
- No regression in any tool behavior
</success_criteria>

<output>
After completion, create `.planning/phases/25-undo-system-optimization/25-01-SUMMARY.md`
</output>
