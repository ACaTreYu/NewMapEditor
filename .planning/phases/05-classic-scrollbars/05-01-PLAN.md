---
phase: 05-classic-scrollbars
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/MapCanvas/MapCanvas.css
autonomous: true

must_haves:
  truths:
    - "User sees arrow buttons at each end of both scrollbars"
    - "User clicks arrow button once and viewport moves by one tile"
    - "User holds arrow button and viewport scrolls continuously at ~8 tiles/sec"
    - "User clicks scrollbar track (not thumb) and viewport jumps one page"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Arrow button elements and event handlers"
      contains: "handleArrowMouseDown"
    - path: "src/components/MapCanvas/MapCanvas.css"
      provides: "Arrow button styling with theme support"
      contains: "scroll-arrow-up"
  key_links:
    - from: "MapCanvas.tsx arrow buttons"
      to: "setViewport"
      via: "scrollByTiles helper function"
      pattern: "scrollByTiles.*setViewport"
    - from: "MapCanvas.css arrow styles"
      to: "CSS variables"
      via: "var(--scrollbar-track), var(--text-secondary)"
      pattern: "var\\(--scrollbar"
---

<objective>
Add classic Windows-style scrollbar controls with arrow buttons at each end, one-tile-per-click scrolling, continuous scroll on hold, and page-jump on track click.

Purpose: Provide familiar navigation controls that match classic Windows UI patterns, improving map traversal efficiency.
Output: Scrollbars with 4 arrow buttons (up/down/left/right), click and hold behavior, and track click page jumps.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-classic-scrollbars/05-CONTEXT.md
@.planning/phases/05-classic-scrollbars/05-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
@src/components/MapCanvas/MapCanvas.css
@src/App.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add arrow button elements and scroll handlers to MapCanvas.tsx</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Add arrow buttons and continuous scroll functionality to the scrollbar implementation:

1. **Add constants at top of file** (after existing constants):
```typescript
const INITIAL_SCROLL_DELAY = 250; // ms before continuous scroll starts
const SCROLL_REPEAT_RATE = 125;   // ms between scroll ticks (~8 tiles/sec)
```

2. **Add refs for timer cleanup** (after existing refs):
```typescript
const scrollIntervalRef = useRef<number | null>(null);
const scrollTimeoutRef = useRef<number | null>(null);
```

3. **Add scrollByTiles helper function** (before handleMouseDown):
```typescript
const scrollByTiles = useCallback((direction: 'up' | 'down' | 'left' | 'right', tiles: number) => {
  const clampX = (x: number) => Math.max(0, Math.min(MAP_WIDTH - 10, x));
  const clampY = (y: number) => Math.max(0, Math.min(MAP_HEIGHT - 10, y));

  switch (direction) {
    case 'up':
      setViewport({ y: clampY(viewport.y - tiles) });
      break;
    case 'down':
      setViewport({ y: clampY(viewport.y + tiles) });
      break;
    case 'left':
      setViewport({ x: clampX(viewport.x - tiles) });
      break;
    case 'right':
      setViewport({ x: clampX(viewport.x + tiles) });
      break;
  }
}, [viewport, setViewport]);
```

4. **Add arrow button event handlers** (after scrollByTiles):
```typescript
const handleArrowMouseDown = useCallback((direction: 'up' | 'down' | 'left' | 'right') => {
  // Immediate single-tile scroll
  scrollByTiles(direction, 1);

  // Set up continuous scrolling after initial delay
  const timeout = window.setTimeout(() => {
    const interval = window.setInterval(() => {
      scrollByTiles(direction, 1);
    }, SCROLL_REPEAT_RATE);
    scrollIntervalRef.current = interval;
  }, INITIAL_SCROLL_DELAY);

  scrollTimeoutRef.current = timeout;
}, [scrollByTiles]);

const stopArrowScroll = useCallback(() => {
  if (scrollTimeoutRef.current) {
    clearTimeout(scrollTimeoutRef.current);
    scrollTimeoutRef.current = null;
  }
  if (scrollIntervalRef.current) {
    clearInterval(scrollIntervalRef.current);
    scrollIntervalRef.current = null;
  }
}, []);
```

5. **Add track click handler** (after stopArrowScroll):
```typescript
const handleTrackClick = useCallback((axis: 'h' | 'v', event: React.MouseEvent) => {
  const target = event.target as HTMLElement;
  // Don't handle clicks on thumb or arrow buttons
  if (target.classList.contains('scroll-thumb-h') ||
      target.classList.contains('scroll-thumb-v') ||
      target.classList.contains('scroll-arrow-up') ||
      target.classList.contains('scroll-arrow-down') ||
      target.classList.contains('scroll-arrow-left') ||
      target.classList.contains('scroll-arrow-right')) {
    return;
  }

  const canvas = canvasRef.current;
  if (!canvas) return;

  const tilePixels = TILE_SIZE * viewport.zoom;

  if (axis === 'h') {
    const visibleTiles = Math.floor(canvas.width / tilePixels);
    const trackRect = event.currentTarget.getBoundingClientRect();
    const clickX = event.clientX - trackRect.left;
    const thumbLeft = (viewport.x / MAP_WIDTH) * (trackRect.width - 20); // Account for arrow buttons

    if (clickX < thumbLeft + 10) { // Click left of thumb (account for left arrow)
      setViewport({ x: Math.max(0, viewport.x - visibleTiles) });
    } else {
      setViewport({ x: Math.min(MAP_WIDTH - visibleTiles, viewport.x + visibleTiles) });
    }
  } else {
    const visibleTiles = Math.floor(canvas.height / tilePixels);
    const trackRect = event.currentTarget.getBoundingClientRect();
    const clickY = event.clientY - trackRect.top;
    const thumbTop = (viewport.y / MAP_HEIGHT) * (trackRect.height - 20); // Account for arrow buttons

    if (clickY < thumbTop + 10) { // Click above thumb (account for top arrow)
      setViewport({ y: Math.max(0, viewport.y - visibleTiles) });
    } else {
      setViewport({ y: Math.min(MAP_HEIGHT - visibleTiles, viewport.y + visibleTiles) });
    }
  }
}, [viewport, setViewport]);
```

6. **Add cleanup useEffect** (after the scrollDrag useEffect):
```typescript
// Cleanup scroll timers on unmount
useEffect(() => {
  return () => {
    if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    if (scrollIntervalRef.current) clearInterval(scrollIntervalRef.current);
  };
}, []);

// Global mouseup listener for arrow buttons (in case mouse leaves button while pressed)
useEffect(() => {
  const handleGlobalMouseUp = () => {
    stopArrowScroll();
  };
  document.addEventListener('mouseup', handleGlobalMouseUp);
  return () => document.removeEventListener('mouseup', handleGlobalMouseUp);
}, [stopArrowScroll]);
```

7. **Update JSX for horizontal scrollbar** - replace the existing scroll-track-h div:
```tsx
{/* Horizontal scroll bar */}
<div className="scroll-track-h" onClick={(e) => handleTrackClick('h', e)}>
  <button
    className="scroll-arrow-left"
    onMouseDown={() => handleArrowMouseDown('left')}
    onMouseUp={stopArrowScroll}
    onMouseLeave={stopArrowScroll}
    aria-label="Scroll left"
  />
  <div
    className="scroll-thumb-h"
    style={{
      left: `calc(10px + ${scrollMetrics.thumbLeft}% * (100% - 20px) / 100)`,
      width: `calc(${scrollMetrics.thumbWidth}% * (100% - 20px) / 100)`
    }}
    onMouseDown={(e) => handleScrollMouseDown('h', e)}
  />
  <button
    className="scroll-arrow-right"
    onMouseDown={() => handleArrowMouseDown('right')}
    onMouseUp={stopArrowScroll}
    onMouseLeave={stopArrowScroll}
    aria-label="Scroll right"
  />
</div>
```

8. **Update JSX for vertical scrollbar** - replace the existing scroll-track-v div:
```tsx
{/* Vertical scroll bar */}
<div className="scroll-track-v" onClick={(e) => handleTrackClick('v', e)}>
  <button
    className="scroll-arrow-up"
    onMouseDown={() => handleArrowMouseDown('up')}
    onMouseUp={stopArrowScroll}
    onMouseLeave={stopArrowScroll}
    aria-label="Scroll up"
  />
  <div
    className="scroll-thumb-v"
    style={{
      top: `calc(10px + ${scrollMetrics.thumbTop}% * (100% - 20px) / 100)`,
      height: `calc(${scrollMetrics.thumbHeight}% * (100% - 20px) / 100)`
    }}
    onMouseDown={(e) => handleScrollMouseDown('v', e)}
  />
  <button
    className="scroll-arrow-down"
    onMouseDown={() => handleArrowMouseDown('down')}
    onMouseUp={stopArrowScroll}
    onMouseLeave={stopArrowScroll}
    aria-label="Scroll down"
  />
</div>
```

Note: The thumb position calculation accounts for the 10px arrow buttons at each end (20px total reserved space).
  </action>
  <verify>
Run `npm run typecheck` - no TypeScript errors.
Run `npm run electron:dev` - app launches without errors.
  </verify>
  <done>
Arrow buttons visible at each end of both scrollbars. Clicking an arrow scrolls by one tile. Holding an arrow triggers continuous scrolling after 250ms delay.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CSS styling for arrow buttons and thin scrollbars</name>
  <files>src/components/MapCanvas/MapCanvas.css</files>
  <action>
Update the scrollbar CSS to support arrow buttons and reduce scrollbar width to 10px:

1. **Update .scroll-track-h** - change dimensions and position for arrow button space:
```css
.scroll-track-h {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 10px;  /* Account for vertical scrollbar width */
  height: 10px; /* Thinner scrollbar */
  background: var(--scrollbar-track);
  border-top: 1px solid var(--border-default);
}
```

2. **Update .scroll-track-v** - change dimensions and position for arrow button space:
```css
.scroll-track-v {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 10px; /* Account for horizontal scrollbar height */
  width: 10px;  /* Thinner scrollbar */
  background: var(--scrollbar-track);
  border-left: 1px solid var(--border-default);
}
```

3. **Update .scroll-thumb-h** - adjust for thinner scrollbar:
```css
.scroll-thumb-h {
  top: 1px;
  height: 8px;
  min-width: 20px;
}
```

4. **Update .scroll-thumb-v** - adjust for thinner scrollbar:
```css
.scroll-thumb-v {
  left: 1px;
  width: 8px;
  min-height: 20px;
}
```

5. **Update shared thumb styles** - smaller border radius:
```css
.scroll-thumb-h,
.scroll-thumb-v {
  position: absolute;
  background: var(--scrollbar-thumb);
  border-radius: 4px;
  cursor: grab;
  transition: background 0.15s;
}
```

6. **Add arrow button base styles** (after existing scroll styles):
```css
/* Arrow buttons - shared styles */
.scroll-arrow-up,
.scroll-arrow-down,
.scroll-arrow-left,
.scroll-arrow-right {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: var(--scrollbar-track);
  border: none;
  cursor: pointer;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.scroll-arrow-up:hover,
.scroll-arrow-down:hover,
.scroll-arrow-left:hover,
.scroll-arrow-right:hover {
  background-color: var(--bg-hover);
}

.scroll-arrow-up:active,
.scroll-arrow-down:active,
.scroll-arrow-left:active,
.scroll-arrow-right:active {
  background-color: var(--bg-active);
}
```

7. **Add arrow button positioning**:
```css
/* Vertical scrollbar arrows */
.scroll-arrow-up {
  top: 0;
  right: 0;
}

.scroll-arrow-down {
  bottom: 0;
  right: 0;
}

/* Horizontal scrollbar arrows */
.scroll-arrow-left {
  left: 0;
  bottom: 0;
}

.scroll-arrow-right {
  right: 0;
  bottom: 0;
}
```

8. **Add SVG triangles using CSS pseudo-elements** (for theme color support):
```css
/* Arrow glyphs using CSS borders for solid triangles */
.scroll-arrow-up::after,
.scroll-arrow-down::after,
.scroll-arrow-left::after,
.scroll-arrow-right::after {
  content: '';
  display: block;
  width: 0;
  height: 0;
  border-style: solid;
}

.scroll-arrow-up::after {
  border-width: 0 3px 4px 3px;
  border-color: transparent transparent var(--text-secondary) transparent;
}

.scroll-arrow-down::after {
  border-width: 4px 3px 0 3px;
  border-color: var(--text-secondary) transparent transparent transparent;
}

.scroll-arrow-left::after {
  border-width: 3px 4px 3px 0;
  border-color: transparent var(--text-secondary) transparent transparent;
}

.scroll-arrow-right::after {
  border-width: 3px 0 3px 4px;
  border-color: transparent transparent transparent var(--text-secondary);
}
```

9. **Add corner piece** (bottom-right corner where scrollbars meet):
```css
/* Corner piece where scrollbars meet */
.scroll-corner {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 10px;
  height: 10px;
  background: var(--scrollbar-track);
}
```

Note: Using CSS border triangles instead of SVG data URIs for simpler theme color support via CSS variables.
  </action>
  <verify>
Run `npm run electron:dev` - scrollbars display correctly with arrow buttons.
Arrow triangles visible and pointing correct directions.
Scrollbars are thinner (~10px) than before (was 14px).
Arrow buttons highlight on hover.
Arrow buttons darken on click/active.
Theme toggle (if available) changes arrow colors appropriately.
  </verify>
  <done>
Scrollbars are 10px wide with visible arrow buttons at each end. Triangles point in correct directions and use theme-aware colors. Corner piece fills the bottom-right intersection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add scroll corner element and update thumb calculations</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Add the corner piece element and fix the thumb drag calculation to account for arrow buttons:

1. **Update handleScrollMouseMove** to account for arrow buttons in track size:
```typescript
const handleScrollMouseMove = useCallback((e: MouseEvent) => {
  if (!scrollDrag) return;
  const container = containerRef.current;
  if (!container) return;

  // Track size minus arrow buttons (10px on each end = 20px total)
  const trackSize = scrollDrag.axis === 'h'
    ? container.clientWidth - 10 - 20  // minus vertical scrollbar and arrow buttons
    : container.clientHeight - 10 - 20; // minus horizontal scrollbar and arrow buttons
  const delta = (scrollDrag.axis === 'h' ? e.clientX : e.clientY) - scrollDrag.startPos;
  const viewportDelta = (delta / trackSize) * (scrollDrag.axis === 'h' ? MAP_WIDTH : MAP_HEIGHT);

  if (scrollDrag.axis === 'h') {
    setViewport({ x: Math.max(0, Math.min(MAP_WIDTH - 10, scrollDrag.startViewport + viewportDelta)) });
  } else {
    setViewport({ y: Math.max(0, Math.min(MAP_HEIGHT - 10, scrollDrag.startViewport + viewportDelta)) });
  }
}, [scrollDrag, setViewport]);
```

2. **Add corner element to JSX** (after the vertical scrollbar div, before the closing container div):
```tsx
{/* Corner piece where scrollbars meet */}
<div className="scroll-corner" />
```

3. **Update getScrollMetrics** to account for smaller visible thumb area:
The current calculation is fine since we use percentage-based positioning in the JSX that already accounts for the arrow button space.

No changes needed to getScrollMetrics - the calc() expressions in the JSX handle the offset.
  </action>
  <verify>
Run `npm run electron:dev` - drag the scrollbar thumb.
Thumb dragging moves viewport proportionally across the entire map.
Corner piece visible at bottom-right intersection of scrollbars.
No visual gaps or overlaps at scrollbar edges.
  </verify>
  <done>
Thumb dragging works correctly accounting for arrow button space. Corner piece fills the intersection. All scrollbar interactions (arrow click, arrow hold, track click, thumb drag) function correctly together.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the following requirements are met:

1. **NAV-01**: Arrow buttons visible at each end of both scrollbars
   - Horizontal: left arrow at left end, right arrow at right end
   - Vertical: up arrow at top, down arrow at bottom
   - All arrows show solid filled triangles

2. **NAV-02**: Track click jumps viewport by one page
   - Click left of horizontal thumb -> viewport moves left by visible width
   - Click right of horizontal thumb -> viewport moves right by visible width
   - Click above vertical thumb -> viewport moves up by visible height
   - Click below vertical thumb -> viewport moves down by visible height

3. **NAV-03**: Arrow buttons scroll by one tile per click
   - Click any arrow once -> viewport moves exactly 16px (1 tile) in that direction

4. **NAV-04**: Holding arrow button continuously scrolls
   - Hold any arrow for >250ms -> continuous scrolling begins at ~8 tiles/sec
   - Release arrow -> scrolling stops immediately

5. **Theme integration**:
   - Switch theme (if toggle available) -> arrow colors change appropriately
   - Arrow backgrounds use --scrollbar-track
   - Arrow triangles use --text-secondary

6. **Visual polish**:
   - Scrollbars are thin (~10px) for maximum canvas space
   - Corner piece fills bottom-right intersection
   - No visual gaps between scrollbar elements
</verification>

<success_criteria>
- All four NAV requirements (NAV-01 through NAV-04) pass manual verification
- TypeScript compiles with no errors (`npm run typecheck`)
- Application runs without console errors
- Scrollbar interactions feel responsive and match classic Windows behavior
- Theme colors apply correctly to all scrollbar elements
</success_criteria>

<output>
After completion, create `.planning/phases/05-classic-scrollbars/05-01-SUMMARY.md` using the summary template.
</output>
