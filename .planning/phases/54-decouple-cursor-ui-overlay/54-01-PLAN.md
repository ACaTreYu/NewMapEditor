---
phase: 54-decouple-cursor-ui-overlay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Zero React re-renders during any tool mousemove interaction (cursor tracking, line preview, selection drag, paste preview)"
    - "UI overlay redraws imperatively via RAF-debounced dirty flag, not React useEffect"
    - "Cursor highlight, line preview, selection rectangle, and paste preview render correctly at all zoom levels"
    - "Escape cancellation still works for line, selection drag, rect drag, and paste preview"
    - "Committed state (selection finalized on mouseup, line committed on mouseup) still writes to Zustand"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Ref-based transient UI state with RAF-debounced imperative redraw"
      contains: "requestUiRedraw"
  key_links:
    - from: "handleMouseMove"
      to: "cursorTileRef/lineStateRef/selectionDragRef/pastePreviewRef"
      via: "ref mutation + requestUiRedraw()"
      pattern: "requestUiRedraw"
    - from: "requestUiRedraw"
      to: "drawUiLayer"
      via: "RAF callback reads refs"
      pattern: "requestAnimationFrame.*drawUiLayer"
    - from: "handleMouseUp"
      to: "Zustand (setSelection, commitUndo)"
      via: "ref values committed to store on mouseup"
      pattern: "setSelection|commitUndo"
---
<objective>
Convert all transient UI state (cursor position, line preview, selection drag rect, paste preview position) from React useState/Zustand to useRef, and redraw the UI overlay imperatively via a RAF-debounced dirty flag.

Purpose: Eliminate the last source of React re-renders during mousemove interactions. Currently, setCursorTile (line 922), setLineState (line 944), setSelectionDrag (line 949), and setPastePreviewPosition (line 927) all fire on every mousemove, triggering React re-render + drawUiLayer useEffect. These are pure UI concerns that only affect canvas rendering.

Output: MapCanvas.tsx with zero React re-renders during any tool mousemove interaction. All transient UI state stored in refs, all committed state still in Zustand.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-decouple-cursor-ui-overlay/54-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
@src/core/canvas/CanvasEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert transient UI state to refs and add requestUiRedraw</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
    **Step 1: Add RAF-debounced requestUiRedraw helper**

    Add two new refs near the existing refs (around line 50):

        const uiDirtyRef = useRef(false);
        const uiRafIdRef = useRef<number | null>(null);

    Create a requestUiRedraw callback (after the drawUiLayer definition, around line 573):

        const requestUiRedraw = useCallback(() => {
          uiDirtyRef.current = true;
          if (uiRafIdRef.current !== null) return;
          uiRafIdRef.current = requestAnimationFrame(() => {
            uiRafIdRef.current = null;
            if (uiDirtyRef.current) {
              uiDirtyRef.current = false;
              drawUiLayer();
            }
          });
        }, [drawUiLayer]);

    **Step 2: Convert cursorTile from useState to useRef**

    - REMOVE: the useState declaration for cursorTile (line 68)
    - NOTE: cursorTileRef already exists at line 50 -- reuse it for all cursor tracking
    - In drawUiLayer (line 231-572), replace ALL reads of cursorTile.x / cursorTile.y with cursorTileRef.current.x / cursorTileRef.current.y
    - Remove cursorTile from drawUiLayer useCallback deps array (line 572)

    **Step 3: Convert lineState from useState to useRef**

    - REMOVE: the useState declaration for lineState (lines 61-67)
    - ADD: const lineStateRef = useRef<LineState>({ active: false, startX: 0, startY: 0, endX: 0, endY: 0 });
    - In drawUiLayer, replace all reads of lineState.active, lineState.startX, etc. with lineStateRef.current.active, lineStateRef.current.startX, etc.
    - Remove lineState from drawUiLayer useCallback deps array

    **Step 4: Convert selectionDrag from useState to useRef**

    - REMOVE: the useState declaration for selectionDrag (lines 72-78)
    - ADD: const selectionDragRef = useRef with the same type and initial value
    - In drawUiLayer, replace selectionDrag reads with selectionDragRef.current reads
    - Remove selectionDrag from drawUiLayer useCallback deps array

    **Step 5: Convert pastePreviewPosition from Zustand to useRef**

    - ADD: const pastePreviewRef = useRef<{ x: number; y: number } | null>(null);
    - In drawUiLayer, replace pastePreviewPosition reads with pastePreviewRef.current
    - Update guard condition from isPasting && clipboard && pastePreviewPosition && tilesetImage to isPasting && clipboard && pastePreviewRef.current && tilesetImage
    - Remove pastePreviewPosition from drawUiLayer useCallback deps array
    - Remove pastePreviewPosition from the useShallow selector at line 113-122 (keep isPasting and clipboard)
    - Remove setPastePreviewPosition selector at line 151

    **Step 6: Update drawUiLayer useEffect trigger**

    - The existing useEffect at line 647-649 remains -- it handles committed state changes (tool change, viewport change, grid toggle, etc.)
    - The animation-tick useEffect at line 652-657 remains unchanged -- depends on committed Zustand state only
    - The drawUiLayer deps array should now exclude cursorTile, lineState, selectionDrag, and pastePreviewPosition

    **Step 7: Add RAF cleanup on unmount**

    In the existing cleanup useEffect at line 1236-1242, also cancel uiRafIdRef:

        useEffect(() => {
          return () => {
            if (rafIdRef.current !== null) cancelAnimationFrame(rafIdRef.current);
            if (uiRafIdRef.current !== null) cancelAnimationFrame(uiRafIdRef.current);
          };
        }, []);
  </action>
  <verify>Run npm run typecheck -- zero TypeScript errors. Verify that cursorTile (as a useState variable) no longer appears. Verify setCursorTile, setLineState (useState setter), and setSelectionDrag (useState setter) no longer appear. Verify requestUiRedraw function exists. Verify drawUiLayer deps array does NOT contain cursorTile, lineState, selectionDrag, or pastePreviewPosition.</verify>
  <done>All four transient UI state variables converted to refs. drawUiLayer reads from refs. requestUiRedraw RAF helper exists. RAF cleanup on unmount.</done>
</task>

<task type="auto">
  <name>Task 2: Rewire mouse handlers and Escape handlers to use refs</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
    **Step 1: Update handleMouseMove (line 916-960)**

    - Line 922: Replace setCursorTile(prev => ...) with ref-based deduplication:

        const prevCursor = cursorTileRef.current;
        if (prevCursor.x !== x || prevCursor.y !== y) {
          cursorTileRef.current = { x, y };
          requestUiRedraw();
        }

    - Line 927: Replace setPastePreviewPosition(x, y) with:

        pastePreviewRef.current = { x, y };
        requestUiRedraw();

    - Line 944: Replace setLineState(prev => ...) with:

        const prevLine = lineStateRef.current;
        if (prevLine.endX !== x || prevLine.endY !== y) {
          lineStateRef.current = { ...prevLine, endX: x, endY: y };
          requestUiRedraw();
        }

    - Line 949: Replace setSelectionDrag(prev => ...) with:

        const prevSel = selectionDragRef.current;
        if (prevSel.endX !== x || prevSel.endY !== y) {
          selectionDragRef.current = { ...prevSel, endX: x, endY: y };
          requestUiRedraw();
        }

    - Update condition checks: replace lineState.active with lineStateRef.current.active, selectionDrag.active with selectionDragRef.current.active

    **Step 2: Update handleMouseDown (line 830-913)**

    - Line 864-870: Replace setLineState({...}) with lineStateRef.current = { active: true, startX: x, startY: y, endX: x, endY: y }; requestUiRedraw();
    - Line 896: Replace setSelectionDrag({...}) with selectionDragRef.current = { active: true, startX: x, startY: y, endX: x, endY: y }; requestUiRedraw();

    **Step 3: Update handleMouseUp (line 963-1040)**

    - Line 969-981: Replace selectionDrag reads with selectionDragRef.current reads. KEEP setSelection({...}) (Zustand commit). Replace setSelectionDrag({...}) reset with selectionDragRef.current = reset object; requestUiRedraw();

    - Line 985-1011: Replace lineState reads with lineStateRef.current reads. Replace setLineState({...}) reset with lineStateRef.current = reset object; requestUiRedraw();

    **Step 4: Update handleMouseLeave (line 1043-1082)**

    - Line 1068: Replace setCursorTile with cursorTileRef.current = { x: -1, y: -1 }; requestUiRedraw();
    - Line 1070-1072: Replace lineState.active with lineStateRef.current.active, replace setLineState with ref reset
    - Line 1076-1078: Set pastePreviewRef.current = null. Keep cancelPasting() call.
    - Line 1079-1081: Replace selectionDrag.active with selectionDragRef.current.active, replace setSelectionDrag with ref reset

    **Step 5: Update Escape key handlers**

    Since refs do not trigger useEffect re-runs, convert the ref-gated Escape listeners to permanent listeners that check ref values inside the handler:

    - Line 1267-1277 (line Escape): Remove the early return guard. Inside handler, check lineStateRef.current.active before resetting. Replace setLineState with ref reset + requestUiRedraw(). Change deps from [lineState.active] to [requestUiRedraw].

    - Line 1293-1303 (selection drag Escape): Same pattern -- remove early return guard. Inside handler check selectionDragRef.current.active. Replace setSelectionDrag with ref reset + requestUiRedraw(). Change deps from [selectionDrag.active] to [requestUiRedraw].

    ALTERNATIVE (preferred -- cleaner): Merge the line and selection drag Escape handlers into the existing permanent pencil drag Escape listener (line 1318-1339). Add checks for lineStateRef.current.active and selectionDragRef.current.active inside that handler. This reduces the number of window event listeners.

    **Step 6: Remove unused state and selectors**

    - Remove the setPastePreviewPosition selector (line 151) if no other code references it
    - Remove pastePreviewPosition from the useShallow selector (line 113-122) if not done in Task 1
    - Verify no remaining references to removed useState variables

    **Step 7: Verify no React state setters remain for transient UI**

    Ensure none of these patterns remain:
    - setCursorTile( -- zero occurrences
    - setLineState( -- zero occurrences
    - setSelectionDrag( -- zero occurrences
    - setPastePreviewPosition( -- zero occurrences
  </action>
  <verify>Run npm run typecheck -- zero TypeScript errors. Run npm run electron:dev and verify:
1. Cursor highlight follows mouse correctly across all tools
2. Line tool: preview line renders during drag, commits on mouseup
3. Selection tool: drag rectangle renders during drag, commits on mouseup
4. Paste preview: follows cursor while in paste mode
5. Escape cancels line, selection drag, and paste preview
6. No console errors during any interaction
7. Wall pencil still works (not migrated -- stays on Zustand)
8. Rect drag tools still work (not migrated -- stays on Zustand for Phase 55)</verify>
  <done>All mouse handlers use ref-based state. Zero useState setters called during mousemove. Escape handlers work as permanent listeners checking ref values. Committed state (selection, line tiles) still writes to Zustand on mouseup. Zero React re-renders during any tool mousemove interaction.</done>
</task>

</tasks>

<verification>
1. npm run typecheck passes with zero errors
2. No setCursorTile, setLineState (useState), setSelectionDrag (useState), or setPastePreviewPosition calls remain in mousemove handlers
3. requestUiRedraw function exists and is called from all ref mutations that affect rendering
4. drawUiLayer deps array does NOT contain any of the four migrated state variables
5. All Escape key handlers still function correctly
6. Committed state (selection finalized on mouseup, line tiles committed on mouseup) still flows through Zustand
7. RAF cleanup on unmount cancels uiRafIdRef
</verification>

<success_criteria>
- Zero React re-renders during cursor movement, line preview drag, selection drag, and paste preview positioning
- UI overlay redraws via RAF-debounced imperative call (requestUiRedraw)
- All four transient UI state variables (cursorTile, lineState, selectionDrag, pastePreviewPosition) stored in refs
- All committed state changes (mouseup actions) still write to Zustand
- TypeScript compiles cleanly
- All tools render their overlays correctly during interaction
</success_criteria>

<output>
After completion, create .planning/phases/54-decouple-cursor-ui-overlay/54-01-SUMMARY.md
</output>
