---
phase: 49-canvas-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/MapCanvas/MapCanvas.css
autonomous: true

must_haves:
  truths:
    - "Map canvas uses only 2 HTML canvas elements (map layer + UI overlay) instead of 4"
    - "Map layer renders all tiles (static + animated) in a single pass using pre-sliced ImageBitmap array"
    - "Map layer context created with alpha:false for compositor optimization"
    - "Grid renders via createPattern() fill instead of individual line strokes"
    - "All existing functionality preserved: pan drag, zoom, scrollbars, tools, selection, paste preview"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "2-layer canvas architecture with ImageBitmap atlas and pattern grid"
      contains: "alpha: false"
    - path: "src/components/MapCanvas/MapCanvas.css"
      provides: "Styles for 2-canvas layout (removed 2 redundant canvas layers)"
  key_links:
    - from: "MapCanvas.tsx createTileAtlas()"
      to: "drawMapLayer()"
      via: "tileAtlas state → bitmap lookup by tile ID"
      pattern: "tileAtlas\\.bitmaps\\[tileId\\]"
    - from: "MapCanvas.tsx drawUILayer()"
      to: "createPattern()"
      via: "cached grid pattern with zoom invalidation"
      pattern: "createPattern.*repeat"
    - from: "MapCanvas.tsx commitPan()"
      to: "drawMapLayer() + drawUILayer()"
      via: "pre-render with final viewport before clearing CSS transforms"
      pattern: "drawMapLayer.*drawUILayer"
---

<objective>
Consolidate MapCanvas from 4 canvas layers to 2, introduce ImageBitmap tile atlas for GPU-ready rendering, enable alpha:false compositor optimization on the map layer, and replace individual grid line strokes with pattern-based fill.

Purpose: Reduce compositor overhead (4→2 layers), eliminate per-draw CPU tile decode (ImageBitmap pre-slicing), enable opaque blending fast path (alpha:false), and replace O(N) grid line strokes with O(1) pattern fill.

Output: Optimized MapCanvas with 2-layer architecture, tile atlas, and pattern grid.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-canvas-optimization/49-RESEARCH.md
@.planning/phases/48-real-time-pan-rendering/48-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
@src/components/MapCanvas/MapCanvas.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: ImageBitmap tile atlas + layer consolidation (4→2) + alpha:false</name>
  <files>src/components/MapCanvas/MapCanvas.tsx, src/components/MapCanvas/MapCanvas.css</files>
  <action>
This is the core structural refactor. Perform all changes in MapCanvas.tsx and MapCanvas.css:

**1. Create ImageBitmap tile atlas utility (top of file, before component):**

```typescript
interface TileAtlas {
  bitmaps: ImageBitmap[];
  totalTiles: number;
}

async function createTileAtlas(
  tilesetImage: HTMLImageElement,
  tileSize: number = 16,
  tilesPerRow: number = 40
): Promise<TileAtlas> {
  const cols = Math.floor(tilesetImage.width / tileSize);
  const rows = Math.floor(tilesetImage.height / tileSize);
  const totalTiles = cols * rows;
  const bitmaps: ImageBitmap[] = new Array(totalTiles);
  const promises: Promise<void>[] = [];

  for (let tileId = 0; tileId < totalTiles; tileId++) {
    const col = tileId % tilesPerRow;
    const row = Math.floor(tileId / tilesPerRow);
    const sx = col * tileSize;
    const sy = row * tileSize;
    promises.push(
      createImageBitmap(tilesetImage, sx, sy, tileSize, tileSize)
        .then(bitmap => { bitmaps[tileId] = bitmap; })
    );
  }

  await Promise.all(promises);
  return { bitmaps, totalTiles };
}
```

Index by tile ID directly so `bitmaps[tileId]` is a direct lookup (no row/col conversion needed at draw time).

**2. Replace 4 canvas refs with 2:**

Remove:
```typescript
const staticLayerRef = useRef<HTMLCanvasElement>(null);
const animLayerRef = useRef<HTMLCanvasElement>(null);
const overlayLayerRef = useRef<HTMLCanvasElement>(null);
const gridLayerRef = useRef<HTMLCanvasElement>(null);
```

Add:
```typescript
const mapLayerRef = useRef<HTMLCanvasElement>(null);
const uiLayerRef = useRef<HTMLCanvasElement>(null);
```

**3. Add tile atlas state:**

```typescript
const [tileAtlas, setTileAtlas] = useState<TileAtlas | null>(null);
```

Add useEffect to create atlas when tilesetImage changes:
```typescript
useEffect(() => {
  if (!tilesetImage) { setTileAtlas(null); return; }
  createTileAtlas(tilesetImage, TILE_SIZE, TILES_PER_ROW)
    .then(atlas => setTileAtlas(atlas))
    .catch(err => console.error('Failed to create tile atlas:', err));
}, [tilesetImage]);
```

**4. Replace drawStaticLayer + drawAnimLayer with single drawMapLayer:**

The new drawMapLayer renders ALL tiles (static + animated) in a single pass:
- Get context with `{ alpha: false }` for compositor optimization
- Use `tileAtlas.bitmaps[tileId]` instead of `ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, ...)`
- For animated tiles: compute current frame from animationFrame + frameOffset, look up bitmap by resolved tile ID
- For static tiles: look up bitmap directly by tile value
- Guard with `if (!tileAtlas) return;` at the top (skip draw until atlas loads)
- Use `mapLayerRef` instead of `staticLayerRef`

Important: Keep the same ViewportOverride pattern from Phase 48 (the overrideViewport parameter).

**5. Replace drawOverlayLayer with drawUILayer:**

Rename drawOverlayLayer to drawUILayer. Change ref from `overlayLayerRef` to `uiLayerRef`. Keep all existing overlay drawing logic intact (cursor highlight, line preview, paste preview, selection rectangle, etc.). Grid rendering will be added in Task 2.

**6. Remove drawGridLayer as separate function.** The grid will be drawn inside drawUILayer in Task 2. For now, move the grid drawing logic inline into drawUILayer (keep the same line-stroke logic temporarily — Task 2 will replace it with pattern).

**7. Update getVisibleTiles and getScrollMetrics:**
- Change `gridLayerRef.current` references to `uiLayerRef.current` (the UI layer is the one that receives mouse events and determines canvas size)

**8. Update all scrollByTiles, handleTrackClick, handleScrollMouseMove:**
- Replace `gridLayerRef.current` with `uiLayerRef.current`

**9. Update screenToTile to use uiLayerRef (or just viewport, it doesn't use canvas ref).**

**10. Update handleMouseDown, handleMouseMove, handleMouseUp, handleMouseLeave:**
- Replace `gridLayerRef.current` references with `uiLayerRef.current`

**11. Update handleWheel:**
- Replace `gridLayerRef.current` references with `uiLayerRef.current`

**12. Update requestProgressiveRender:**
- Replace `gridLayerRef.current` references with `uiLayerRef.current`
- Change `drawStaticLayer(tempViewport); drawAnimLayer(tempViewport);` to `drawMapLayer(tempViewport);`
- Note: Only drawMapLayer during progressive render (UI overlay can lag 1 frame, same as before)

**13. Update commitPan:**
- Replace the 4 layer draws with 2: `drawMapLayer(finalViewport); drawUILayer(finalViewport);`
- Replace the 4 CSS transform clears with 2 (mapLayerRef, uiLayerRef)
- Replace `staticLayerRef`/`animLayerRef`/`overlayLayerRef`/`gridLayerRef` references with `mapLayerRef`/`uiLayerRef`

**14. Update pan CSS transform application in handleMouseMove:**
- Replace 4 transform assignments with 2 (mapLayerRef.current, uiLayerRef.current)

**15. Update layer-specific render triggers (useEffects):**
- Replace the 4 separate useEffects with 2:
  - `useEffect(() => { drawMapLayer(); }, [drawMapLayer]);`
  - `useEffect(() => { drawUILayer(); }, [drawUILayer]);`
- Update the conditional animation useEffect to use drawUILayer

**16. Update ResizeObserver:**
- Resize 2 canvases instead of 4
- Call drawMapLayer() + drawUILayer() instead of 4 layer draws

**17. Update JSX:**
- Replace 4 canvas elements with 2:
  - `<canvas ref={mapLayerRef} className="map-canvas-layer no-events" />` (bottom layer, no events)
  - `<canvas ref={uiLayerRef} className="map-canvas-layer map-canvas" onMouseDown=... onMouseMove=... />` (top layer, receives events)

**18. Update MapCanvas.css:**
- No structural CSS changes needed (same class names work for 2 canvases). The `.map-canvas-layer`, `.no-events`, `.map-canvas` classes remain as-is.

**19. Update drawMapLayer useCallback dependency array:**
- Dependencies: `[map, viewport, tilesetImage, tileAtlas, animationFrame, getVisibleTiles]`
- Note: animationFrame is now a dependency of drawMapLayer (merged from drawAnimLayer)

**20. Update drawUILayer useCallback dependency array:**
- Should include all the overlay dependencies plus showGrid + grid-related deps
- Dependencies: same as current drawOverlayLayer deps + showGrid + getVisibleTiles

**Key constraint:** The `tilesetImage` prop must still be used as fallback for overlay drawing (paste preview, conveyor preview) because those draw from clipboard data, not the tile atlas. Use `tilesetImage` with source rect for overlay tile rendering (same as current overlay logic). Only the main map tiles use the atlas.

Actually, for paste preview and conveyor preview in the overlay: these also draw tiles from the tileset. They CAN use the atlas too. Update all overlay tile drawing to use `tileAtlas.bitmaps[tileId]` instead of `ctx.drawImage(tilesetImage, srcX, srcY, ...)`. Guard with `if (tileAtlas)` checks.
  </action>
  <verify>
Run `npm run typecheck` — should pass with zero errors.
Run `npm run electron:dev` — app should launch, map should render all tiles correctly.
Verify:
- Tiles render correctly (no blank tiles, no wrong tiles)
- Pan drag works (CSS transform + progressive render)
- Zoom works
- Scrollbars track viewport correctly
- Selection tool works
- Paste preview renders
- Animated tiles animate
- Grid lines render (temporary line-stroke logic in drawUILayer)
  </verify>
  <done>
MapCanvas uses 2 canvas elements (mapLayerRef + uiLayerRef) instead of 4. Map layer context created with alpha:false. All tiles rendered using ImageBitmap atlas (no source rect calculations). All existing functionality preserved: pan, zoom, scrollbars, tools, selection, paste.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pattern-based grid rendering</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Replace the line-stroke grid rendering (moved into drawUILayer in Task 1) with createPattern() + fillRect.

**1. Add module-level grid pattern cache (outside component, top of file):**

```typescript
let cachedGridPattern: CanvasPattern | null = null;
let cachedGridZoom: number | null = null;

function createGridPattern(tilePixels: number): CanvasPattern | null {
  const size = Math.round(tilePixels);
  if (size < 1) return null;

  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = size;
  patternCanvas.height = size;

  const pctx = patternCanvas.getContext('2d');
  if (!pctx) return null;

  // Draw right and bottom edges of a single grid cell
  pctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  pctx.lineWidth = 1;
  pctx.beginPath();
  // Right edge
  pctx.moveTo(size - 0.5, 0);
  pctx.lineTo(size - 0.5, size);
  // Bottom edge
  pctx.moveTo(0, size - 0.5);
  pctx.lineTo(size, size - 0.5);
  pctx.stroke();

  // Create pattern from a temporary context (not the pattern canvas itself)
  const tmpCanvas = document.createElement('canvas');
  const tmpCtx = tmpCanvas.getContext('2d');
  return tmpCtx?.createPattern(patternCanvas, 'repeat') ?? null;
}
```

Use `size - 0.5` for crisp 1px lines (sub-pixel alignment on canvas 2D).

**2. Inside drawUILayer, replace the grid line-stroke block with pattern fill:**

Replace the block that draws vertical/horizontal lines with:
```typescript
if (showGrid) {
  const tilePixels = TILE_SIZE * vp.zoom;

  // Invalidate pattern cache when zoom changes
  if (cachedGridZoom !== vp.zoom) {
    cachedGridPattern = createGridPattern(tilePixels);
    cachedGridZoom = vp.zoom;
  }

  if (cachedGridPattern) {
    // Calculate viewport offset for pattern alignment
    const offsetX = -((vp.x * tilePixels) % tilePixels);
    const offsetY = -((vp.y * tilePixels) % tilePixels);

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.fillStyle = cachedGridPattern;
    ctx.fillRect(-offsetX, -offsetY, canvas.width, canvas.height);
    ctx.restore();
  }
}
```

The pattern is cached and only recreated when zoom changes. Viewport offset via translate() ensures grid lines align with tile boundaries during pan.

**3. Draw grid BEFORE overlay elements** so selection/cursor/tool previews render on top of grid lines. Place the grid pattern fill at the beginning of drawUILayer (after clearRect), before any overlay drawing (cursor, selection, etc.).

**4. Remove getVisibleTiles from drawUILayer's grid section** — pattern fill doesn't need visible tile range (it fills entire canvas, clipped automatically).

**5. Verify the showGrid dependency is included in drawUILayer's useCallback deps** (should already be there from Task 1).
  </action>
  <verify>
Run `npm run typecheck` — should pass with zero errors.
Run `npm run electron:dev` — verify:
- Grid lines render correctly at all zoom levels (0.25x to 4x)
- Grid lines align perfectly with tile boundaries
- Grid lines stay aligned during pan drag
- Grid lines update correctly when zooming in/out
- Grid toggle (show/hide) works
- No visible difference in grid appearance vs previous line-stroke rendering
  </verify>
  <done>
Grid rendered via createPattern() + single fillRect call instead of individual line strokes. Pattern cached and invalidated on zoom change. Grid lines align with tile boundaries at all zoom levels and during pan.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run typecheck` passes with zero errors
2. Only 2 `<canvas>` elements in DOM (inspect via DevTools Elements panel)
3. Map layer context has alpha:false (verify in code: `getContext('2d', { alpha: false })`)
4. Tiles render using ImageBitmap atlas (no `drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, ...)` in drawMapLayer)
5. Grid uses createPattern (no `ctx.moveTo`/`ctx.lineTo` in grid rendering)
6. All tools work: pencil, fill, wall, line, select, paste, conveyor, game objects
7. Pan drag works with progressive render + scrollbar sync
8. Zoom to cursor works at all zoom levels
9. Animated tiles animate correctly
10. Selection rectangle and paste preview render correctly
</verification>

<success_criteria>
- MapCanvas renders with exactly 2 canvas elements (map + UI overlay)
- Map layer created with alpha:false context option
- Tiles drawn using pre-sliced ImageBitmap array (tileAtlas.bitmaps[tileId])
- Grid rendered with createPattern() + fillRect (O(1) instead of O(N) line strokes)
- All existing functionality preserved (pan, zoom, scrollbars, tools, selection, paste, animation)
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/49-canvas-optimization/49-01-SUMMARY.md`
</output>
