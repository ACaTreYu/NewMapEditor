---
phase: 49-canvas-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/MapCanvas/MapCanvas.css
autonomous: true

must_haves:
  truths:
    - "Map canvas uses only 2 HTML canvas elements (map layer + UI overlay) instead of 4"
    - "Map layer renders all tiles (static + animated) in a single pass using pre-sliced ImageBitmap array"
    - "Map layer context created with alpha:false for compositor optimization"
    - "Grid renders via createPattern() fill instead of individual line strokes"
    - "Pan drag works with CSS transform + progressive render + scrollbar sync"
    - "Zoom to cursor works at all zoom levels (0.25x to 4x)"
    - "All tools work: pencil, fill, wall, line, select, paste, conveyor, game objects"
    - "Selection rectangle and paste preview render correctly on UI overlay"
    - "Animated tiles animate at correct frame rate with correct frame offsets"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "2-layer canvas architecture with ImageBitmap atlas and pattern grid"
      contains: "alpha: false"
    - path: "src/components/MapCanvas/MapCanvas.css"
      provides: "Styles for 2-canvas layout (removed 2 redundant canvas layers)"
  key_links:
    - from: "MapCanvas.tsx createTileAtlas()"
      to: "drawMapLayer()"
      via: "tileAtlas state -> bitmap lookup by tile ID"
      pattern: "tileAtlas\\.bitmaps\\[tileId\\]"
    - from: "MapCanvas.tsx drawUILayer()"
      to: "createGridPattern()"
      via: "cached grid pattern with zoom invalidation; initialized on first showGrid=true render when cachedGridPattern is null"
      pattern: "createPattern.*repeat"
    - from: "MapCanvas.tsx commitPan()"
      to: "drawMapLayer() + drawUILayer()"
      via: "pre-render with final viewport before clearing CSS transforms"
      pattern: "drawMapLayer.*drawUILayer"
---

<objective>
Consolidate MapCanvas from 4 canvas layers to 2, introduce ImageBitmap tile atlas for GPU-ready rendering, enable alpha:false compositor optimization on the map layer, and replace individual grid line strokes with pattern-based fill.

Purpose: Reduce compositor overhead (4->2 layers), eliminate per-draw CPU tile decode (ImageBitmap pre-slicing), enable opaque blending fast path (alpha:false), and replace O(N) grid line strokes with O(1) pattern fill.

Output: Optimized MapCanvas with 2-layer architecture, tile atlas, and pattern grid.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-canvas-optimization/49-RESEARCH.md
@.planning/phases/48-real-time-pan-rendering/48-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
@src/components/MapCanvas/MapCanvas.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImageBitmap atlas utility + state</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Add the ImageBitmap tile atlas infrastructure to MapCanvas.tsx. This task only ADDS new code; it does not yet remove old layers or change rendering.

**1. Create ImageBitmap tile atlas utility (top of file, before component):**

```typescript
interface TileAtlas {
  bitmaps: ImageBitmap[];
  totalTiles: number;
}

async function createTileAtlas(
  tilesetImage: HTMLImageElement,
  tileSize: number = 16,
  tilesPerRow: number = 40
): Promise<TileAtlas> {
  const cols = Math.floor(tilesetImage.width / tileSize);
  const rows = Math.floor(tilesetImage.height / tileSize);
  const totalTiles = cols * rows;
  const bitmaps: ImageBitmap[] = new Array(totalTiles);
  const promises: Promise<void>[] = [];

  for (let tileId = 0; tileId < totalTiles; tileId++) {
    const col = tileId % tilesPerRow;
    const row = Math.floor(tileId / tilesPerRow);
    const sx = col * tileSize;
    const sy = row * tileSize;
    promises.push(
      createImageBitmap(tilesetImage, sx, sy, tileSize, tileSize)
        .then(bitmap => { bitmaps[tileId] = bitmap; })
    );
  }

  await Promise.all(promises);
  return { bitmaps, totalTiles };
}
```

Index by tile ID directly so `bitmaps[tileId]` is a direct lookup (no row/col conversion needed at draw time).

**2. Add tile atlas state inside component:**

```typescript
const [tileAtlas, setTileAtlas] = useState<TileAtlas | null>(null);
```

**3. Add useEffect to create atlas when tilesetImage changes:**

```typescript
useEffect(() => {
  if (!tilesetImage) { setTileAtlas(null); return; }
  createTileAtlas(tilesetImage, TILE_SIZE, TILES_PER_ROW)
    .then(atlas => setTileAtlas(atlas))
    .catch(err => console.error('Failed to create tile atlas:', err));
}, [tilesetImage]);
```

This task is additive only. The atlas will be used by the drawMapLayer function created in Task 2. The existing 4-layer rendering continues to work unchanged until Task 2 swaps it out.
  </action>
  <verify>
Run `npm run typecheck` -- should pass with zero errors. The new TileAtlas interface, createTileAtlas function, and useState/useEffect are additive and do not conflict with existing code.
  </verify>
  <done>
TileAtlas interface and createTileAtlas() utility exist at module scope. Component has tileAtlas state populated via useEffect when tilesetImage loads. Atlas indexes bitmaps by tile ID for O(1) lookup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Consolidate layers (4->2) + alpha:false + drawMapLayer + drawUILayer</name>
  <files>src/components/MapCanvas/MapCanvas.tsx, src/components/MapCanvas/MapCanvas.css</files>
  <action>
This is the core structural refactor. Replace the 4-layer canvas architecture with 2 layers and create the new draw functions.

**1. Replace 4 canvas refs with 2:**

Remove:
```typescript
const staticLayerRef = useRef<HTMLCanvasElement>(null);
const animLayerRef = useRef<HTMLCanvasElement>(null);
const overlayLayerRef = useRef<HTMLCanvasElement>(null);
const gridLayerRef = useRef<HTMLCanvasElement>(null);
```

Add:
```typescript
const mapLayerRef = useRef<HTMLCanvasElement>(null);
const uiLayerRef = useRef<HTMLCanvasElement>(null);
```

**2. Replace drawStaticLayer + drawAnimLayer with single drawMapLayer:**

The new drawMapLayer renders ALL tiles (static + animated) in a single pass:
- Get context with `{ alpha: false }` for compositor optimization
- Use `tileAtlas.bitmaps[tileId]` instead of `ctx.drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, ...)`
- For animated tiles: compute current frame from animationFrame + frameOffset, look up bitmap by resolved tile ID
- For static tiles: look up bitmap directly by tile value
- Guard with `if (!tileAtlas) return;` at the top (skip draw until atlas loads)
- Use `mapLayerRef` instead of `staticLayerRef`

Important: Keep the same ViewportOverride pattern from Phase 48 (the overrideViewport parameter).

Dependencies for drawMapLayer useCallback: `[map, viewport, tilesetImage, tileAtlas, animationFrame, getVisibleTiles]`
Note: animationFrame is now a dependency of drawMapLayer (merged from drawAnimLayer).

**3. Replace drawOverlayLayer + drawGridLayer with single drawUILayer:**

Rename drawOverlayLayer to drawUILayer. Change ref from `overlayLayerRef` to `uiLayerRef`. Keep all existing overlay drawing logic intact (cursor highlight, line preview, paste preview, selection rectangle, etc.).

For grid: move the existing grid line-stroke logic from drawGridLayer inline into drawUILayer as a **temporary placeholder**. Keep it functionally identical to the old drawGridLayer. This temporary line-stroke grid will be replaced by pattern-based rendering in Task 3. Place grid drawing BEFORE overlay elements (after clearRect) so selection/cursor/tool previews render on top of grid lines.

For paste preview and overlay tile drawing: update to use `tileAtlas.bitmaps[tileId]` instead of `ctx.drawImage(tilesetImage, srcX, srcY, ...)`. Guard with `if (tileAtlas)` checks.

Dependencies for drawUILayer useCallback: same as current drawOverlayLayer deps + showGrid + getVisibleTiles.

**4. Update MapCanvas.css:**

No structural CSS changes needed (same class names work for 2 canvases). The `.map-canvas-layer`, `.no-events`, `.map-canvas` classes remain as-is.

**5. Update JSX (replace 4 canvas elements with 2):**

```jsx
<canvas ref={mapLayerRef} className="map-canvas-layer no-events" />
<canvas ref={uiLayerRef} className="map-canvas-layer map-canvas" onMouseDown=... onMouseMove=... />
```

**6. Update all ref usages throughout the component:**

Every reference to the old 4 refs must be updated:

- `getVisibleTiles` and `getScrollMetrics`: change `gridLayerRef.current` to `uiLayerRef.current`
- `scrollByTiles`, `handleTrackClick`, `handleScrollMouseMove`: replace `gridLayerRef.current` with `uiLayerRef.current`
- `screenToTile`: use `uiLayerRef` if it references a canvas ref
- `handleMouseDown`, `handleMouseMove`, `handleMouseUp`, `handleMouseLeave`: replace `gridLayerRef.current` with `uiLayerRef.current`
- `handleWheel`: replace `gridLayerRef.current` with `uiLayerRef.current`
- `requestProgressiveRender`: replace `gridLayerRef.current` with `uiLayerRef.current`; change `drawStaticLayer(tempViewport); drawAnimLayer(tempViewport);` to `drawMapLayer(tempViewport);`
- `commitPan`: replace the 4 layer draws with 2: `drawMapLayer(finalViewport); drawUILayer(finalViewport);`; replace the 4 CSS transform clears with 2 (mapLayerRef, uiLayerRef)
- Pan CSS transform application in handleMouseMove: replace 4 transform assignments with 2 (mapLayerRef.current, uiLayerRef.current)
- Layer-specific render triggers (useEffects): replace the 4 separate useEffects with 2:
  - `useEffect(() => { drawMapLayer(); }, [drawMapLayer]);`
  - `useEffect(() => { drawUILayer(); }, [drawUILayer]);`
- ResizeObserver: resize 2 canvases instead of 4; call drawMapLayer() + drawUILayer() instead of 4 layer draws

**Key constraint:** The `tilesetImage` prop must still be available for any edge case that can't use the atlas (if any). In practice, all tile drawing (map + overlay) should use the atlas via `tileAtlas.bitmaps[tileId]`.
  </action>
  <verify>
Run `npm run typecheck` -- should pass with zero errors.
Run `npm run electron:dev` -- app should launch, map should render all tiles correctly.
Verify:
- Tiles render correctly (no blank tiles, no wrong tiles)
- Pan drag works (CSS transform + progressive render)
- Zoom works
- Scrollbars track viewport correctly
- Selection tool works
- Paste preview renders
- Animated tiles animate
- Grid lines render (temporary line-stroke logic in drawUILayer)
  </verify>
  <done>
MapCanvas uses 2 canvas elements (mapLayerRef + uiLayerRef) instead of 4. Map layer context created with alpha:false. All tiles rendered using ImageBitmap atlas (no source rect calculations). Grid temporarily uses inline line-stroke logic (unchanged behavior). All existing functionality preserved: pan, zoom, scrollbars, tools, selection, paste.
  </done>
</task>

<task type="auto">
  <name>Task 3: Pattern-based grid rendering</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Replace the temporary line-stroke grid rendering (moved into drawUILayer in Task 2) with createPattern() + fillRect.

**1. Add module-level grid pattern cache (outside component, top of file):**

```typescript
let cachedGridPattern: CanvasPattern | null = null;
let cachedGridZoom: number | null = null;

function createGridPattern(tilePixels: number): CanvasPattern | null {
  const size = Math.round(tilePixels);
  if (size < 1) return null;

  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = size;
  patternCanvas.height = size;

  const pctx = patternCanvas.getContext('2d');
  if (!pctx) return null;

  // Draw right and bottom edges of a single grid cell
  pctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  pctx.lineWidth = 1;
  pctx.beginPath();
  // Right edge
  pctx.moveTo(size - 0.5, 0);
  pctx.lineTo(size - 0.5, size);
  // Bottom edge
  pctx.moveTo(0, size - 0.5);
  pctx.lineTo(size, size - 0.5);
  pctx.stroke();

  // Create pattern from a temporary context (not the pattern canvas itself)
  const tmpCanvas = document.createElement('canvas');
  const tmpCtx = tmpCanvas.getContext('2d');
  return tmpCtx?.createPattern(patternCanvas, 'repeat') ?? null;
}
```

Use `size - 0.5` for crisp 1px lines (sub-pixel alignment on canvas 2D).

**2. Inside drawUILayer, replace the temporary line-stroke grid block with pattern fill:**

Replace the block that draws vertical/horizontal lines with:
```typescript
if (showGrid) {
  const tilePixels = TILE_SIZE * vp.zoom;

  // Initialize or invalidate pattern cache when zoom changes.
  // On first showGrid=true render, both cachedGridPattern and cachedGridZoom
  // are null, so this condition is true and the pattern gets created.
  if (cachedGridZoom !== vp.zoom) {
    cachedGridPattern = createGridPattern(tilePixels);
    cachedGridZoom = vp.zoom;
  }

  if (cachedGridPattern) {
    // Calculate viewport offset for pattern alignment
    const offsetX = -((vp.x * tilePixels) % tilePixels);
    const offsetY = -((vp.y * tilePixels) % tilePixels);

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.fillStyle = cachedGridPattern;
    ctx.fillRect(-offsetX, -offsetY, canvas.width, canvas.height);
    ctx.restore();
  }
}
```

The pattern is cached and only recreated when zoom changes. On the very first render with showGrid=true, `cachedGridZoom` is null and `vp.zoom` is a number, so `cachedGridZoom !== vp.zoom` evaluates to true, triggering pattern creation. Subsequent renders at the same zoom hit the cache. Viewport offset via translate() ensures grid lines align with tile boundaries during pan.

**3. Grid is already positioned BEFORE overlay elements** (placed there in Task 2) so selection/cursor/tool previews render on top of grid lines. Verify this ordering is maintained.

**4. Remove getVisibleTiles from drawUILayer's grid section** -- pattern fill doesn't need visible tile range (it fills entire canvas, clipped automatically). If the temporary line-stroke code from Task 2 used getVisibleTiles for the grid, remove that usage.

**5. Verify the showGrid dependency is included in drawUILayer's useCallback deps** (should already be there from Task 2).
  </action>
  <verify>
Run `npm run typecheck` -- should pass with zero errors.
Run `npm run electron:dev` -- verify:
- Grid lines render correctly at all zoom levels (0.25x to 4x)
- Grid lines align perfectly with tile boundaries
- Grid lines stay aligned during pan drag
- Grid lines update correctly when zooming in/out
- Grid toggle (show/hide) works
- No visible difference in grid appearance vs previous line-stroke rendering
  </verify>
  <done>
Grid rendered via createPattern() + single fillRect call instead of individual line strokes. Pattern cached at module scope and invalidated on zoom change. First render initializes pattern from null state. Grid lines align with tile boundaries at all zoom levels and during pan.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run typecheck` passes with zero errors
2. Only 2 `<canvas>` elements in DOM (inspect via DevTools Elements panel)
3. Map layer context has alpha:false (verify in code: `getContext('2d', { alpha: false })`)
4. Tiles render using ImageBitmap atlas (no `drawImage(tilesetImage, srcX, srcY, TILE_SIZE, TILE_SIZE, ...)` in drawMapLayer)
5. Grid uses createPattern (no `ctx.moveTo`/`ctx.lineTo` in grid rendering)
6. All tools work: pencil, fill, wall, line, select, paste, conveyor, game objects
7. Pan drag works with progressive render + scrollbar sync
8. Zoom to cursor works at all zoom levels
9. Animated tiles animate correctly
10. Selection rectangle and paste preview render correctly
</verification>

<success_criteria>
- MapCanvas renders with exactly 2 canvas elements (map + UI overlay)
- Map layer created with alpha:false context option
- Tiles drawn using pre-sliced ImageBitmap array (tileAtlas.bitmaps[tileId])
- Grid rendered with createPattern() + fillRect (O(1) instead of O(N) line strokes)
- Pan drag works with CSS transform + progressive render + scrollbar sync
- Zoom to cursor works at all zoom levels (0.25x to 4x)
- All tools work: pencil, fill, wall, line, select, paste, conveyor, game objects
- Selection rectangle and paste preview render correctly on UI overlay
- Animated tiles animate at correct frame rate with correct frame offsets
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/49-canvas-optimization/49-01-SUMMARY.md`
</output>
