---
phase: 52-engine-subscribes-to-zustand
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/canvas/CanvasEngine.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Canvas redraws on viewport change without React useEffect triggering drawMapLayer"
    - "Canvas redraws on map tile change (undo, fill, line commit) via engine subscription, not React re-render"
    - "Animation ticks update visible animated tiles via engine subscription, not React useEffect"
    - "Map subscription is guarded by isDragActive flag (currently always false, Phase 53 wires it)"
    - "Engine cleanup on detach unsubscribes all Zustand subscriptions and cancels pending RAF"
  artifacts:
    - path: "src/core/canvas/CanvasEngine.ts"
      provides: "setupSubscriptions(), getViewport(), getMap(), dirty flags, isDragActive guard"
      contains: "useEditorStore.subscribe"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Simplified component without rendering useEffect blocks"
      min_lines: 1300
  key_links:
    - from: "src/core/canvas/CanvasEngine.ts"
      to: "useEditorStore"
      via: "subscribe() in setupSubscriptions()"
      pattern: "useEditorStore\\.subscribe"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "attach() with documentId"
      pattern: "engine\\.attach.*documentId"
---

<objective>
Wire CanvasEngine to subscribe directly to Zustand store for viewport, map, and animation state changes. Remove React useEffect blocks that trigger canvas rendering, keeping only the engine's own subscriptions as the rendering driver.

Purpose: This is the core architectural shift of v2.8 — React reconciliation is removed from the rendering hot path. When Zustand state changes, the engine redraws the canvas immediately without waiting for React to schedule, reconcile, and commit a component update.

Output: CanvasEngine with 3 Zustand subscriptions (viewport, map, animation), dirty flags, and isDragActive guard. MapCanvas with old rendering useEffect blocks removed.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-extract-canvasengine-class/51-01-SUMMARY.md
@.planning/phases/52-engine-subscribes-to-zustand/52-RESEARCH.md
@src/core/canvas/CanvasEngine.ts
@src/components/MapCanvas/MapCanvas.tsx
@src/core/editor/slices/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Zustand subscriptions, dirty flags, and helpers to CanvasEngine</name>
  <files>src/core/canvas/CanvasEngine.ts</files>
  <action>
Add the following to CanvasEngine class in `src/core/canvas/CanvasEngine.ts`:

**New imports at top of file:**
```typescript
import { useEditorStore } from '@core/editor';
import type { MapData } from '@core/map';
```
Note: `MapData` is already imported — just add `useEditorStore`.

**New private fields (add after existing fields, before `attach()`):**
```typescript
private unsubscribers: Array<() => void> = [];
private documentId: string | null = null;
private animationFrame: number = 0;
private rafId: number | null = null;
private isDragActive: boolean = false; // Phase 53 will wire beginDrag/commitDrag
private dirty = {
  mapBuffer: false,
  mapBlit: false,
  uiOverlay: false
};
```

**Modify `attach()` signature and body:**
Change signature to `attach(screenCanvas: HTMLCanvasElement, documentId?: string): void`
Add at end of attach body (after `this.detached = false;`):
```typescript
this.documentId = documentId ?? null;
this.setupSubscriptions();
```

**Modify `detach()` to clean up subscriptions:**
Add at the beginning of detach() body, BEFORE `this.detached = true;`:
```typescript
// Unsubscribe from Zustand
this.unsubscribers.forEach(unsub => unsub());
this.unsubscribers = [];

// Cancel pending RAF
if (this.rafId !== null) {
  cancelAnimationFrame(this.rafId);
  this.rafId = null;
}
```

**Add private `setupSubscriptions()` method:**
Three subscriptions using the existing proven pattern from MapCanvas.tsx line 637:

Subscription 1 — Viewport changes (immediate blit):
- Compare `this.getViewport(state)` !== `this.getViewport(prevState)` by reference
- Guard: `if (!this.screenCtx) return;`
- On change: call `this.blitToScreen(vp, this.screenCtx.canvas.width, this.screenCtx.canvas.height)`

Subscription 2 — Map tile changes (incremental patch, drag-guarded):
- Guard: `if (this.isDragActive) return;` (SUB-03 requirement)
- Guard: `if (!this.screenCtx) return;`
- Compare `this.getMap(state)` !== `this.getMap(prevState)` by reference
- On change: call `this.drawMapLayer(map, this.getViewport(state), this.animationFrame)`

Subscription 3 — Animation frame (patch animated tiles):
- Compare `state.animationFrame !== prevState.animationFrame`
- Update `this.animationFrame = state.animationFrame;`
- Guard: `if (!this.tilesetImage || !this.screenCtx) return;`
- Read map and viewport, call `this.patchAnimatedTiles(map, vp, state.animationFrame, canvasWidth, canvasHeight)`

Push each subscription's unsubscribe function to `this.unsubscribers`.

**Add private `getViewport()` helper:**
```typescript
private getViewport(state: ReturnType<typeof useEditorStore.getState>): Viewport {
  if (this.documentId) {
    const doc = state.documents.get(this.documentId);
    return doc?.viewport ?? { x: 0, y: 0, zoom: 1 };
  }
  return state.viewport;
}
```
Uses `this.documentId` (instance field, not closure capture) to avoid stale closure pitfall.

**Add private `getMap()` helper:**
```typescript
private getMap(state: ReturnType<typeof useEditorStore.getState>): MapData | null {
  if (this.documentId) {
    return state.documents.get(this.documentId)?.map ?? null;
  }
  return state.map;
}
```

**Key constraints:**
- Do NOT add `subscribeWithSelector` middleware — manual reference checks are sufficient
- Do NOT add RAF debouncing yet — synchronous draw in subscriptions is fine for Phase 52
- The `isDragActive` flag is declared but always `false` until Phase 53 adds `beginDrag()`/`commitDrag()`
- All subscription callbacks must guard against null `screenCtx`/`bufferCtx` (Pitfall 4 from research)
- Use `this.documentId` in subscriptions (instance field), NOT closure-captured parameter
  </action>
  <verify>
Run `npm run typecheck` — should compile with no new errors. Verify the file contains:
1. `useEditorStore.subscribe` called 3 times inside `setupSubscriptions()`
2. `this.unsubscribers.push(...)` for each subscription
3. `this.isDragActive` guard in map subscription
4. `detach()` iterates `this.unsubscribers` and calls each
5. `attach()` accepts optional `documentId` parameter and calls `setupSubscriptions()`
  </verify>
  <done>
CanvasEngine has 3 Zustand subscriptions (viewport blit, map patch, animation tick) with proper null guards, isDragActive guard on map subscription, and full cleanup in detach(). TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove old React useEffect rendering triggers from MapCanvas</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Modify `src/components/MapCanvas/MapCanvas.tsx` to remove the React useEffect blocks that are now redundant (engine subscriptions handle them):

**1. Remove drawMapLayer useEffect (lines 628-630):**
Delete this entire block:
```typescript
useEffect(() => {
  drawMapLayer();
}, [drawMapLayer]);
```
This useEffect triggered a full drawMapLayer on every dependency change. The engine's map subscription now handles this.

**2. Remove viewport subscription useEffect (lines 637-657):**
Delete this entire block:
```typescript
useEffect(() => {
  const unsub = useEditorStore.subscribe((state, prevState) => {
    // ... viewport blit logic ...
  });
  return unsub;
}, [documentId]);
```
This subscription is now inside CanvasEngine.setupSubscriptions() (Subscription 1).

**3. Remove animation tick useEffect (lines 661-682):**
Delete this entire block:
```typescript
useEffect(() => {
  const engine = engineRef.current;
  if (!engine || !tilesetImage) return;
  // ... animation patching logic ...
}, [animationFrame, tilesetImage, documentId, drawUiLayer]);
```
This is now handled by CanvasEngine.setupSubscriptions() (Subscription 3).

**IMPORTANT — Handle the animation-triggered UI redraw:**
The old animation useEffect (line 678-681) also triggered `drawUiLayer()` when animated overlays were active (paste preview, conveyor preview, selection with animations). This behavior must be preserved. Add a NEW focused useEffect that ONLY handles this UI overlay case:

```typescript
// Redraw UI overlay when animation ticks affect visible overlays (paste/conveyor/selection)
useEffect(() => {
  if (selection?.active || (isPasting && clipboard) ||
      (rectDragState?.active && currentTool === ToolType.CONVEYOR)) {
    drawUiLayer();
  }
}, [animationFrame, selection, isPasting, clipboard, rectDragState, currentTool, drawUiLayer]);
```

Place this right after the `drawUiLayer` useEffect (line 632-634), which IS being kept.

**4. KEEP the drawUiLayer useEffect (lines 632-634):**
```typescript
useEffect(() => {
  drawUiLayer();
}, [drawUiLayer]);
```
This stays — Phase 54 will move UI overlay rendering into the engine.

**5. Update engine mount effect to pass documentId:**
Change the mount effect (lines 1265-1276) to pass `documentId` to `attach()`:
```typescript
useEffect(() => {
  const canvas = mapLayerRef.current;
  if (!canvas) return;
  const engine = new CanvasEngine();
  engine.attach(canvas, documentId);
  if (tilesetImage) engine.setTilesetImage(tilesetImage);
  engineRef.current = engine;
  return () => {
    engine.detach();
    engineRef.current = null;
  };
}, []);
```
Note: `documentId` does not change for a given MapCanvas instance (it's a prop from MDI window), so reading it in mount effect is safe. The engine stores it as an instance field.

**6. Remove unused `animationFrame` subscription (line 97):**
After removing the animation useEffect, check if `animationFrame` is still needed in the component. It IS still needed for the new animation-overlay useEffect above, so KEEP IT.

**7. Verify `drawMapLayer` callback is still used:**
After removing the useEffect that called `drawMapLayer()`, verify it's still referenced by:
- `requestProgressiveRender` (line 578) — yes, still used for pan drag
- `commitPan` (line 610-611) — yes, still used for pan commit
- `drawMapLayerRef.current = drawMapLayer` (line 624) — yes, ResizeObserver uses this
So keep `drawMapLayer` and all its dependencies.

**Key constraints:**
- Do NOT remove `drawUiLayer` useEffect (line 632-634) — Phase 54 handles that
- Do NOT remove the `map`/`viewport` useShallow subscription (line 83-94) — still needed for `drawUiLayer`, `drawMapLayer` callback deps, scroll calculations, and mouse handlers
- Do NOT remove `animationFrame` selector (line 97) — still needed for UI overlay animation
- The initial render on mount is handled by `drawMapLayer` being called via ResizeObserver and the engine's subscription firing when state is read for the first time
  </action>
  <verify>
Run `npm run typecheck` — should compile with no new errors.

Verify by counting useEffect blocks related to rendering:
- REMOVED: `drawMapLayer` trigger (was line 628)
- REMOVED: viewport subscription (was line 637)
- REMOVED: animation tick (was line 661)
- KEPT: `drawUiLayer` trigger (line 632)
- ADDED: animation-overlay UI redraw
- KEPT: engine mount/unmount (line 1265)
- KEPT: tileset update (line 1279)

Verify the component still has `drawMapLayer` callback defined (needed by pan, resize, commitPan).

Run `npm run electron:dev` and verify:
1. Map renders correctly on load
2. Pan works (right-click drag)
3. Zoom works (mouse wheel)
4. Pencil tool draws tiles with immediate feedback
5. Animations play
6. Undo/redo triggers canvas update
  </verify>
  <done>
MapCanvas no longer has React useEffect blocks driving drawMapLayer, viewport blit, or animation tick. All three are driven by CanvasEngine's Zustand subscriptions. The drawUiLayer useEffect remains (Phase 54). The component still defines drawMapLayer for pan/resize use. TypeScript compiles and the editor functions identically.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation:** `npm run typecheck` passes with no new errors
2. **Visual verification:** `npm run electron:dev` — map renders, tools work, animations play
3. **Subscription-driven rendering:** In CanvasEngine.ts, all rendering is triggered by `useEditorStore.subscribe()` callbacks
4. **No double rendering:** The old React useEffect blocks (drawMapLayer trigger, viewport subscription, animation tick) are removed. Only engine subscriptions remain.
5. **isDragActive guard present:** Map subscription in CanvasEngine checks `this.isDragActive` before redrawing (currently always false, Phase 53 will activate it)
6. **Proper cleanup:** Engine.detach() unsubscribes all listeners, cancels RAF, nulls refs
7. **UI overlay preserved:** drawUiLayer useEffect still active (Phase 54 will migrate it)
</verification>

<success_criteria>
- CanvasEngine has 3 Zustand subscriptions driving all canvas rendering
- MapCanvas has 3 fewer rendering useEffect blocks (drawMapLayer, viewport, animation)
- Per-layer dirty flags declared in engine (mapBuffer, mapBlit, uiOverlay)
- isDragActive boolean declared in engine (Phase 53 wires it)
- Zero behavioral regression — map renders, tools work, animations play identically
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/52-engine-subscribes-to-zustand/52-01-SUMMARY.md`
</output>
