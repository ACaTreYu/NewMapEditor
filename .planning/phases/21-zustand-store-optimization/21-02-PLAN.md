---
phase: 21-zustand-store-optimization
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/components/ToolBar/ToolBar.tsx
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Every component in the app uses granular selectors (no bare useEditorStore() destructuring anywhere)"
    - "animationFrame changes only re-render MapCanvas, AnimationPanel, and AnimationPreview"
    - "ToolBar canUndo/canRedo buttons update reactively when undo/redo stack changes"
    - "Tool switches don't re-render StatusBar, Minimap, or MapSettingsPanel"
    - "Application builds with zero TypeScript errors"
    - "All existing functionality preserved (tools, drawing, selection, clipboard, undo/redo)"
  artifacts:
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "Granular selectors with reactive canUndo/canRedo"
      contains: "useShallow"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Granular selectors split into state and actions"
      contains: "useShallow"
  key_links:
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "Selector-based canUndo/canRedo derived from undoStack/redoStack length"
      pattern: "state\\.undoStack\\.length > 0"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "useShallow selector including animationFrame for animated tile rendering"
      pattern: "useShallow.*animationFrame"
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "useShallow selector WITHOUT animationFrame (ToolBar should not re-render on animation ticks)"
      pattern: "useShallow.*currentTool"
---

<objective>
Migrate the two most complex components (ToolBar and MapCanvas) from bare useEditorStore() destructuring to granular selectors. Fix the canUndo/canRedo reactivity bug by replacing method calls with selector-based derived state.

Purpose: Complete the store optimization. ToolBar is the most important fix because its canUndo/canRedo buttons currently don't update reactively AND it unnecessarily re-renders on animationFrame changes. MapCanvas legitimately needs animationFrame but should use granular selectors for all other state.

Output: Zero bare useEditorStore() calls remaining in codebase. canUndo/canRedo buttons update reactively. ToolBar isolated from animationFrame re-renders.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-zustand-store-optimization/21-RESEARCH.md
@.planning/phases/21-zustand-store-optimization/21-01-SUMMARY.md
@src/core/editor/EditorState.ts
@src/components/ToolBar/ToolBar.tsx
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate ToolBar to granular selectors with reactive canUndo/canRedo</name>
  <files>src/components/ToolBar/ToolBar.tsx</files>
  <action>
  Replace the bare `useEditorStore()` destructuring with granular selectors. This component is critical because:
  1. It currently calls `canUndo()` and `canRedo()` as methods, which DON'T trigger re-renders when stacks change
  2. It subscribes to the entire store, re-rendering on every animationFrame tick (every 150ms) despite not displaying animations

  Add import:
  ```typescript
  import { useShallow } from 'zustand/react/shallow';
  ```

  Replace the existing destructuring block:
  ```typescript
  const {
    currentTool, setTool, showGrid, toggleGrid,
    undo, redo, canUndo, canRedo, map,
    gameObjectToolState, setSpawnType, setSwitchType,
    setBunkerSettings, setHoldingPenType, setBridgeDirection,
    setConveyorDirection, copySelection, cutSelection,
    pasteClipboard, deleteSelection
  } = useEditorStore();
  ```

  With these granular selectors:

  ```typescript
  // State subscriptions (only these trigger re-renders)
  const { currentTool, showGrid, map, gameObjectToolState } = useEditorStore(
    useShallow((state) => ({
      currentTool: state.currentTool,
      showGrid: state.showGrid,
      map: state.map,
      gameObjectToolState: state.gameObjectToolState
    }))
  );

  // Reactive derived state (replaces canUndo()/canRedo() methods)
  const canUndo = useEditorStore((state) => state.undoStack.length > 0);
  const canRedo = useEditorStore((state) => state.redoStack.length > 0);

  // Action subscriptions (stable references, never cause re-renders)
  const setTool = useEditorStore((state) => state.setTool);
  const toggleGrid = useEditorStore((state) => state.toggleGrid);
  const undo = useEditorStore((state) => state.undo);
  const redo = useEditorStore((state) => state.redo);
  const setSpawnType = useEditorStore((state) => state.setSpawnType);
  const setSwitchType = useEditorStore((state) => state.setSwitchType);
  const setBunkerSettings = useEditorStore((state) => state.setBunkerSettings);
  const setHoldingPenType = useEditorStore((state) => state.setHoldingPenType);
  const setBridgeDirection = useEditorStore((state) => state.setBridgeDirection);
  const setConveyorDirection = useEditorStore((state) => state.setConveyorDirection);
  const copySelection = useEditorStore((state) => state.copySelection);
  const cutSelection = useEditorStore((state) => state.cutSelection);
  const pasteClipboard = useEditorStore((state) => state.pasteClipboard);
  const deleteSelection = useEditorStore((state) => state.deleteSelection);
  ```

  **Critical change for canUndo/canRedo:** Since plan 01 removed the methods from the store, replace `disabled={!canUndo()}` with `disabled={!canUndo}` and `disabled={!canRedo()}` with `disabled={!canRedo}`. These are now boolean VALUES from selectors, not methods to call.

  Find these two lines in the JSX and update:
  - `disabled={!canUndo()}` becomes `disabled={!canUndo}`
  - `disabled={!canRedo()}` becomes `disabled={!canRedo}`

  **Do NOT change:**
  - Any event handlers, JSX structure, CSS imports
  - The variant configs (they read from gameObjectToolState which is already selected)
  - The keyboard shortcut useEffect (it uses the action references which are stable)
  - Any other logic

  **Note:** ToolBar does NOT subscribe to animationFrame, so it will no longer re-render every 150ms.
  </action>
  <verify>
  Run `npx tsc --noEmit 2>&1 | grep ToolBar` to verify zero compile errors in ToolBar.
  Run `npm run electron:dev`, open a map, draw some tiles, verify undo/redo buttons enable/disable reactively as you draw and undo.
  Verify tool switching still works, grid toggle works, keyboard shortcuts work.
  </verify>
  <done>ToolBar uses granular selectors. canUndo/canRedo are reactive boolean selectors (not method calls). ToolBar does not subscribe to animationFrame. All toolbar functionality preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate MapCanvas to granular selectors split into state and actions</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
  Replace the bare `useEditorStore()` destructuring with granular selectors. MapCanvas is the largest consumer (~20 fields) but the migration is mechanical.

  Add import:
  ```typescript
  import { useShallow } from 'zustand/react/shallow';
  ```

  Replace the existing destructuring block:
  ```typescript
  const {
    map, viewport, showGrid, currentTool, selectedTile, tileSelection,
    animationFrame, rectDragState, gameObjectToolState, selection,
    setTile, setTiles, placeWall, eraseTile, fillArea, setSelectedTile,
    restorePreviousTool, setViewport, pushUndo, placeGameObject,
    placeGameObjectRect, setRectDragState, setSelection, clearSelection
  } = useEditorStore();
  ```

  With these granular selectors:

  ```typescript
  // State subscriptions (triggers re-renders when these values change)
  const {
    map, viewport, showGrid, currentTool, selectedTile, tileSelection,
    animationFrame, rectDragState, gameObjectToolState, selection
  } = useEditorStore(
    useShallow((state) => ({
      map: state.map,
      viewport: state.viewport,
      showGrid: state.showGrid,
      currentTool: state.currentTool,
      selectedTile: state.selectedTile,
      tileSelection: state.tileSelection,
      animationFrame: state.animationFrame,
      rectDragState: state.rectDragState,
      gameObjectToolState: state.gameObjectToolState,
      selection: state.selection
    }))
  );

  // Action subscriptions (stable references, never cause re-renders)
  const {
    setTile, setTiles, placeWall, eraseTile, fillArea, setSelectedTile,
    restorePreviousTool, setViewport, pushUndo, placeGameObject,
    placeGameObjectRect, setRectDragState, setSelection, clearSelection
  } = useEditorStore(
    useShallow((state) => ({
      setTile: state.setTile,
      setTiles: state.setTiles,
      placeWall: state.placeWall,
      eraseTile: state.eraseTile,
      fillArea: state.fillArea,
      setSelectedTile: state.setSelectedTile,
      restorePreviousTool: state.restorePreviousTool,
      setViewport: state.setViewport,
      pushUndo: state.pushUndo,
      placeGameObject: state.placeGameObject,
      placeGameObjectRect: state.placeGameObjectRect,
      setRectDragState: state.setRectDragState,
      setSelection: state.setSelection,
      clearSelection: state.clearSelection
    }))
  );
  ```

  **Do NOT change:**
  - Any drawing logic, event handlers, scroll bar handlers, JSX
  - The `draw()` callback dependencies array
  - Any useEffect hooks
  - The lineState, cursorTile, selectionDrag, or other local state
  - Any other imports or logic

  **Note:** MapCanvas legitimately needs animationFrame for rendering animated tiles and marching ants. It will still re-render on animation ticks, which is correct behavior.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify zero TypeScript errors across the entire project.
  Run `npm run electron:dev` and verify:
  1. Map renders tiles correctly
  2. Animated tiles animate smoothly
  3. Grid toggles on/off
  4. All tools work (pencil, eraser, fill, wall, line, rect, select, picker)
  5. Zoom and pan work
  6. Marching ants selection animates
  7. Scroll bars work
  8. Game object tools place correctly
  </verify>
  <done>MapCanvas uses granular selectors. State and actions split into separate useShallow calls. Zero bare useEditorStore() destructuring remains anywhere in the codebase. All canvas functionality preserved.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -rn "} = useEditorStore()" src/` returns zero results (no bare destructuring anywhere)
3. `grep -rn "useShallow" src/` shows imports in ToolBar, MapCanvas, and all components migrated in plan 01
4. `grep -rn "canUndo()\|canRedo()" src/` returns zero results (no method calls, only selector booleans)
5. `grep -rn "animationFrame" src/components/ToolBar/` returns zero results (ToolBar does not subscribe to animationFrame)
6. App runs with all features working: tools, undo/redo, animation, selection, clipboard
</verification>

<success_criteria>
- Zero bare useEditorStore() destructuring calls remain in the entire codebase
- ToolBar canUndo/canRedo are reactive selectors that update when undo/redo stacks change
- ToolBar does NOT subscribe to animationFrame (no re-render every 150ms)
- MapCanvas subscribes to animationFrame (needed for animated tiles and marching ants)
- TypeScript compiles with zero errors
- All existing functionality preserved: all tools, undo/redo, zoom/pan, selection, clipboard, game objects
</success_criteria>

<output>
After completion, create `.planning/phases/21-zustand-store-optimization/21-02-SUMMARY.md`
</output>
