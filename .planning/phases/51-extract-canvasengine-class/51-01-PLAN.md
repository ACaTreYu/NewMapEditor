---
phase: 51-extract-canvasengine-class
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/canvas/CanvasEngine.ts
  - src/core/canvas/index.ts
  - src/core/index.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Map renders identically to before (tiles, animations, zoom, pan all work)"
    - "Tile editing with pencil tool shows immediate visual feedback (no flicker, no delay)"
    - "Animation tick updates animated tiles on the buffer and blits to screen"
    - "Viewport changes (pan, zoom, scroll) blit correctly from buffer"
    - "No rendering logic remains as useCallback in MapCanvas (only engine method calls)"
  artifacts:
    - path: "src/core/canvas/CanvasEngine.ts"
      provides: "CanvasEngine class with buffer management, rendering, blitting"
      exports: ["CanvasEngine"]
    - path: "src/core/canvas/index.ts"
      provides: "Barrel export for canvas module"
      exports: ["CanvasEngine"]
    - path: "src/core/index.ts"
      provides: "Updated core barrel to include canvas module"
      contains: "export * from './canvas'"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Thin React wrapper delegating rendering to CanvasEngine"
      contains: "engineRef"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "engineRef.current created in useEffect, attach/detach on mount/unmount"
      pattern: "engine\\.attach\\("
    - from: "src/core/canvas/CanvasEngine.ts"
      to: "src/core/map/types.ts"
      via: "imports MAP_WIDTH, MAP_HEIGHT, TILE_SIZE, ANIMATION_DEFINITIONS"
      pattern: "import.*from.*@core/map"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "drawMapLayer calls engine.drawMapLayer(), immediatePatchTile calls engine.patchTile(), multi-tile stamp calls engine.patchTileBuffer() + engine.blitToScreen()"
      pattern: "engine(Ref\\.current)?\\.(drawMapLayer|patchTile|patchTileBuffer|blitToScreen)"
---

<objective>
Extract all canvas rendering logic from MapCanvas.tsx into a standalone CanvasEngine class at `src/core/canvas/CanvasEngine.ts`. The engine owns the off-screen buffer, tile rendering, incremental patching, viewport blitting, and animation tick rendering. MapCanvas becomes a thin React wrapper that creates the engine on mount, detaches on unmount, and delegates all pixel operations to it.

Purpose: Foundation for v2.8 Canvas Engine milestone. Decoupling rendering from React eliminates stale closure bugs, simplifies dependency tracking, and enables future Zustand subscription-driven rendering (Phase 52).

Output: CanvasEngine class + rewired MapCanvas component with zero behavioral change.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-extract-canvasengine-class/51-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
@src/core/map/types.ts
@src/core/map/index.ts
@src/core/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CanvasEngine class with buffer management and rendering methods</name>
  <files>
    src/core/canvas/CanvasEngine.ts
    src/core/canvas/index.ts
    src/core/index.ts
  </files>
  <action>
Create `src/core/canvas/CanvasEngine.ts` as a plain TypeScript class that encapsulates all rendering logic currently scattered across MapCanvas.tsx. This is a mechanical extraction — no behavioral changes, no new algorithms.

**Class structure:**

```typescript
export class CanvasEngine {
  // Private state (replaces scattered refs in MapCanvas)
  private buffer: HTMLCanvasElement | null = null;
  private bufferCtx: CanvasRenderingContext2D | null = null;
  private screenCtx: CanvasRenderingContext2D | null = null;
  private prevTiles: Uint16Array | null = null;
  private prevTileset: HTMLImageElement | null = null;
  private lastBlitVp: { x: number; y: number; zoom: number } | null = null;
  private tilesetImage: HTMLImageElement | null = null;
  private detached: boolean = false;

  // Lifecycle
  attach(screenCanvas: HTMLCanvasElement): void
  detach(): void
  setTilesetImage(img: HTMLImageElement | null): void

  // Rendering (extracted from MapCanvas useCallbacks)
  renderTile(ctx: CanvasRenderingContext2D, tile: number, destX: number, destY: number, destSize: number, animFrame: number): void
  drawMapLayer(map: MapData, viewport: Viewport, animFrame: number): void
  blitToScreen(viewport: Viewport, canvasWidth: number, canvasHeight: number): void
  patchTile(tileX: number, tileY: number, tile: number, viewport: Viewport, animFrame: number): void
  patchTileBuffer(tileX: number, tileY: number, tile: number, animFrame: number): void
  patchAnimatedTiles(map: MapData, viewport: Viewport, animFrame: number, canvasWidth: number, canvasHeight: number): boolean
}
```

**Extract these specific functions from MapCanvas.tsx:**

1. **`renderTile()`** — Lines 36-66. Move the standalone function into the class as a method. Instead of accepting `tilesetImg` as a parameter, read from `this.tilesetImage`. Keep the same tile rendering logic (animated tiles with ANIMATION_DEFINITIONS, static tiles, fallback colors).

2. **`attach(screenCanvas)`** — New method combining buffer creation logic from lines 268-276 of `drawMapLayer`. Creates off-screen 4096x4096 buffer, gets 2d contexts, stores screen context. Throw if getContext fails (fail fast, per research).

3. **`detach()`** — New method combining cleanup logic from lines 1424-1434. Sets `this.detached = true`, nulls buffer/contexts/prevTiles. Follows research pitfall #3 pattern.

4. **`setTilesetImage(img)`** — Stores tileset image reference. Follows research pitfall #4 pattern (stateful approach).

5. **`drawMapLayer(map, viewport, animFrame)`** — Extract from lines 261-326. Note: signature is `drawMapLayer(map: MapData, viewport: Viewport, animFrame: number): void` — no screenCanvas parameter. The engine already has the screen context from `attach()`. Handles both full buffer rebuild (when prevTiles is null or tileset changed) and incremental patch (diff and update only changed tiles). Then blits buffer to screen.

6. **`blitToScreen(viewport, canvasWidth, canvasHeight)`** — Extract from lines 231-244 (`immediateBlitToScreen`). Single drawImage from buffer to screen at given viewport.

7. **`patchTile(tileX, tileY, tile, viewport, animFrame)`** — Extract from lines 246-256 (`immediatePatchTile`). Patches single tile on buffer, updates prevTiles snapshot, blits to screen. This is the single-tile fast path that patches AND blits in one call.

8. **`patchTileBuffer(tileX, tileY, tile, animFrame)`** — Extract the buffer-patch-only operation (no blit) for batch tile updates in multi-tile stamps. Does clearRect + renderTile + prevTiles snapshot update on the buffer, but does NOT call blitToScreen. This allows callers to patch N tiles then blit once, avoiding N redundant blits during multi-tile stamp placement.

9. **`patchAnimatedTiles(map, viewport, animFrame, canvasWidth, canvasHeight)`** — Extract from lines 786-832 (animation tick useEffect body). Patches only animated tiles in visible area on the buffer, blits to screen. Returns boolean indicating whether any animated tiles were updated.

**Import requirements:**
- `MAP_WIDTH`, `MAP_HEIGHT`, `TILE_SIZE`, `ANIMATION_DEFINITIONS` from `@core/map`
- `MapData` type from `@core/map`

**Viewport type:** Define a local interface `{ x: number; y: number; zoom: number }` or reuse existing.

**Constants:** `TILES_PER_ROW = 40` — move to CanvasEngine or import from constants.

**Critical details per research pitfalls:**
- `assertAttached()` private method: throws if buffer/bufferCtx/screenCtx are null. Call at top of public render methods instead of scattered null checks.
- `detached` flag: checked at start of `drawMapLayer`, `blitToScreen`, `patchTile`, `patchTileBuffer`, `patchAnimatedTiles` — early return if detached.
- Buffer creation in `attach()` always creates fresh 4096x4096 canvas with `imageSmoothingEnabled = false`.
- `screenCtx.imageSmoothingEnabled = false` set in every blit operation (matches existing code).
- `prevTiles` comparison uses direct Uint16Array element comparison (matches existing incremental patch).
- The "skip blit if nothing changed" optimization from lines 310-314 must be preserved.

**Do NOT:**
- Make CanvasEngine a singleton (MDI requires one per document)
- Add Zustand subscription logic (that's Phase 52)
- Add drag-related state (that's Phase 53)
- Add UI overlay rendering (drawUiLayer stays in MapCanvas for now)
- Import from Zustand — engine is a pure rendering executor

Create `src/core/canvas/index.ts` with `export { CanvasEngine } from './CanvasEngine';`

Update `src/core/index.ts` to add `export * from './canvas';` after existing exports.
  </action>
  <verify>
Run `npm run typecheck` — zero TypeScript errors. The CanvasEngine class should compile cleanly with proper types for all methods and properties.
  </verify>
  <done>
`src/core/canvas/CanvasEngine.ts` exists with attach/detach lifecycle, renderTile, drawMapLayer (full rebuild + incremental patch), blitToScreen, patchTile, patchTileBuffer (buffer-only patch for batch operations), and patchAnimatedTiles methods. Barrel exports work. TypeScript compiles with zero errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewire MapCanvas to use CanvasEngine for all rendering</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
Modify MapCanvas.tsx to create a CanvasEngine instance and delegate all rendering to it. The component retains all mouse handling, tool logic, scrollbar UI, and escape key handlers — only pixel operations move to the engine.

**Changes to make:**

1. **Add engine ref:**
```typescript
import { CanvasEngine } from '@core/canvas';
const engineRef = useRef<CanvasEngine | null>(null);
```

2. **Mount/unmount lifecycle (replace buffer cleanup useEffect at lines 1424-1434):**
```typescript
useEffect(() => {
  const canvas = mapLayerRef.current;
  if (!canvas) return;

  const engine = new CanvasEngine();
  engine.attach(canvas);
  if (tilesetImage) engine.setTilesetImage(tilesetImage);
  engineRef.current = engine;

  return () => {
    engine.detach();
    engineRef.current = null;
  };
}, []); // Mount once — tileset updates handled separately
```

3. **Tileset update effect:**
```typescript
useEffect(() => {
  engineRef.current?.setTilesetImage(tilesetImage ?? null);
}, [tilesetImage]);
```

4. **Remove these refs** (now owned by engine):
- `mapBufferRef` — engine owns buffer
- `mapBufferCtxRef` — engine owns buffer context
- `prevTilesRef` — engine owns tile snapshot
- `prevTilesetRef` — engine owns tileset tracking
- `lastBlitVpRef` — engine owns blit viewport tracking

5. **Remove standalone `renderTile` function** (lines 36-66) — now a method on CanvasEngine.

6. **Replace `immediateBlitToScreen` useCallback** (lines 230-244) with:
```typescript
const immediateBlitToScreen = useCallback((vp: { x: number; y: number; zoom: number }) => {
  const engine = engineRef.current;
  const canvas = mapLayerRef.current;
  if (!engine || !canvas) return;
  engine.blitToScreen(vp, canvas.width, canvas.height);
}, []);
```

7. **Replace `immediatePatchTile` useCallback** (lines 246-256) with:
```typescript
const immediatePatchTile = useCallback((tileX: number, tileY: number, tile: number, vp: { x: number; y: number; zoom: number }) => {
  const engine = engineRef.current;
  if (!engine) return;
  engine.patchTile(tileX, tileY, tile, vp, animFrameRef.current);
}, []);
```
Note: No more dependency on `tilesetImage` or `immediateBlitToScreen` — engine has those internally.

8. **Replace `drawMapLayer` useCallback** (lines 261-326) with:
```typescript
const drawMapLayer = useCallback((overrideViewport?: ViewportOverride) => {
  const engine = engineRef.current;
  if (!engine || !map) return;
  const vp = overrideViewport ?? viewport;
  engine.drawMapLayer(map, vp, animFrameRef.current);
}, [map, viewport]);
```
Note: `tilesetImage` removed from deps — engine tracks it internally.

9. **Replace animation tick useEffect** (lines 786-839) with:
```typescript
useEffect(() => {
  const engine = engineRef.current;
  if (!engine || !tilesetImage) return;

  const state = useEditorStore.getState();
  const doc = documentId ? state.documents.get(documentId) : null;
  const currentMap = doc ? doc.map : state.map;
  const vp = doc ? (doc.viewport ?? { x: 0, y: 0, zoom: 1 }) : state.viewport;
  if (!currentMap) return;

  const canvas = mapLayerRef.current;
  if (!canvas) return;

  const hasAnimated = engine.patchAnimatedTiles(currentMap, vp, animationFrame, canvas.width, canvas.height);

  // Redraw UI layer only if animated overlays are active
  if (hasAnimated || state.selection?.active || (state.isPasting && state.clipboard) ||
      (state.rectDragState?.active && state.currentTool === ToolType.CONVEYOR)) {
    drawUiLayer();
  }
}, [animationFrame, tilesetImage, documentId, drawUiLayer]);
```

10. **Replace direct store subscription** (lines 753-782) with engine-delegated version:
```typescript
useEffect(() => {
  const unsub = useEditorStore.subscribe((state, prevState) => {
    const engine = engineRef.current;
    const canvas = mapLayerRef.current;
    if (!engine || !canvas) return;

    const getVp = (s: typeof state) => {
      if (documentId) {
        const doc = s.documents.get(documentId);
        return doc?.viewport ?? { x: 0, y: 0, zoom: 1 };
      }
      return s.viewport;
    };
    const vp = getVp(state);
    const prevVp = getVp(prevState);
    if (vp !== prevVp) {
      engine.blitToScreen(vp, canvas.width, canvas.height);
    }
  });
  return unsub;
}, [documentId]);
```

11. **Update `handleToolAction`** (lines 1304-1352): The multi-tile stamp path (lines 1328-1337) directly accesses `mapBufferCtxRef.current` and calls `renderTile()`. Replace with `patchTileBuffer` (buffer-only, no blit) for each tile, then a single `blitToScreen` at the end:
```typescript
const canvas = mapLayerRef.current;
for (const t of tiles) {
  if (t.x >= 0 && t.x < MAP_WIDTH && t.y >= 0 && t.y < MAP_HEIGHT) {
    engineRef.current?.patchTileBuffer(t.x, t.y, t.tile, animFrameRef.current);
  }
}
if (canvas) {
  engineRef.current?.blitToScreen(viewport, canvas.width, canvas.height);
}
```
This avoids N redundant blits — patches all tiles on the buffer first, then blits once to screen. This is why `patchTileBuffer` exists as a separate method from `patchTile`.

12. **Update ResizeObserver** (lines 1537-1539): Replace `drawMapLayerRef.current()` with engine delegation. The stable ref pattern stays the same — just the function body changes.

13. **Keep drawUiLayer exactly as-is.** UI overlay rendering stays in MapCanvas. It still uses `tileToScreen`, `getLineTiles`, and all the cursor/selection/preview drawing. This is intentional — Phase 54 extracts UI overlay.

**What stays in MapCanvas (not extracted):**
- All useState hooks (isDragging, lineState, cursorTile, selectionDrag, etc.)
- All mouse event handlers (handleMouseDown/Move/Up/Leave/Wheel)
- All tool logic (handleToolAction, line drawing, wall pencil, rect drag)
- drawUiLayer and all overlay rendering
- Scroll bar logic and UI
- Escape key handlers
- Progressive pan rendering (requestProgressiveRender, commitPan)

**Critical: No behavioral change.** The app must render and interact exactly the same before and after this change. The only difference is where the rendering functions live (engine class vs component useCallbacks).
  </action>
  <verify>
1. `npm run typecheck` passes with zero errors.
2. `npm run electron:dev` launches the app successfully.
3. Open a map file — tiles render correctly at all zoom levels (0.25x to 4x).
4. Draw with pencil tool (single tile) — immediate visual feedback, no flicker.
4b. Select multi-tile region in palette (e.g. 2x2), stamp onto map — immediate rendering, no flicker, single blit after all tiles patched.
5. Pan the map (right-click drag) — smooth progressive rendering.
6. Animated tiles animate correctly.
7. Zoom to cursor (mouse wheel) — correct behavior.
8. All tools still work (pencil, fill, wall, line, select, game objects).
  </verify>
  <done>
MapCanvas.tsx creates CanvasEngine on mount, detaches on unmount, and delegates all pixel operations (drawMapLayer, blitToScreen, patchTile, patchTileBuffer, patchAnimatedTiles) to the engine. No rendering useCallbacks with buffer/context logic remain in MapCanvas. The standalone renderTile function is removed. All refs for buffer management (mapBufferRef, mapBufferCtxRef, prevTilesRef, prevTilesetRef, lastBlitVpRef) are removed from MapCanvas. Multi-tile stamps use patchTileBuffer (buffer-only) + single blitToScreen for efficient batch rendering. App behavior is identical to before.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript:** `npm run typecheck` — zero errors
2. **Runtime:** `npm run electron:dev` — app launches, map loads, all rendering works
3. **Code audit:**
   - `src/core/canvas/CanvasEngine.ts` exists with all extracted rendering methods
   - `MapCanvas.tsx` no longer contains `mapBufferRef`, `mapBufferCtxRef`, `prevTilesRef`, `prevTilesetRef`, `lastBlitVpRef`
   - `MapCanvas.tsx` no longer contains standalone `renderTile()` function
   - `MapCanvas.tsx` references `engineRef.current` for all pixel operations
   - `drawUiLayer` is still in MapCanvas (not extracted yet — Phase 54)
4. **Functional:** Pencil draw, fill, wall, line, select, game objects, pan, zoom, scroll bars, animated tiles — all work identically
5. **Multi-tile stamp:** Select 2x2+ region in palette, stamp onto map — renders correctly without flicker, uses patchTileBuffer batch path

Requirements satisfied: ENG-01 (CanvasEngine class owns rendering), ENG-02 (React delegates via lifecycle effects), ENG-03 (no rendering logic in React useCallbacks)
</verification>

<success_criteria>
- CanvasEngine class exists at `src/core/canvas/CanvasEngine.ts` with attach/detach lifecycle
- Engine owns: off-screen buffer, buffer context, screen context, prevTiles snapshot, tileset image reference
- Engine methods: drawMapLayer (full rebuild + incremental patch), blitToScreen, patchTile, patchTileBuffer (buffer-only for batch ops), patchAnimatedTiles, renderTile
- MapCanvas creates engine on mount, detaches on unmount
- Zero rendering logic in React useCallbacks (only thin wrappers calling engine methods)
- Multi-tile stamp uses patchTileBuffer + single blitToScreen (no N redundant blits)
- Zero behavioral change — app works identically before and after
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/51-extract-canvasengine-class/51-01-SUMMARY.md`
</output>
