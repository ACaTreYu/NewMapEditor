---
phase: 48-real-time-pan-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Pan drag shows immediate visual feedback via CSS transform while canvas progressively re-renders tiles underneath"
    - "Tiles update during pan drag via RAF-debounced canvas redraws (not just on mouse release)"
    - "Viewport state commits to Zustand only on mouse release (not during drag)"
    - "Scrollbar thumb positions update in real-time during pan drag"
    - "No visible snap-back when mouse is released after pan drag"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "RAF progressive render during pan drag, parameterized draw functions, scrollbar sync"
      contains: "rafIdRef"
  key_links:
    - from: "handleMouseMove pan branch"
      to: "requestProgressiveRender"
      via: "Called after applying CSS transform"
      pattern: "requestProgressiveRender"
    - from: "requestProgressiveRender"
      to: "drawStaticLayer/drawAnimLayer"
      via: "RAF callback passes temporary viewport"
      pattern: "requestAnimationFrame"
    - from: "getScrollMetrics"
      to: "panDeltaRef"
      via: "Uses temporary viewport during drag for thumb position"
      pattern: "panDeltaRef\\.current"
    - from: "handleMouseUp/handleMouseLeave"
      to: "cancelAnimationFrame"
      via: "Cancels pending RAF before committing viewport"
      pattern: "cancelAnimationFrame"
---

<objective>
Implement RAF-debounced progressive canvas rendering during pan drag, with real-time scrollbar sync and snap-back prevention.

Purpose: Currently, pan drag applies CSS transforms for instant feedback but canvas tiles only re-render on mouse release. This creates a "frozen" canvas during long drags (especially at low zoom). Progressive rendering keeps tiles fresh during drag, and scrollbars tracking the pan position completes the professional UX.

Output: Modified MapCanvas.tsx with progressive pan rendering, parameterized draw functions, scrollbar sync during drag, and clean mouseup transition.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-real-time-pan-rendering/48-RESEARCH.md
@.planning/phases/47-ui-cleanup-scrollbar-math-fix/47-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize draw functions and add RAF progressive render infrastructure</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
  This task adds viewport-override support to draw functions and implements the RAF-debounced progressive render loop.

  **Step 1: Define a Viewport type alias** (top of component, after imports):
  ```typescript
  interface ViewportOverride { x: number; y: number; zoom: number }
  ```

  **Step 2: Parameterize `getVisibleTiles`** to accept an optional viewport override:
  ```typescript
  const getVisibleTiles = useCallback((overrideViewport?: ViewportOverride) => {
    const vp = overrideViewport ?? viewport;
    const canvas = gridLayerRef.current;
    if (!canvas) return { startX: 0, startY: 0, endX: 20, endY: 20 };
    const tilePixels = TILE_SIZE * vp.zoom;
    const tilesX = Math.ceil(canvas.width / tilePixels) + 1;
    const tilesY = Math.ceil(canvas.height / tilePixels) + 1;
    return {
      startX: Math.floor(vp.x),
      startY: Math.floor(vp.y),
      endX: Math.min(MAP_WIDTH, Math.floor(vp.x) + tilesX),
      endY: Math.min(MAP_HEIGHT, Math.floor(vp.y) + tilesY)
    };
  }, [viewport]);
  ```

  **Step 3: Parameterize `drawStaticLayer`** to accept optional viewport:
  Add parameter `(overrideViewport?: ViewportOverride)`. Inside, use `const vp = overrideViewport ?? viewport;` and replace all `viewport.x`, `viewport.y`, `viewport.zoom` with `vp.x`, `vp.y`, `vp.zoom`. Pass `overrideViewport` to `getVisibleTiles(overrideViewport)`.

  **Step 4: Parameterize `drawAnimLayer`** the same way. Use `vp` for viewport access, pass `overrideViewport` to `getVisibleTiles`.

  **Step 5: Parameterize `drawGridLayer`** the same way. Use `vp` for viewport access, pass `overrideViewport` to `getVisibleTiles`.

  **Step 6: Parameterize `drawOverlayLayer`** the same way. Use `vp` for viewport access. Note: this function also calls `tileToScreen` — parameterize `tileToScreen` too:
  ```typescript
  const tileToScreen = useCallback((tileX: number, tileY: number, overrideViewport?: ViewportOverride) => {
    const vp = overrideViewport ?? viewport;
    const tilePixels = TILE_SIZE * vp.zoom;
    return {
      x: (tileX - vp.x) * tilePixels,
      y: (tileY - vp.y) * tilePixels
    };
  }, [viewport]);
  ```
  Pass `overrideViewport` through `drawOverlayLayer` to `tileToScreen` calls inside it.

  **IMPORTANT:** The existing no-arg calls (from useEffect triggers, resize observer, etc.) must continue to work unchanged. The `overrideViewport` parameter is optional — when omitted, functions use the Zustand `viewport` as before.

  **Step 7: Add RAF refs and pan delta ref** near other refs (after `panStartRef`):
  ```typescript
  const rafIdRef = useRef<number | null>(null);
  const panDeltaRef = useRef<{ dx: number; dy: number } | null>(null);
  ```
  `panDeltaRef` stores the current pixel delta during drag so the RAF callback can read fresh values without stale closures.

  **Step 8: Create `requestProgressiveRender` function** (after draw functions, before useEffect triggers):
  ```typescript
  const requestProgressiveRender = useCallback(() => {
    if (rafIdRef.current !== null) {
      cancelAnimationFrame(rafIdRef.current);
    }
    rafIdRef.current = requestAnimationFrame(() => {
      rafIdRef.current = null;
      if (!panStartRef.current || !panDeltaRef.current) return;

      const { dx, dy } = panDeltaRef.current;
      const tilePixels = TILE_SIZE * panStartRef.current.viewportZoom;
      const canvas = gridLayerRef.current;
      const visibleTilesX = canvas ? canvas.width / tilePixels : 10;
      const visibleTilesY = canvas ? canvas.height / tilePixels : 10;
      const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTilesX);
      const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTilesY);

      const newX = Math.max(0, Math.min(maxOffsetX, panStartRef.current.viewportX - dx / tilePixels));
      const newY = Math.max(0, Math.min(maxOffsetY, panStartRef.current.viewportY - dy / tilePixels));
      const tempViewport = { x: newX, y: newY, zoom: panStartRef.current.viewportZoom };

      // Progressive render: redraw static + anim layers with temp viewport
      // Skip overlay + grid (UI elements okay to lag 1 frame)
      drawStaticLayer(tempViewport);
      drawAnimLayer(tempViewport);
    });
  }, [drawStaticLayer, drawAnimLayer]);
  ```

  **Step 9: Store `viewportZoom` in panStartRef.** Update the `panStartRef` type and its assignment in `handleMouseDown`:
  Change the type to include `viewportZoom`:
  ```typescript
  const panStartRef = useRef<{ mouseX: number; mouseY: number; viewportX: number; viewportY: number; viewportZoom: number } | null>(null);
  ```
  In `handleMouseDown`, add `viewportZoom: viewport.zoom` to the panStartRef assignment.

  **Step 10: Wire RAF into pan mousemove.** In `handleMouseMove`, inside the `isDragging && panStartRef.current` branch (currently lines 927-936), AFTER applying CSS transforms and BEFORE the `return`, add:
  ```typescript
  panDeltaRef.current = { dx, dy };
  requestProgressiveRender();
  ```
  The CSS transform still provides instant feedback. The RAF schedules a canvas re-render for the next frame.

  **Step 11: Add RAF cleanup on unmount.** Add a useEffect at the end of the component (near the other cleanup effects):
  ```typescript
  useEffect(() => {
    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, []);
  ```

  **Key constraints:**
  - Do NOT add `viewport` to the RAF callback's dependency closure. The RAF reads from `panStartRef.current` and `panDeltaRef.current` (refs, not state) to avoid stale closures.
  - Keep the existing useEffect render triggers exactly as-is. They fire when Zustand viewport changes (on mouseup commit). The RAF progressive render is an additional rendering path that runs during drag only.
  - The draw function dependencies in useCallback should NOT change — `viewport` remains in their dependency arrays since the Zustand viewport is the default when no override is passed.
  </action>
  <verify>
  Run `npm run typecheck` — zero TypeScript errors.
  Grep for `requestProgressiveRender` — should appear in the `handleMouseMove` pan branch and be defined as a useCallback.
  Grep for `overrideViewport` — should appear in `drawStaticLayer`, `drawAnimLayer`, `drawGridLayer`, `drawOverlayLayer`, `getVisibleTiles`, and `tileToScreen` function signatures.
  Grep for `rafIdRef` — should appear in refs, `requestProgressiveRender`, mouseup cleanup, mouseleave cleanup, and unmount cleanup.
  Verify existing no-arg draw calls still exist in useEffect triggers (lines ~652-666) — they must be unchanged.
  </verify>
  <done>
  Draw functions accept optional viewport override parameter. RAF-debounced progressive render fires during pan drag, updating static and anim layers with temporary viewport. Existing render pipeline unchanged (useEffect triggers, resize observer use default Zustand viewport). RAF cleanup on unmount prevents stale callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scrollbar real-time sync during drag and snap-back prevention on mouseup</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
  This task makes scrollbars track pan position during drag and eliminates the visible snap-back when releasing the mouse.

  **Step 1: Update `getScrollMetrics` to use temporary viewport during drag.**
  The function currently reads `viewport` from Zustand (line 693). During pan drag, viewport hasn't committed yet, so scrollbars show the pre-drag position.

  Modify `getScrollMetrics` to compute an effective viewport when pan is active:
  ```typescript
  const getScrollMetrics = useCallback(() => {
    const canvas = gridLayerRef.current;
    if (!canvas) return { thumbWidth: 20, thumbHeight: 20, thumbLeft: 10, thumbTop: 10 };

    // During pan drag, compute temporary viewport from panStartRef + panDeltaRef
    let effectiveViewport = viewport;
    if (isDragging && panStartRef.current && panDeltaRef.current) {
      const { dx, dy } = panDeltaRef.current;
      const tilePixels = TILE_SIZE * panStartRef.current.viewportZoom;
      const vTilesX = canvas.width / tilePixels;
      const vTilesY = canvas.height / tilePixels;
      const maxOX = Math.max(0, MAP_WIDTH - vTilesX);
      const maxOY = Math.max(0, MAP_HEIGHT - vTilesY);
      effectiveViewport = {
        x: Math.max(0, Math.min(maxOX, panStartRef.current.viewportX - dx / tilePixels)),
        y: Math.max(0, Math.min(maxOY, panStartRef.current.viewportY - dy / tilePixels)),
        zoom: panStartRef.current.viewportZoom
      };
    }

    const tilePixels = TILE_SIZE * effectiveViewport.zoom;
    // ... rest uses effectiveViewport.x, effectiveViewport.y, effectiveViewport.zoom instead of viewport.*
  ```
  Replace all `viewport.x`, `viewport.y`, `viewport.zoom` references inside `getScrollMetrics` with `effectiveViewport.x`, `effectiveViewport.y`, `effectiveViewport.zoom`.

  Add `isDragging` to the `getScrollMetrics` useCallback dependency array.

  **Step 2: Force scrollbar re-render during drag via state update.**
  The RAF callback in `requestProgressiveRender` already runs during drag. After the canvas redraws, we need React to re-render the scrollbar JSX with updated metrics. Since `getScrollMetrics` now reads from `panDeltaRef` when `isDragging` is true, we need a state trigger.

  Add a `panRenderCount` state counter to force re-renders:
  ```typescript
  const [panRenderCount, setPanRenderCount] = useState(0);
  ```

  In the RAF callback inside `requestProgressiveRender`, after the `drawAnimLayer(tempViewport)` call, add:
  ```typescript
  setPanRenderCount(c => c + 1);
  ```

  This triggers a React re-render. On re-render, `getScrollMetrics()` is called (line ~1345), reads `panDeltaRef.current` (fresh ref value), and returns updated thumb positions. The scrollbar JSX re-renders with correct positions.

  **Step 3: Fix commitPan to render canvas BEFORE clearing CSS transforms.**
  Currently `commitPan` (lines 139-162) clears CSS transforms first, then calls `setViewport()` which triggers React re-render and draw functions asynchronously. This causes a 1-frame snap-back.

  Rewrite `commitPan` to:
  1. Cancel any pending RAF
  2. Calculate final viewport (already does this)
  3. Render all 4 layers with the final viewport (synchronous canvas draw)
  4. Clear CSS transforms (canvas is now correct underneath)
  5. Commit to Zustand (future re-renders use committed viewport)
  6. Clear refs

  ```typescript
  const commitPan = useCallback((clientX: number, clientY: number) => {
    if (!panStartRef.current) return;

    // Cancel pending RAF render
    if (rafIdRef.current !== null) {
      cancelAnimationFrame(rafIdRef.current);
      rafIdRef.current = null;
    }

    const tilePixels = TILE_SIZE * panStartRef.current.viewportZoom;
    const dx = clientX - panStartRef.current.mouseX;
    const dy = clientY - panStartRef.current.mouseY;

    const canvas = gridLayerRef.current;
    const visibleTilesX = canvas ? canvas.width / tilePixels : 10;
    const visibleTilesY = canvas ? canvas.height / tilePixels : 10;
    const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTilesX);
    const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTilesY);

    const newX = Math.max(0, Math.min(maxOffsetX, panStartRef.current.viewportX - dx / tilePixels));
    const newY = Math.max(0, Math.min(maxOffsetY, panStartRef.current.viewportY - dy / tilePixels));
    const finalViewport = { x: newX, y: newY, zoom: panStartRef.current.viewportZoom };

    // Render canvas with final viewport BEFORE clearing transforms (prevents snap-back)
    drawStaticLayer(finalViewport);
    drawAnimLayer(finalViewport);
    drawOverlayLayer(finalViewport);
    drawGridLayer(finalViewport);

    // Now safe to clear CSS transforms — canvas shows correct content
    if (staticLayerRef.current) staticLayerRef.current.style.transform = '';
    if (animLayerRef.current) animLayerRef.current.style.transform = '';
    if (overlayLayerRef.current) overlayLayerRef.current.style.transform = '';
    if (gridLayerRef.current) gridLayerRef.current.style.transform = '';

    // Commit to Zustand (triggers React re-render with committed viewport)
    setViewport({ x: newX, y: newY });
    panStartRef.current = null;
    panDeltaRef.current = null;
  }, [viewport.zoom, setViewport, drawStaticLayer, drawAnimLayer, drawOverlayLayer, drawGridLayer]);
  ```

  **IMPORTANT**: `commitPan` now needs `drawStaticLayer`, `drawAnimLayer`, `drawOverlayLayer`, `drawGridLayer` in its useCallback dependency array. The existing `viewport.zoom` dependency can stay (it's used as a fallback) but `panStartRef.current.viewportZoom` is what's actually used.

  **Step 4: Fix `handleMouseLeave` to also cancel RAF and clear panDeltaRef.**
  In the `handleMouseLeave` function, inside the `isDragging && panStartRef.current` branch, the `commitPan` call already handles this (since we updated `commitPan` in Step 3). No additional changes needed beyond what `commitPan` does.

  **Step 5: Clean up `panDeltaRef` on drag end.**
  In `handleMouseUp`, after the `commitPan(e.clientX, e.clientY)` call, `panDeltaRef.current = null` is already set inside the updated `commitPan`. Verify this happens. Also ensure the `setIsDragging(false)` on line 986 happens AFTER `commitPan` (it already does).

  **Key constraints:**
  - `panRenderCount` is ONLY used as a re-render trigger. It is not read anywhere. Do NOT add it to any useCallback dependencies.
  - `getScrollMetrics` uses refs (`panStartRef`, `panDeltaRef`) which don't need to be in dependencies. Only `isDragging` (state) is added to deps.
  - Scrollbar thumb positions will update smoothly because: mousemove → CSS transform + panDeltaRef update → RAF fires → canvas redraws + setPanRenderCount → React re-render → getScrollMetrics reads fresh panDeltaRef → scrollbar JSX updates.
  </action>
  <verify>
  Run `npm run typecheck` — zero TypeScript errors.
  Grep for `effectiveViewport` in `getScrollMetrics` — should be present.
  Grep for `panRenderCount` — should appear in useState declaration and in RAF callback.
  Grep for `cancelAnimationFrame` inside `commitPan` — should be present (RAF cleanup before commit).
  Verify `commitPan` calls draw functions with `finalViewport` parameter before clearing CSS transforms.
  Verify `getScrollMetrics` dependency array includes `isDragging`.
  </verify>
  <done>
  Scrollbar thumb positions update in real-time during pan drag by reading temporary viewport from refs. Mouseup renders canvas with final viewport before clearing CSS transforms, eliminating visible snap-back. RAF is properly cancelled on mouseup/mouseleave. Complete pan-scroll-render pipeline: mousemove → CSS transform (instant) → RAF → canvas redraw + scrollbar update → mouseup → final render → clear transforms → Zustand commit.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. All draw functions (`drawStaticLayer`, `drawAnimLayer`, `drawOverlayLayer`, `drawGridLayer`) accept optional `ViewportOverride` parameter
3. `getVisibleTiles` and `tileToScreen` accept optional `ViewportOverride` parameter
4. `requestProgressiveRender` exists and is called from mousemove pan branch
5. `rafIdRef` is properly initialized, used, and cleaned up (unmount, commitPan)
6. `panDeltaRef` stores pixel delta during drag and is cleared on commit
7. `getScrollMetrics` computes effective viewport from refs during drag
8. `commitPan` renders all 4 layers BEFORE clearing CSS transforms
9. Existing render pipeline (useEffect triggers, resize observer) unchanged — no-arg calls still work
10. No Zustand viewport commits during drag (only on mouseup via commitPan)
</verification>

<success_criteria>
- Pan drag shows tiles updating during drag (not frozen until release)
- CSS transform provides instant feedback (no perceptible delay)
- Scrollbar thumbs move in real-time as map is panned
- No snap-back artifact when releasing mouse after pan
- Viewport commits to Zustand only on mouse release
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/48-real-time-pan-rendering/48-01-SUMMARY.md`
</output>
