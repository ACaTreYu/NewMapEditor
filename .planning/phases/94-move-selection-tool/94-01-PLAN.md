---
phase: 94-move-selection-tool
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking and dragging inside an active selection moves the marquee border to follow the cursor without modifying any tiles"
    - "The cursor changes to a move cursor when hovering inside an active selection with the SELECT tool active"
    - "Pressing Escape during a move drag reverts the marquee to its original position"
    - "After a completed move, cut/copy/delete operations act on the new marquee position"
    - "Arrow keys nudge the marquee 1 tile per press (10 tiles with Shift held) while a selection is active"
    - "Moving the selection off-canvas (mouseLeave) commits the current position rather than reverting"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "selectionMoveRef, isInsideSelection helper, mouse handler branching, drawUiLayer move preview, Escape revert, arrow key nudge, cursor affordance"
      contains: "selectionMoveRef"
  key_links:
    - from: "selectionMoveRef (transient drag state)"
      to: "drawUiLayer activeSelection ternary"
      via: "selectionMoveRef.current.active takes priority in activeSelection resolution"
      pattern: "selectionMoveRef\\.current\\.active"
    - from: "handleMouseDown SELECT branch"
      to: "selectionMoveRef"
      via: "isInsideSelection gate before existing clearSelection branch"
      pattern: "isInsideSelection"
    - from: "handleMouseUp"
      to: "setSelection"
      via: "commits selectionMoveRef final coords to Zustand on mouseup"
      pattern: "selectionMoveRef\\.current\\.active"
    - from: "Arrow key useEffect"
      to: "setSelection"
      via: "direct Zustand update on ArrowLeft/Right/Up/Down"
      pattern: "ArrowLeft.*ArrowRight.*ArrowUp.*ArrowDown"
---

<objective>
Add move-selection capability to the SELECT tool so users can reposition an existing selection marquee by clicking and dragging inside it. Also add arrow-key nudging for precise 1-tile (or 10-tile with Shift) repositioning.

Purpose: Selection repositioning is a fundamental image-editor workflow. Without it, users must clear and redraw selections to adjust position, which is tedious. This completes the selection tool's core UX.

Output: Updated MapCanvas.tsx with selectionMoveRef, mouse handler branching, drawUiLayer preview, Escape revert, arrow key nudging, and cursor affordance.

**SCOPE BOUNDARY:** This is marquee-reposition ONLY. No tiles are read or written during the drag. Tile-move-with-selection is explicitly deferred to v2+.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-move-selection-tool/94-RESEARCH.md
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add selectionMoveRef, isInsideSelection helper, and wire mouse handlers + drawUiLayer + Escape</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
**1. Add `isInsideSelection` helper function** (before the component, after imports):

```typescript
function isInsideSelection(tileX: number, tileY: number, sel: { startX: number; startY: number; endX: number; endY: number }): boolean {
  const minX = Math.min(sel.startX, sel.endX);
  const minY = Math.min(sel.startY, sel.endY);
  const maxX = Math.max(sel.startX, sel.endX);
  const maxY = Math.max(sel.startY, sel.endY);
  return tileX >= minX && tileX <= maxX && tileY >= minY && tileY <= maxY;
}
```

**2. Add `selectionMoveRef`** alongside `selectionDragRef` (near line 60):

```typescript
const selectionMoveRef = useRef<{
  active: boolean;
  origStartX: number; origStartY: number; origEndX: number; origEndY: number;
  startX: number; startY: number; endX: number; endY: number;
  grabOffsetX: number; grabOffsetY: number;
}>({
  active: false,
  origStartX: 0, origStartY: 0, origEndX: 0, origEndY: 0,
  startX: 0, startY: 0, endX: 0, endY: 0,
  grabOffsetX: 0, grabOffsetY: 0
});
```

**3. Modify `handleMouseDown` SELECT branch** (currently near line 1875). Replace the simple `clearSelection() + start drag` with a two-branch structure:

```typescript
} else if (currentTool === ToolType.SELECT) {
  if (selection.active && isInsideSelection(x, y, selection)) {
    // Start move-drag: record original position + grab offset
    const selMinX = Math.min(selection.startX, selection.endX);
    const selMinY = Math.min(selection.startY, selection.endY);
    const selMaxX = Math.max(selection.startX, selection.endX);
    const selMaxY = Math.max(selection.startY, selection.endY);
    selectionMoveRef.current = {
      active: true,
      origStartX: selMinX, origStartY: selMinY, origEndX: selMaxX, origEndY: selMaxY,
      startX: selMinX, startY: selMinY, endX: selMaxX, endY: selMaxY,
      grabOffsetX: x - selMinX, grabOffsetY: y - selMinY
    };
    requestUiRedraw();
  } else {
    // Start new selection drag (existing behavior)
    clearSelection();
    selectionDragRef.current = { active: true, startX: x, startY: y, endX: x, endY: y };
    requestUiRedraw();
  }
}
```

**4. Add `selectionMoveRef` branch in `handleMouseMove`** — insert BEFORE the existing `selectionDragRef.current.active` branch (near line 2044):

```typescript
} else if (selectionMoveRef.current.active) {
  const move = selectionMoveRef.current;
  const w = move.origEndX - move.origStartX;
  const h = move.origEndY - move.origStartY;
  const newMinX = Math.max(0, Math.min(MAP_WIDTH - 1 - w, x - move.grabOffsetX));
  const newMinY = Math.max(0, Math.min(MAP_HEIGHT - 1 - h, y - move.grabOffsetY));
  if (newMinX !== move.startX || newMinY !== move.startY) {
    selectionMoveRef.current = {
      ...move,
      startX: newMinX, startY: newMinY,
      endX: newMinX + w, endY: newMinY + h
    };
    requestUiRedraw();
  }
}
```

**5. Add cursor affordance in `handleMouseMove`** — after computing tile (x, y) and updating `cursorTileRef`, before the isDragging check (near line 1910), add cursor style logic:

```typescript
// Move-selection cursor affordance
const canvas = uiLayerRef.current;
if (canvas) {
  if (selectionMoveRef.current.active) {
    canvas.style.cursor = 'grabbing';
  } else if (currentTool === ToolType.SELECT && selection.active && isInsideSelection(x, y, selection)) {
    canvas.style.cursor = 'move';
  } else if (!isDragging) {
    canvas.style.cursor = '';
  }
}
```

**6. Add `selectionMoveRef` commit in `handleMouseUp`** — insert BEFORE the existing `selectionDragRef.current.active` block (near line 2069):

```typescript
if (selectionMoveRef.current.active) {
  const move = selectionMoveRef.current;
  setSelection({ startX: move.startX, startY: move.startY, endX: move.endX, endY: move.endY, active: true });
  selectionMoveRef.current = {
    active: false,
    origStartX: 0, origStartY: 0, origEndX: 0, origEndY: 0,
    startX: 0, startY: 0, endX: 0, endY: 0,
    grabOffsetX: 0, grabOffsetY: 0
  };
  // Reset cursor
  const canvas = uiLayerRef.current;
  if (canvas) canvas.style.cursor = '';
  requestUiRedraw();
}
```

**7. Add `selectionMoveRef` cleanup in `handleMouseLeave`** — insert BEFORE the existing `selectionDragRef.current.active` check (near line 2203). Decision: commit current position on leave (not revert), matching mouseup behavior:

```typescript
if (selectionMoveRef.current.active) {
  const move = selectionMoveRef.current;
  setSelection({ startX: move.startX, startY: move.startY, endX: move.endX, endY: move.endY, active: true });
  selectionMoveRef.current = {
    active: false,
    origStartX: 0, origStartY: 0, origEndX: 0, origEndY: 0,
    startX: 0, startY: 0, endX: 0, endY: 0,
    grabOffsetX: 0, grabOffsetY: 0
  };
  requestUiRedraw();
}
```

**8. Update `drawUiLayer` activeSelection ternary** (near line 844). Add `selectionMoveRef.current.active` as the highest-priority source:

```typescript
const activeSelection = selectionMoveRef.current.active
  ? selectionMoveRef.current
  : selectionDragRef.current.active
    ? selectionDragRef.current
    : selection.active
      ? selection
      : null;
```

**9. Add Escape cancellation for move drag** in the permanent Escape handler (near line 2524, BEFORE the existing `selectionDragRef.current.active` block):

```typescript
// Cancel selection move drag (revert to original position)
if (selectionMoveRef.current.active) {
  e.preventDefault();
  const move = selectionMoveRef.current;
  setSelection({
    startX: move.origStartX, startY: move.origStartY,
    endX: move.origEndX, endY: move.origEndY, active: true
  });
  selectionMoveRef.current = {
    active: false,
    origStartX: 0, origStartY: 0, origEndX: 0, origEndY: 0,
    startX: 0, startY: 0, endX: 0, endY: 0,
    grabOffsetX: 0, grabOffsetY: 0
  };
  // Reset cursor
  const canvas = uiLayerRef.current;
  if (canvas) canvas.style.cursor = '';
  requestUiRedraw();
}
```
  </action>
  <verify>
1. Run `npm run typecheck` — no type errors
2. Run `npm run electron:dev` — app launches without console errors
3. Manual test: Select a region with the SELECT tool, then click inside the selection and drag — marquee follows cursor without tile changes
4. Manual test: Press Escape during move drag — marquee snaps back to original position
5. Manual test: Hover inside selection with SELECT tool — cursor shows `move` icon
6. Manual test: Drag selection to edge of map — selection clamps to map bounds
7. Manual test: Drag off canvas edge — selection stays at last dragged position (commits, does not revert)
  </verify>
  <done>
- selectionMoveRef tracks transient move-drag state
- mousedown inside active selection starts move-drag instead of new selection
- mousemove updates selectionMoveRef with clamped position
- mouseup commits final position to Zustand via setSelection
- mouseLeave commits current position (same as mouseup)
- drawUiLayer renders live move preview via selectionMoveRef priority in activeSelection ternary
- Escape reverts to original position stored in origStartX/Y/origEndX/Y
- Cursor shows `move` on hover inside selection, `grabbing` during active drag
  </done>
</task>

<task type="auto">
  <name>Task 2: Add arrow-key nudge for selection repositioning</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
Add a new `useEffect` that listens for arrow keys while `selection.active && currentTool === ToolType.SELECT`. Place it near the other Escape key useEffect blocks (around line 2476).

```typescript
// Arrow key nudging for active selection (SLCT-01)
useEffect(() => {
  if (!selection.active || currentTool !== ToolType.SELECT) return;

  const handleArrowKey = (e: KeyboardEvent) => {
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
    // Don't nudge during active move drag
    if (selectionMoveRef.current.active) return;

    const step = e.shiftKey ? 10 : 1;
    const minX = Math.min(selection.startX, selection.endX);
    const minY = Math.min(selection.startY, selection.endY);
    const maxX = Math.max(selection.startX, selection.endX);
    const maxY = Math.max(selection.startY, selection.endY);
    const w = maxX - minX;
    const h = maxY - minY;

    let dx = 0, dy = 0;
    if (e.key === 'ArrowLeft')  dx = -step;
    if (e.key === 'ArrowRight') dx =  step;
    if (e.key === 'ArrowUp')    dy = -step;
    if (e.key === 'ArrowDown')  dy =  step;
    if (dx === 0 && dy === 0) return;

    e.preventDefault();
    const newMinX = Math.max(0, Math.min(MAP_WIDTH - 1 - w, minX + dx));
    const newMinY = Math.max(0, Math.min(MAP_HEIGHT - 1 - h, minY + dy));
    setSelection({ startX: newMinX, startY: newMinY, endX: newMinX + w, endY: newMinY + h, active: true });
  };

  window.addEventListener('keydown', handleArrowKey);
  return () => window.removeEventListener('keydown', handleArrowKey);
}, [selection, currentTool, setSelection]);
```

**Key implementation details:**
- The `selectionMoveRef.current.active` guard prevents arrow nudge from conflicting with an active mouse drag
- `e.shiftKey ? 10 : 1` gives precise (1-tile) or fast (10-tile) nudging
- Boundary clamping uses `MAP_WIDTH - 1 - w` to ensure the selection's bottom-right corner stays within the 256x256 map
- Input element guard prevents arrow keys from firing while user is typing in map name or other text fields
- `e.preventDefault()` stops the browser from scrolling or other default arrow key behavior
- `setSelection` directly updates Zustand (no ref needed — nudge is instantaneous, not a drag)
  </action>
  <verify>
1. Run `npm run typecheck` — no type errors
2. Manual test: Create a selection, press arrow keys — marquee moves 1 tile per press
3. Manual test: Hold Shift + arrow key — marquee moves 10 tiles per press
4. Manual test: Nudge selection to map edge — selection stops at boundary, does not go off-map
5. Manual test: Open map settings dialog, type in a text field, press arrow keys — no selection movement (input guard works)
6. Manual test: After arrow nudge, perform cut/copy — operations use the new nudged position
  </verify>
  <done>
- Arrow keys (Left/Right/Up/Down) nudge active selection by 1 tile
- Shift+Arrow nudges by 10 tiles
- Selection is clamped to 256x256 map boundaries
- Input elements are properly guarded
- No conflict with active move drag
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. All five success criteria from the phase definition are met:
   - SC1: Click-drag inside selection moves marquee without modifying tiles
   - SC2: Cursor changes to `move` when hovering inside active selection
   - SC3: Escape during move drag reverts to original position
   - SC4: After move, cut/copy/delete act on new position (setSelection updates Zustand, which all operations read)
   - SC5: Arrow keys nudge 1 tile (10 with Shift)
3. No tiles are ever read or written during move-drag (marquee-only operation)
4. Existing selection, pencil, line, rect, wall, ruler tools are unaffected
</verification>

<success_criteria>
- Selection move-drag works end-to-end: mousedown inside selection → mousemove updates live preview → mouseup commits new position
- Escape during move-drag reverts to original position
- Arrow key nudging works with 1-tile and 10-tile (Shift) increments, clamped to map boundaries
- Cursor affordance: `move` on hover inside selection, `grabbing` during active drag
- mouseLeave during drag commits current position (does not revert)
- No regressions in existing tool behaviors
- `npm run typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/94-move-selection-tool/94-01-SUMMARY.md`
</output>
