---
phase: 82-settings-format-compliance-bug-fixes
plan: 02
type: execute
wave: 2
depends_on: ["82-01"]
files_modified:
  - src/components/MapSettingsDialog/MapSettingsDialog.tsx
autonomous: true

must_haves:
  truths:
    - "User loads any map and sees dropdown values (Very Low through Very High) match the extended setting slider values"
    - "User adjusts Special Damage dropdown and Laser Damage slider does NOT change"
    - "User adjusts Laser Damage dropdown and Special Damage slider does NOT change"
    - "User edits settings, saves map, reloads, and all values are preserved across all tabs"
    - "User loads map with custom extended settings (e.g., LaserDamage=50) and dropdown shows nearest preset (Normal)"
  artifacts:
    - path: "src/components/MapSettingsDialog/MapSettingsDialog.tsx"
      provides: "Reverse mapping from extended settings to dropdown indices on dialog open"
      contains: "findClosestIndex"
  key_links:
    - from: "src/components/MapSettingsDialog/MapSettingsDialog.tsx:open()"
      to: "LASER_DAMAGE_VALUES, SPECIAL_DAMAGE_VALUES, RECHARGE_RATE_VALUES"
      via: "findClosestIndex reverse mapping on dialog open"
      pattern: "findClosestIndex"
    - from: "src/components/MapSettingsDialog/MapSettingsDialog.tsx:open()"
      to: "headerFields state"
      via: "setHeaderFields with computed dropdown indices from extended settings"
      pattern: "setHeaderFields.*laserDamage.*findClosestIndex"
---

<objective>
Fix dropdown-slider synchronization bugs so that loading any map shows correct dropdown selections that match the extended setting values, and fix the Special/Laser Damage crossfire bug.

Purpose: When a user loads a map, the Weapons tab dropdowns (Laser Damage, Special Damage, Recharge Rate) must reflect the actual extended setting values, not stale binary header fields. Additionally, changing one dropdown must not affect another.

Output: MapSettingsDialog.tsx with bidirectional dropdown-slider sync and isolated onChange handlers.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/82-settings-format-compliance-bug-fixes/82-RESEARCH.md
@.planning/phases/82-settings-format-compliance-bug-fixes/82-01-SUMMARY.md
@src/components/MapSettingsDialog/MapSettingsDialog.tsx
@src/core/map/GameSettings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reverse mapping from extended settings to dropdown indices</name>
  <files>src/components/MapSettingsDialog/MapSettingsDialog.tsx</files>
  <action>
Add a `findClosestIndex` helper function near the top of the file (after the value arrays on lines 172-174):

```typescript
/**
 * Find the dropdown index (0-4) whose preset value is closest to the given
 * extended setting value. Handles custom values by snapping to nearest preset.
 */
function findClosestIndex(value: number, valueArray: number[]): number {
  let closestIdx = 0;
  let minDiff = Math.abs(value - valueArray[0]);
  for (let i = 1; i < valueArray.length; i++) {
    const diff = Math.abs(value - valueArray[i]);
    if (diff < minDiff) {
      minDiff = diff;
      closestIdx = i;
    }
  }
  return closestIdx;
}
```

Then modify the `open()` handler (inside `useImperativeHandle`) to compute dropdown indices from the MERGED extended settings instead of using stale `map.header` values:

**Current code (lines 222-236):**
```typescript
setHeaderFields({
  ...
  laserDamage: map.header.laserDamage,
  specialDamage: map.header.specialDamage,
  rechargeRate: map.header.rechargeRate,
  ...
});
```

**Replace with:**
```typescript
// Compute dropdown indices from merged extended settings (not stale header values)
const laserDamageValue = merged['LaserDamage'] ?? 27;
const specialDamageValue = merged['MissileDamage'] ?? 102;
const rechargeRateValue = merged['MissileRecharge'] ?? 945;

setHeaderFields({
  maxPlayers: map.header.maxPlayers,
  numTeams: map.header.numTeams,
  objective: map.header.objective,
  laserDamage: findClosestIndex(laserDamageValue, LASER_DAMAGE_VALUES),
  specialDamage: findClosestIndex(specialDamageValue, SPECIAL_DAMAGE_VALUES),
  rechargeRate: findClosestIndex(rechargeRateValue, RECHARGE_RATE_VALUES),
  holdingTime: map.header.holdingTime,
  missilesEnabled: map.header.missilesEnabled,
  bombsEnabled: map.header.bombsEnabled,
  bounciesEnabled: map.header.bounciesEnabled,
  maxSimulPowerups: map.header.maxSimulPowerups,
  powerupCount: map.header.powerupCount,
  switchCount: map.header.switchCount
});
```

This ensures that when a map is loaded with extended settings like LaserDamage=54, the dropdown correctly shows "High" (index 3) instead of whatever stale value was in the binary header.

Note: The `merged` variable is already computed on line 215 and contains the correct values. Use it AFTER the `setLocalSettings(merged)` call but before `setHeaderFields`.
  </action>
  <verify>
Run `npm run typecheck`. Then test manually: open a map that has custom extended settings in its description, open Settings dialog, verify Weapons tab dropdowns show values matching the slider values.
  </verify>
  <done>
Dialog open() computes dropdown indices from extended settings via findClosestIndex, so dropdowns always reflect the actual setting values on load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit and fix Special/Laser Damage crossfire isolation</name>
  <files>src/components/MapSettingsDialog/MapSettingsDialog.tsx</files>
  <action>
Audit the three dropdown onChange handlers (Laser Damage, Special Damage, Recharge Rate) on lines 511-535 for proper isolation.

**Current handlers:**
```typescript
// Laser Damage (line 511-515)
onChange={(val) => {
  setHeaderFields(prev => ({ ...prev, laserDamage: val }));
  updateSetting('LaserDamage', LASER_DAMAGE_VALUES[val] ?? 27);
  setIsDirty(true);
}}

// Special Damage (line 521-525)
onChange={(val) => {
  setHeaderFields(prev => ({ ...prev, specialDamage: val }));
  updateSetting('MissileDamage', SPECIAL_DAMAGE_VALUES[val] ?? 102);
  setIsDirty(true);
}}

// Recharge Rate (line 531-535)
onChange={(val) => {
  setHeaderFields(prev => ({ ...prev, rechargeRate: val }));
  updateSetting('MissileRecharge', RECHARGE_RATE_VALUES[val] ?? 945);
  setIsDirty(true);
}}
```

These look correctly isolated - each uses functional `prev =>` setState and updates ONLY its own field. The crossfire bug (SBUG-02) is likely caused by the stale initial state from `open()` (fixed in Task 1), not from the onChange handlers themselves. When the dialog opens with stale dropdown indices, changing one dropdown can cause a re-render that appears to "change" the other because both start with wrong values.

**Verify:**
1. Confirm each onChange handler touches ONLY its corresponding headerField key
2. Confirm each updateSetting call references the correct extended setting key:
   - Laser Damage -> 'LaserDamage' (correct)
   - Special Damage -> 'MissileDamage' (correct - "Special Damage" maps to missile damage in AC)
   - Recharge Rate -> 'MissileRecharge' (correct)
3. Confirm `setIsDirty(true)` is called (it is) but does NOT trigger extra re-renders of the dropdown values

If the handlers are already correct (which they appear to be), add a code comment above each handler block explaining the mapping:
```typescript
// Laser Damage dropdown (0-4) maps to LaserDamage extended setting
// Special Damage dropdown (0-4) maps to MissileDamage extended setting
// Recharge Rate dropdown (0-4) maps to MissileRecharge extended setting (inverted: lower = faster)
```

Also verify that `updateSetting` (line 243) uses functional setState:
```typescript
const updateSetting = (key: string, value: number) => {
  setLocalSettings(prev => ({ ...prev, [key]: value }));
  setIsDirty(true);
};
```
This is correct - functional setState prevents stale closures.

**Additional: Sync all related extended settings when dropdown changes.**
When user changes "Laser Damage" dropdown, it currently ONLY updates LaserDamage. But the dropdown conceptually represents a "damage level" that in SEdit also affects other related settings. For this editor, we keep it simple: each dropdown maps to exactly ONE extended setting. Document this in a comment.
  </action>
  <verify>
Run `npm run typecheck`. Test manually: open Settings, go to Weapons tab, change Laser Damage dropdown from Normal to High, verify ONLY the LaserDamage slider updates (not MissileDamage). Then change Special Damage dropdown, verify ONLY MissileDamage slider updates.
  </verify>
  <done>
Dropdown onChange handlers are verified as properly isolated. Each dropdown updates only its corresponding headerField and extended setting. The crossfire bug is resolved by the correct initial state from Task 1's reverse mapping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Round-trip settings preservation test</name>
  <files>src/components/MapSettingsDialog/MapSettingsDialog.tsx</files>
  <action>
Perform a comprehensive audit of the settings round-trip pipeline to ensure no values are lost or corrupted during save -> reload:

**Pipeline:** Dialog Apply -> buildDescription() -> store description + extendedSettings -> MapParser saves to file -> MapParser loads from file -> Dialog open() -> parseDescription() -> merge -> display

**Check 1: buildDescription includes ALL 53 settings.**
`serializeSettings` iterates `GAME_SETTINGS` and uses `settings[key] ?? setting.default`. This means even settings the user hasn't touched get serialized with their default values. Confirm this is intentional (it is - ensures complete round-trip).

**Check 2: parseSettings handles all value types.**
Verify parseInt handles all settings correctly. All settings are integers, so `parseInt(valueStr, 10)` is correct. Format=1.1 is correctly filtered (it's a float, handled by the unrecognized filter on line 71).

**Check 3: extendedSettings merge priority on reload.**
Line 215: `{ ...getDefaultSettings(), ...settings, ...map.header.extendedSettings }`
- First load: `map.header.extendedSettings` is `{}` (from MapParser), so description parsing wins
- After Apply: `map.header.extendedSettings` has full values from localSettings, so it wins on next open

This means: after a user Applies settings, the extendedSettings in the store will have values from localSettings. On next dialog open, these override parsed description values. This is correct because Apply writes BOTH description (via buildDescription) AND extendedSettings to the store.

**BUT THERE IS A SUBTLE BUG:** If the user opens a map file (not via dialog Apply), MapParser sets `extendedSettings: {}`. Then on dialog open, the merge is `defaults + parsed_description + {}`. The empty object doesn't override anything, so parsed description values win. This is correct.

However, after Apply, extendedSettings has ALL 53 values. On next open, these override description parsing. If the description was somehow modified externally (unlikely in this editor), the store extendedSettings would win. This is acceptable behavior.

**Check 4: Verify SwitchWin default logic.**
Lines 217-219: If SwitchWin is 0 and switchCount > 0, SwitchWin defaults to switchCount. This is a reasonable heuristic for new maps with switches but no explicit SwitchWin setting.

**No code changes needed if all checks pass.** If any issues found, fix them. Add a brief comment at the top of `open()` documenting the merge priority: `// Merge priority: defaults < description parsed settings < stored extendedSettings`
  </action>
  <verify>
Run `npm run typecheck`. Run `npm run electron:dev`. Test full round-trip: create new map, open Settings, change several values across multiple tabs (Weapons, Game Rules, Flagger), click OK, save map (Ctrl+S), close map, reopen same map, open Settings, verify ALL changed values are preserved.
  </verify>
  <done>
Settings round-trip is verified: all 53 settings survive save -> reload -> display cycle. Merge priority is documented. No values are lost or corrupted.
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- Open map with known extended settings -> dropdowns match slider values
- Change Laser Damage dropdown -> only LaserDamage slider moves
- Change Special Damage dropdown -> only MissileDamage slider moves
- Edit settings across all 6 tabs -> Apply -> reopen dialog -> all values preserved
- Save map -> reopen map -> open Settings -> all values preserved
- New map defaults: LaserDamage slider shows 27, dropdown shows "Normal" (index 2)
- Load pre-v1.0.4 map (no Format=1.1 in description) -> settings load correctly
</verification>

<success_criteria>
1. Dropdowns and sliders are synchronized on load for all maps (SBUG-01, SBUG-04)
2. Special Damage and Laser Damage are independently adjustable (SBUG-02)
3. Full round-trip: edit -> save -> reload preserves all 53 settings exactly
4. Custom extended setting values (e.g., LaserDamage=50) show nearest dropdown preset
</success_criteria>

<output>
After completion, create `.planning/phases/82-settings-format-compliance-bug-fixes/82-02-SUMMARY.md`
</output>
