---
phase: 53-decouple-pencil-drag
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/canvas/CanvasEngine.ts
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/ToolBar/ToolBar.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Pencil drag accumulates tiles in engine Map, zero Zustand updates until mouseup"
    - "Buffer patched and screen blitted imperatively on each mousemove during pencil drag"
    - "Single setTiles() batch commit + commitUndo() on mouseup — one React re-render per drag"
    - "Escape during pencil drag discards pending tiles and restores buffer from store"
    - "Undo (Ctrl+Z) blocked during active drag — both keyboard shortcut and menu action"
    - "Multi-tile stamp works during drag (loops paintTile per stamp tile)"
    - "Mouse leave during pencil drag commits pending tiles (same as mouseup)"
    - "Component unmount during drag calls cancelDrag() in cleanup"
  artifacts:
    - path: "src/core/canvas/CanvasEngine.ts"
      provides: "beginDrag, paintTile, commitDrag, cancelDrag, getIsDragActive methods"
      contains: "beginDrag"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Pencil mouse handlers wired to engine drag lifecycle"
      contains: "engineRef.current?.beginDrag"
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "Undo blocked during active drag"
      contains: "isDragActive"
    - path: "src/App.tsx"
      provides: "Menu undo blocked during active drag"
      contains: "isDragActive"
  key_links:
    - from: "MapCanvas.handleMouseDown"
      to: "CanvasEngine.beginDrag()"
      via: "engineRef.current?.beginDrag()"
      pattern: "engineRef\\.current\\?\\.beginDrag"
    - from: "MapCanvas.handleMouseMove"
      to: "CanvasEngine.paintTile()"
      via: "engineRef.current?.paintTile()"
      pattern: "engineRef\\.current\\?\\.paintTile"
    - from: "MapCanvas.handleMouseUp"
      to: "CanvasEngine.commitDrag()"
      via: "engineRef.current?.commitDrag()"
      pattern: "engineRef\\.current\\?\\.commitDrag"
    - from: "ToolBar keyboard handler"
      to: "CanvasEngine.getIsDragActive()"
      via: "exported isDragActive check function"
      pattern: "isDragActive"
---

<objective>
Zero React re-renders during pencil drag — accumulate tiles in engine Map ref, patch buffer imperatively on each mousemove, batch commit to Zustand on mouseup.

Purpose: This is the core payoff of v2.8: removing React from the painting hot path. During pencil drag, every mousemove currently calls setTile() which triggers a Zustand update, React re-render, and engine subscription callback. After this plan, mousemove patches the canvas buffer directly via the engine — zero state updates, zero re-renders until mouseup.

Output: CanvasEngine with drag lifecycle methods (beginDrag/paintTile/commitDrag/cancelDrag), MapCanvas pencil handlers rewired to use engine drag, undo blocked during drag in ToolBar and App.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/53-decouple-pencil-drag/53-RESEARCH.md
@.planning/phases/52-engine-subscribes-to-zustand/52-01-SUMMARY.md
@src/core/canvas/CanvasEngine.ts
@src/components/MapCanvas/MapCanvas.tsx
@src/components/ToolBar/ToolBar.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add drag lifecycle methods to CanvasEngine</name>
  <files>src/core/canvas/CanvasEngine.ts</files>
  <action>
Add four public methods and one private field to CanvasEngine class:

**Private field:**
- `private pendingTiles: Map<number, number> | null = null;` — Accumulates tile changes during drag. Key: `tileY * MAP_WIDTH + tileX`, Value: tile ID. Null when not dragging. Reused across drags (cleared, not recreated).

**Method 1: beginDrag()**
```typescript
beginDrag(): void {
  this.isDragActive = true;
  if (!this.pendingTiles) {
    this.pendingTiles = new Map();
  } else {
    this.pendingTiles.clear();
  }
}
```

**Method 2: paintTile(tileX, tileY, tile)**
- Guard: return false if `!this.isDragActive || !this.pendingTiles`
- Guard: return false if out of bounds (`tileX < 0 || tileX >= MAP_WIDTH || tileY < 0 || tileY >= MAP_HEIGHT`)
- Accumulate: `this.pendingTiles.set(tileY * MAP_WIDTH + tileX, tile)`
- Patch buffer: `this.patchTileBuffer(tileX, tileY, tile, this.animationFrame)`
- Update prevTiles snapshot: `if (this.prevTiles) this.prevTiles[tileY * MAP_WIDTH + tileX] = tile;` — This prevents the engine's map subscription from seeing these tiles as "changed" when Zustand commits later, avoiding a redundant full redraw.
- Blit to screen: get viewport from `useEditorStore.getState()` via `this.getViewport()`, call `this.blitToScreen(vp, this.screenCtx!.canvas.width, this.screenCtx!.canvas.height)`
- Return true on success

**Method 3: commitDrag()**
- Guard: return null if `!this.isDragActive || !this.pendingTiles`
- Convert Map to array: iterate `this.pendingTiles` entries, push `{ x: key % MAP_WIDTH, y: Math.floor(key / MAP_WIDTH), tile }` for each
- Set `this.isDragActive = false`
- Call `this.pendingTiles.clear()` (reuse Map for next drag)
- Return `tiles.length > 0 ? tiles : null`
- Return type: `Array<{ x: number; y: number; tile: number }> | null`

**Method 4: cancelDrag()**
- Guard: return if `!this.isDragActive`
- Set `this.isDragActive = false`
- Call `this.pendingTiles?.clear()`
- NOTE: Does NOT restore buffer — caller must trigger full buffer rebuild from store state

**Method 5: getIsDragActive()**
- Public getter: `return this.isDragActive;`
- Used by undo blocking (ToolBar, App) and escape handler

**Also update detach():**
- Add `this.cancelDrag();` as the FIRST line of detach() — resets drag state on unmount so subscriptions aren't permanently blocked.

**Naming note:** The existing `isDragActive` boolean field (line 37) stays as-is. The getter method must be named `getIsDragActive()` to avoid collision with the private boolean field name. Research code showed `isDragActive()` as method name, but that conflicts with the boolean field — use `getIsDragActive()` instead.
  </action>
  <verify>
Run `npm run typecheck` — should pass with no new errors.
Verify methods exist: grep for `beginDrag`, `paintTile`, `commitDrag`, `cancelDrag`, `getIsDragActive` in CanvasEngine.ts.
Verify `cancelDrag()` is called in `detach()`.
  </verify>
  <done>
CanvasEngine has beginDrag/paintTile/commitDrag/cancelDrag/getIsDragActive methods. pendingTiles Map accumulates tile changes. prevTiles snapshot updated on paintTile. detach() calls cancelDrag(). TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pencil drag to engine + undo blocking</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
    src/components/ToolBar/ToolBar.tsx
    src/App.tsx
  </files>
  <action>
**MapCanvas.tsx — Rewire pencil handleMouseDown (line ~883-887):**

Replace the current pencil branch:
```typescript
} else {
  // Pencil - start drag operation
  pushUndo();
  handleToolAction(x, y);
}
```

With engine drag lifecycle:
```typescript
} else if (currentTool === ToolType.PENCIL) {
  // Pencil - start engine drag operation
  pushUndo();
  engineRef.current?.beginDrag();
  // Paint first tile (single or multi-tile stamp)
  paintPencilTile(x, y);
} else if (currentTool === ToolType.PICKER) {
  // Picker tool action (no drag)
  handleToolAction(x, y);
}
```

**MapCanvas.tsx — Create paintPencilTile helper function** (add before handleMouseDown):

```typescript
// Paint pencil tile(s) via engine during drag — supports multi-tile stamps
const paintPencilTile = useCallback((x: number, y: number) => {
  const engine = engineRef.current;
  if (!engine) return;

  if (tileSelection.width === 1 && tileSelection.height === 1) {
    engine.paintTile(x, y, selectedTile);
  } else {
    // Multi-tile stamp: loop over selection, paint each tile
    for (let dy = 0; dy < tileSelection.height; dy++) {
      for (let dx = 0; dx < tileSelection.width; dx++) {
        const tileId = (tileSelection.startRow + dy) * 40 + (tileSelection.startCol + dx);
        if (tileId !== DEFAULT_TILE) {
          engine.paintTile(x + dx, y + dy, tileId);
        }
      }
    }
  }
}, [selectedTile, tileSelection]);
```

**MapCanvas.tsx — Rewire pencil handleMouseMove (line ~932-943):**

Replace the generic left-button drag handler (the `else if (e.buttons === 1 && !e.altKey)` block that calls `handleToolAction`):

The condition that excludes tools from the drag handler already excludes everything except PENCIL and FILL. FILL doesn't drag. So the remaining case is PENCIL only.

Replace:
```typescript
} else if (e.buttons === 1 && !e.altKey) {
  // Drawing with left button held (non-line tools)
  if (currentTool !== ToolType.WALL && currentTool !== ToolType.LINE &&
      currentTool !== ToolType.WALL_PENCIL && currentTool !== ToolType.WALL_RECT &&
      currentTool !== ToolType.FLAG && currentTool !== ToolType.FLAG_POLE &&
      currentTool !== ToolType.SPAWN && currentTool !== ToolType.SWITCH &&
      currentTool !== ToolType.WARP && currentTool !== ToolType.BUNKER &&
      currentTool !== ToolType.HOLDING_PEN && currentTool !== ToolType.BRIDGE &&
      currentTool !== ToolType.CONVEYOR && currentTool !== ToolType.SELECT) {
    handleToolAction(x, y);
  }
}
```

With:
```typescript
} else if (e.buttons === 1 && !e.altKey && currentTool === ToolType.PENCIL) {
  // Pencil drag: paint tile via engine (zero React re-renders)
  paintPencilTile(x, y);
}
```

This is simpler and more explicit — only PENCIL drags during mousemove. FILL is click-only (handled in mousedown). PICKER is click-only.

**MapCanvas.tsx — Rewire pencil handleMouseUp (line ~1015-1019):**

Replace the pencil commit block:
```typescript
if (!lineState.active && !rectDragState.active && !selectionDrag.active && !isDrawingWallPencil) {
  if (currentTool === ToolType.PENCIL) {
    commitUndo('Edit tiles');
  }
}
```

With engine drag commit:
```typescript
if (currentTool === ToolType.PENCIL && engineRef.current?.getIsDragActive()) {
  const tiles = engineRef.current.commitDrag();
  if (tiles && tiles.length > 0) {
    setTiles(tiles);
    commitUndo('Edit tiles');
  } else {
    commitUndo('Edit tiles'); // Empty undo snapshot, will be discarded
  }
}
```

**MapCanvas.tsx — Rewire pencil handleMouseLeave (line ~1039-1042):**

Replace:
```typescript
// Commit pencil drag if active
if (currentTool === ToolType.PENCIL) {
  commitUndo('Edit tiles');
}
```

With:
```typescript
// Commit pencil drag if active
if (currentTool === ToolType.PENCIL && engineRef.current?.getIsDragActive()) {
  const tiles = engineRef.current.commitDrag();
  if (tiles && tiles.length > 0) {
    setTiles(tiles);
    commitUndo('Edit tiles');
  } else {
    commitUndo('Edit tiles');
  }
}
```

**MapCanvas.tsx — Add Escape cancellation for pencil drag:**

Add a new useEffect after the existing Escape handlers (after line ~1307):
```typescript
// Escape key cancellation for pencil drag
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape' && engineRef.current?.getIsDragActive()) {
      e.preventDefault();
      engineRef.current.cancelDrag();
      // Restore buffer from Zustand state (full rebuild)
      const state = useEditorStore.getState();
      const currentMap = documentId
        ? state.documents.get(documentId)?.map ?? null
        : state.map;
      const currentVp = documentId
        ? state.documents.get(documentId)?.viewport ?? { x: 0, y: 0, zoom: 1 }
        : state.viewport;
      if (currentMap && engineRef.current) {
        engineRef.current.drawMapLayer(currentMap, currentVp, state.animationFrame);
      }
    }
  };
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [documentId]);
```

This is an always-active listener (no dependency on drag state) that checks `getIsDragActive()` dynamically. Avoids the stale-closure problem of having isDragActive in deps.

**MapCanvas.tsx — Update engine unmount cleanup (line ~1228-1231):**

Change the cleanup in the engine mount useEffect:
```typescript
return () => {
  engine.detach(); // detach() now calls cancelDrag() internally
  engineRef.current = null;
};
```

No change needed here — detach() already calls cancelDrag() from Task 1. Just verify it's correct.

**MapCanvas.tsx — Clean up handleToolAction PENCIL case:**

The PENCIL case in handleToolAction (lines 1108-1137) is now ONLY called from the PICKER fallback (which doesn't use PENCIL). However, to be safe and maintain backward compat (handleToolAction is still called from mousedown for non-drag tools), keep the PENCIL case but it's now dead code during drag. Actually — since mousedown now calls `paintPencilTile` instead of `handleToolAction` for pencil, the PENCIL case in handleToolAction is dead code. Remove it to avoid confusion:

Replace the PENCIL case in handleToolAction with just a comment:
```typescript
case ToolType.PENCIL:
  // Pencil drag handled by engine.paintTile() — see paintPencilTile()
  break;
```

**ToolBar.tsx — Add undo blocking during active drag:**

The keyboard handler at line 338 dispatches undo/redo. Add a drag-active check.

Import the CanvasEngine drag check — since ToolBar doesn't have access to the engine ref, we need a different approach. The simplest: export a module-level function from CanvasEngine that MapCanvas registers, or check via a global.

BETTER approach: Since the undo/redo store actions go through Zustand, add the guard at the Zustand action level. BUT modifying the store adds cross-cutting concern.

SIMPLEST approach: ToolBar already imports `useEditorStore`. Add a module-level ref that MapCanvas exports, OR just check a store field.

PRAGMATIC approach: Add a `dragActive` boolean to the Zustand store. No — that reintroduces React coupling during drag.

CLEANEST approach: Export a singleton check from CanvasEngine module. The engine is a class instance, but we can export a module-level registry:

In `src/core/canvas/CanvasEngine.ts`, add at module level (outside the class):
```typescript
// Module-level drag active check for external consumers (undo blocking)
let activeEngine: CanvasEngine | null = null;
export function isAnyDragActive(): boolean {
  return activeEngine?.getIsDragActive() ?? false;
}
```

In `beginDrag()`, set `activeEngine = this;`.
In `commitDrag()` and `cancelDrag()`, after setting isDragActive to false, DON'T clear activeEngine (it stays registered for future drags).
In `attach()`, set `activeEngine = this;`.
In `detach()`, set `activeEngine = null;` (after cancelDrag).

In `src/components/ToolBar/ToolBar.tsx`:
- Add import: `import { isAnyDragActive } from '@core/canvas';`
- In the keyboard handler (line 354), wrap undo/redo:
```typescript
case 'z':
  e.preventDefault();
  if (isAnyDragActive()) break; // Block undo/redo during drag
  if (e.shiftKey) {
    redo();
  } else {
    undo();
  }
  break;
case 'y':
  e.preventDefault();
  if (isAnyDragActive()) break; // Block redo during drag
  redo();
  break;
```

In `src/core/canvas/index.ts`:
- Add export: `export { isAnyDragActive } from './CanvasEngine';`

In `src/App.tsx`:
- Add import: `import { isAnyDragActive } from '@core/canvas';`
- In the menu-action handler (line 288), wrap undo/redo:
```typescript
case 'undo':
  if (!isAnyDragActive()) state.undo();
  break;
case 'redo':
  if (!isAnyDragActive()) state.redo();
  break;
```

**MapCanvas.tsx — Remove pendingTilesRef (line 50):**

The `pendingTilesRef` at line 50 is now replaced by engine's internal `pendingTiles` Map. Remove this line:
```typescript
const pendingTilesRef = useRef<Map<number, number> | null>(null); // key: y*MAP_WIDTH+x, value: tile
```

This was declared but never fully wired in React. Engine now owns it.
  </action>
  <verify>
Run `npm run typecheck` — should pass with no new errors.

Verify wiring:
- grep `beginDrag` in MapCanvas.tsx — should appear in mousedown pencil branch
- grep `paintTile` in MapCanvas.tsx — should appear in paintPencilTile helper and mousemove
- grep `commitDrag` in MapCanvas.tsx — should appear in mouseup and mouseleave
- grep `cancelDrag` in MapCanvas.tsx — should appear in Escape handler
- grep `isAnyDragActive` in ToolBar.tsx — should appear in keyboard handler
- grep `isAnyDragActive` in App.tsx — should appear in menu handler

Verify removed:
- grep `pendingTilesRef` in MapCanvas.tsx — should NOT appear
- The old handleToolAction PENCIL case should be a no-op comment or removed

Verify no setTile() calls during pencil drag path:
- In handleMouseDown pencil branch: no setTile, only beginDrag + paintPencilTile
- In handleMouseMove pencil branch: no setTile, only paintPencilTile
- setTiles() only called in handleMouseUp/handleMouseLeave after commitDrag()
  </verify>
  <done>
Pencil drag uses engine.beginDrag() on mousedown, engine.paintTile() on mousemove (zero Zustand updates), engine.commitDrag() + setTiles() on mouseup (single batch commit). Escape calls cancelDrag() + full buffer rebuild. Undo blocked during drag in ToolBar keyboard handler and App menu handler. pendingTilesRef removed from MapCanvas. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
Requirements coverage:

| Requirement | How Satisfied |
|-------------|---------------|
| DRAG-01 | pendingTiles Map in engine, zero Zustand updates during drag |
| DRAG-02 | paintTile() calls patchTileBuffer() + blitToScreen() imperatively |
| DRAG-03 | commitDrag() returns tiles array, single setTiles() + commitUndo() call |
| DRAG-04 | cancelDrag() + full drawMapLayer() rebuild from store in Escape handler |
| DRAG-05 | isAnyDragActive() guard in ToolBar keyboard handler + App menu handler |
| PERF-01 | No React state mutations during pencil drag (paintTile is imperative) |
| PERF-02 | patchTileBuffer + blitToScreen is < 1ms (same pattern as existing immediatePatchTile) |
| PERF-03 | Single setTiles() on mouseup → single React re-render |

Post-execution verification commands:
```bash
npm run typecheck
```

Manual verification checklist:
- [ ] Draw a line of tiles with pencil — tiles appear instantly during drag
- [ ] Release mouse — tiles committed (visible in undo stack)
- [ ] Press Ctrl+Z during drag — nothing happens (undo blocked)
- [ ] Press Escape during drag — painted tiles disappear, buffer restored
- [ ] Drag pencil to canvas edge (mouse leave) — tiles committed
- [ ] Multi-tile stamp works during pencil drag
</verification>

<success_criteria>
1. `npm run typecheck` passes
2. CanvasEngine has beginDrag/paintTile/commitDrag/cancelDrag/getIsDragActive methods
3. MapCanvas pencil handlers use engine drag lifecycle (no setTile during drag)
4. Undo blocked during active drag (keyboard + menu)
5. Escape during drag cancels and restores buffer
6. pendingTilesRef removed from MapCanvas
7. All 8 Phase 53 requirements (DRAG-01..05, PERF-01..03) addressed
</success_criteria>

<output>
After completion, create `.planning/phases/53-decouple-pencil-drag/53-01-SUMMARY.md`
</output>
