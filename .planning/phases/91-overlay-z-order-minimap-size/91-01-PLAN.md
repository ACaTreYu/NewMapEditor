---
phase: 91-overlay-z-order-minimap-size
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Minimap/Minimap.css
  - src/components/GameObjectToolPanel/GameObjectToolPanel.css
  - src/App.css
  - src/components/Minimap/Minimap.tsx
autonomous: true

must_haves:
  truths:
    - "Minimap and game object tool panel remain visible above maximized MDI child windows"
    - "Minimap canvas renders at 160x160 pixels with no empty margins"
    - "At 800x600 minimum window size, minimap and tool panel do not overlap each other"
    - "Z-index budget is documented in a CSS comment in App.css"
  artifacts:
    - path: "src/components/Minimap/Minimap.css"
      provides: "Minimap overlay z-index above MDI ceiling"
      contains: "z-index: 200000"
    - path: "src/components/GameObjectToolPanel/GameObjectToolPanel.css"
      provides: "Game object tool panel z-index above MDI ceiling"
      contains: "z-index: 200000"
    - path: "src/App.css"
      provides: "Z-index budget documentation comment"
      contains: "Z-INDEX BUDGET"
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "160x160 minimap rendering with correct pixel-fill loop"
      contains: "MINIMAP_SIZE = 160"
  key_links:
    - from: "src/components/Minimap/Minimap.css"
      to: "src/core/editor/slices/windowSlice.ts"
      via: "z-index value 200000 exceeds MDI window ceiling (Z_INDEX_NORMALIZE_THRESHOLD = 100000)"
      pattern: "z-index:\\s*200000"
    - from: "src/components/Minimap/Minimap.tsx"
      to: "Canvas rendering"
      via: "MINIMAP_SIZE constant drives SCALE, canvas dimensions, createImageData, and rendering loop bounds"
      pattern: "MINIMAP_SIZE = 160"
---

<objective>
Fix overlay z-index so minimap and game object tool panel stay above maximized MDI windows, enlarge minimap from 128x128 to 160x160 with correct rendering, and document the z-index budget.

Purpose: OVRL-01 requires overlays always visible; OVRL-02 requires 160x160 minimap. Currently overlays at z-index 100 are covered by MDI windows at z-index 1000+. Minimap rendering loop has hardcoded 2x subsampling that only fills 128px correctly.

Output: Four modified files -- two CSS z-index fixes, one z-index budget comment, one TypeScript constant + rendering loop refactor.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91-overlay-z-order-minimap-size/91-RESEARCH.md
@src/components/Minimap/Minimap.tsx
@src/components/Minimap/Minimap.css
@src/components/GameObjectToolPanel/GameObjectToolPanel.css
@src/App.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Raise overlay z-indexes and document z-index budget</name>
  <files>
    src/components/Minimap/Minimap.css
    src/components/GameObjectToolPanel/GameObjectToolPanel.css
    src/App.css
  </files>
  <action>
    **Minimap.css** — Change `z-index: 100` to `z-index: 200000` on the `.minimap` rule (line 5). This value matches the existing toolbar dropdown pattern in ToolBar.css and is above the MDI window normalization ceiling of 100,000.

    **GameObjectToolPanel.css** — Change `z-index: 100` to `z-index: 200000` on the `.game-object-tool-panel` rule (line 5). Same reasoning as above.

    **App.css** — Insert a z-index budget comment block AFTER the `@import './styles/variables.css';` line (line 8) and BEFORE the `/* ===== Base Styles ===== */` comment (line 10). Use exactly this comment block:

    ```css
    /*
     * Z-INDEX BUDGET
     * ==============
     * 1-2:        Component-internal stacking (MapSettingsDialog tabs: 1, 2)
     * 500:        Minimized bars container (Workspace.css)
     * 1000-99999: MDI child windows (windowSlice.ts BASE_Z_INDEX=1000, normalizes at 100000)
     * 5000-99999: Trace image windows (TRACE_BASE_Z_INDEX=5000)
     * 200000:     Always-on-top overlays: minimap, game object tool panel, toolbar dropdowns
     *
     * Stacking context: .main-area (position: relative) is the root.
     * .workspace has no z-index, so MDI windows participate in .main-area's stacking context.
     * Overlays at 200000 are guaranteed above MDI windows regardless of normalization state.
     */
    ```

    Do NOT change any other CSS properties. Only z-index values and the budget comment.
  </action>
  <verify>
    1. `grep -rn "z-index: 200000" src/components/Minimap/Minimap.css src/components/GameObjectToolPanel/GameObjectToolPanel.css` — both files show z-index: 200000
    2. `grep "Z-INDEX BUDGET" src/App.css` — budget comment exists
    3. `npm run typecheck` passes (no TS errors from CSS changes)
  </verify>
  <done>
    Minimap.css has z-index: 200000 on .minimap. GameObjectToolPanel.css has z-index: 200000 on .game-object-tool-panel. App.css contains the z-index budget comment block between the import and base styles sections. No other CSS properties changed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enlarge minimap to 160x160 and fix rendering loop</name>
  <files>
    src/components/Minimap/Minimap.tsx
  </files>
  <action>
    **Change MINIMAP_SIZE constant** (line 29): Change `const MINIMAP_SIZE = 128;` to `const MINIMAP_SIZE = 160;`

    **Update file header comment** (line 3): Change "0.5px per tile (128x128 canvas)" to "0.625px per tile (160x160 canvas)"

    **Rewrite the tile rendering loop** (lines 324-387 in the `draw` callback, the "Layer 2: Draw tiles as colored pixels" section):

    Replace the existing loop that iterates over MAP_WIDTH x MAP_HEIGHT with a `% 2` subsampling guard:
    ```typescript
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        const tileValue = map.tiles[y * MAP_WIDTH + x];
        if (x % 2 === 0 && y % 2 === 0) {
          const px = Math.floor(x / 2);
          const py = Math.floor(y / 2);
          // ... color lookup ...
        }
      }
    }
    ```

    With a loop that iterates over minimap pixels and maps back to tile coordinates:
    ```typescript
    for (let py = 0; py < MINIMAP_SIZE; py++) {
      for (let px = 0; px < MINIMAP_SIZE; px++) {
        const tx = Math.min(MAP_WIDTH - 1, Math.floor(px / SCALE));
        const ty = Math.min(MAP_HEIGHT - 1, Math.floor(py / SCALE));
        const tileValue = map.tiles[ty * MAP_WIDTH + tx];

        let r: number, g: number, b: number;

        if (tileValue === DEFAULT_TILE) {
          if (farplanePixelsRef.current) {
            const fpIdx = (py * MINIMAP_SIZE + px) * 4;
            r = farplanePixelsRef.current[fpIdx];
            g = farplanePixelsRef.current[fpIdx + 1];
            b = farplanePixelsRef.current[fpIdx + 2];
          } else {
            const isGray = ((Math.floor(px / 8) + Math.floor(py / 8)) % 2) === 0;
            r = isGray ? 192 : 255;
            g = isGray ? 192 : 255;
            b = isGray ? 192 : 255;
          }
        } else if ((tileValue & 0x8000) !== 0) {
          const animId = tileValue & 0xFF;
          if (animColorCacheRef.current) {
            const offset = animId * 3;
            r = animColorCacheRef.current[offset];
            g = animColorCacheRef.current[offset + 1];
            b = animColorCacheRef.current[offset + 2];
          } else {
            r = 90; g = 90; b = 142;
          }
        } else {
          const specialColor = specialColorMapRef.current?.get(tileValue);
          if (specialColor) {
            r = specialColor[0];
            g = specialColor[1];
            b = specialColor[2];
          } else if (tileColorCacheRef.current) {
            const totalTilesInCache = tileColorCacheRef.current.length / 3;
            if (tileValue < totalTilesInCache) {
              const offset = tileValue * 3;
              r = tileColorCacheRef.current[offset];
              g = tileColorCacheRef.current[offset + 1];
              b = tileColorCacheRef.current[offset + 2];
            } else {
              r = 26; g = 26; b = 46;
            }
          } else {
            r = 26; g = 26; b = 46;
          }
        }

        const idx = (py * MINIMAP_SIZE + px) * 4;
        data[idx] = r;
        data[idx + 1] = g;
        data[idx + 2] = b;
        data[idx + 3] = 255;
      }
    }
    ```

    The key changes:
    1. Outer loops iterate minimap pixels (0..MINIMAP_SIZE) instead of map tiles (0..MAP_WIDTH)
    2. `tx` and `ty` are computed via inverse SCALE: `Math.floor(px / SCALE)` — correct for any MINIMAP_SIZE
    3. No `% 2` guard — every minimap pixel gets a color, filling the full 160x160 canvas
    4. Color lookup logic (DEFAULT_TILE, animated, static) is preserved identically
    5. Farplane pixel sampling uses `py * MINIMAP_SIZE + px` (unchanged formula, works at any size)

    Do NOT change: tile color cache building, farplane cache effect, viewport rectangle calculation, click handlers, or any other code. SCALE auto-recalculates from the new MINIMAP_SIZE.
  </action>
  <verify>
    1. `npm run typecheck` passes — no TypeScript errors
    2. `grep "MINIMAP_SIZE = 160" src/components/Minimap/Minimap.tsx` — constant is 160
    3. Verify no `x % 2` or `y % 2` guards remain in the draw function (the old subsampling pattern is gone)
    4. The rendering loop iterates `MINIMAP_SIZE * MINIMAP_SIZE` pixels (25,600 iterations for 160x160)
  </verify>
  <done>
    MINIMAP_SIZE is 160. SCALE auto-calculates to 0.625. The rendering loop iterates all 160x160 minimap pixels, maps each back to tile coordinates via inverse SCALE, and fills every pixel with the correct color. No empty margins. The canvas element renders at 160x160. Header comment updated to reflect new dimensions.
  </done>
</task>

</tasks>

<verification>
1. **Z-index fix (OVRL-01):** Open the app, create/open a map, maximize an MDI child window. The minimap (top-right) and game object tool panel (bottom-right) must remain visible above the maximized window. Test with multiple MDI windows open and raised repeatedly (z-index increments should never exceed 200000).

2. **Minimap size (OVRL-02):** The minimap canvas should visually appear larger than before (160px vs 128px). All 160x160 pixels should be filled — no empty right or bottom margin. Verify across all three themes (Light, Dark, Terminal) that the minimap border and background render correctly.

3. **No overlap at 800x600:** Resize the application window to 800x600. The minimap (top-right, 160px tall) and game object tool panel (bottom-right) must not overlap. The main-area height at 800x600 minus toolbar/statusbar is approximately 540px, which comfortably fits both panels (160 + 8 + 8 + ~200 = ~376px needed).

4. **Z-index budget:** Open `src/App.css` and verify the z-index budget comment block exists between the import and base styles sections.

5. **TypeScript:** `npm run typecheck` passes with no errors.
</verification>

<success_criteria>
- Minimap and game object tool panel stay above maximized MDI windows (z-index: 200000)
- Minimap renders at 160x160 pixels with full pixel coverage (no empty margins)
- Z-index budget comment exists in App.css
- TypeScript compiles without errors
- No visual regression in minimap colors, viewport rectangle, or click-to-navigate behavior
</success_criteria>

<output>
After completion, create `.planning/phases/91-overlay-z-order-minimap-size/91-01-SUMMARY.md`
</output>
