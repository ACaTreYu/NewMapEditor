---
phase: 59-ruler-tool-advanced-modes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/globalSlice.ts
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/StatusBar/StatusBar.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag to measure rectangular area and see WxH + tile count"
    - "User can drag from center point to measure radius and see radius + area"
    - "Status bar shows mode-specific measurement values"
    - "Mode switch clears active measurement state cleanly"
  artifacts:
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "RulerMode enum, rulerMode state, pinnedMeasurements array, mode/pin actions"
      contains: "RulerMode"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Mode-branched mouse handlers and rendering for rectangle + radius"
      contains: "RulerMode.RECTANGLE"
    - path: "src/components/StatusBar/StatusBar.tsx"
      provides: "Mode-specific measurement display"
      contains: "rulerMode"
  key_links:
    - from: "src/core/editor/slices/globalSlice.ts"
      to: "src/components/MapCanvas/MapCanvas.tsx"
      via: "useEditorStore subscription for rulerMode"
      pattern: "rulerMode"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "setRulerMeasurement with mode-specific data"
      pattern: "setRulerMeasurement"
---

<objective>
Add RulerMode state infrastructure and implement rectangle + radius measurement modes.

Purpose: Extends Phase 58 line-mode ruler with two drag-based modes (rectangle area, radius/circle) sharing the same click-drag interaction pattern. Establishes the RulerMode enum and multi-mode state structure that Plan 02 builds on.

Output: User can switch between line/rectangle/radius modes, drag to measure, and see mode-specific metrics in the status bar and as floating labels.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-ruler-tool-advanced-modes/59-RESEARCH.md
@.planning/phases/58-ruler-tool-line-mode/58-01-SUMMARY.md

Key files to read before implementation:
@src/core/editor/slices/globalSlice.ts (rulerMeasurement state, current shape)
@src/components/MapCanvas/MapCanvas.tsx (rulerStateRef, mouse handlers at ~994, ~1092, rendering at ~619)
@src/components/StatusBar/StatusBar.tsx (rulerMeasurement display at ~174)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RulerMode enum and extend Zustand state for multi-mode ruler</name>
  <files>src/core/editor/slices/globalSlice.ts</files>
  <action>
1. Add a `RulerMode` enum at the top of globalSlice.ts (after imports):
```typescript
export enum RulerMode {
  LINE = 'line',
  RECTANGLE = 'rectangle',
  PATH = 'path',
  RADIUS = 'radius'
}
```

2. Extend the `rulerMeasurement` type in GlobalSlice interface to be a discriminated union supporting all modes. Replace the current type with this COMPLETE definition (includes shared coordinate fields used by all modes for zoom-stable pinning):
```typescript
rulerMeasurement: {
  mode: RulerMode;
  // Shared coordinate fields — stored for ALL modes so pinMeasurement
  // can reconstruct rendering without separate coordinate storage
  startX: number;
  startY: number;
  endX: number;
  endY: number;
  // Line mode
  dx?: number;
  dy?: number;
  manhattan?: number;
  euclidean?: number;
  // Rectangle mode
  width?: number;
  height?: number;
  tileCount?: number;
  // Path mode (used by Plan 02)
  waypoints?: Array<{ x: number; y: number }>;
  totalDistance?: number;
  // Radius mode
  centerX?: number;
  centerY?: number;
  radius?: number;
  area?: number;
} | null;
```

3. Add new state fields to GlobalSlice interface:
```typescript
rulerMode: RulerMode;
pinnedMeasurements: Array<{
  id: string;
  measurement: NonNullable<GlobalSlice['rulerMeasurement']>;
}>;
```
Note: The `pinnedMeasurement.measurement` already contains `startX/Y`, `endX/Y`, and `waypoints` from the shared coordinate fields above — no separate coordinate storage needed.

4. Add new actions to GlobalSlice interface:
```typescript
setRulerMode: (mode: RulerMode) => void;
pinMeasurement: () => void;
unpinMeasurement: (id: string) => void;
clearAllPinnedMeasurements: () => void;
```

5. Add initial values in the state creator:
```typescript
rulerMode: RulerMode.LINE,
pinnedMeasurements: [],
```

6. Implement the actions:
- `setRulerMode`: `(mode) => set({ rulerMode: mode, rulerMeasurement: null })` (clear measurement on mode switch)
- `pinMeasurement`: Reads current `rulerMeasurement`, if non-null, appends to `pinnedMeasurements` with `id: Date.now().toString()`. Since `rulerMeasurement` already contains `startX/Y`, `endX/Y`, and `waypoints` (shared coordinate fields defined in step 2), `pinMeasurement` simply copies the entire measurement object into the pinned array with an id — no separate coordinate extraction needed.
- `unpinMeasurement`: Filters `pinnedMeasurements` by id.
- `clearAllPinnedMeasurements`: Sets `pinnedMeasurements` to `[]`.

7. Export the `RulerMode` enum so it can be imported by other files.

**Important:** The `setRulerMeasurement` action signature stays the same (accepts the measurement type or null). Existing Phase 58 line-mode code in MapCanvas.tsx that calls `setRulerMeasurement({ dx, dy, manhattan, euclidean })` must be updated to include `mode: RulerMode.LINE, startX, startY, endX, endY`.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify RulerMode enum is exported and all new state fields exist.</verify>
  <done>GlobalSlice has RulerMode enum, rulerMode state (default LINE), extended rulerMeasurement type with mode discriminant and coordinate fields, pinnedMeasurements array, and setRulerMode/pinMeasurement/unpinMeasurement/clearAllPinnedMeasurements actions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement rectangle + radius mouse handlers, rendering, and status bar</name>
  <files>src/components/MapCanvas/MapCanvas.tsx, src/components/StatusBar/StatusBar.tsx</files>
  <action>
**MapCanvas.tsx changes:**

1. Import `RulerMode` from globalSlice (or from the types barrel export if available). Subscribe to `rulerMode` from Zustand:
```typescript
const rulerMode = useEditorStore((state) => state.rulerMode);
```

2. Update the `RulerState` interface to include waypoints for Plan 02:
```typescript
interface RulerState {
  active: boolean;
  startX: number;
  startY: number;
  endX: number;
  endY: number;
  waypoints: Array<{ x: number; y: number }>;
}
```
Update initial ref value to include `waypoints: []`.

3. Add a `useEffect` for mode-switch cleanup (clear ruler state when rulerMode changes):
```typescript
useEffect(() => {
  if (rulerStateRef.current.active) {
    rulerStateRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0, waypoints: [] };
    setRulerMeasurement(null);
    requestUiRedraw();
  }
}, [rulerMode]);
```

4. **handleMouseDown** — The existing ruler block at ~line 994 already sets `rulerStateRef.current` for line mode. Keep this behavior for LINE, RECTANGLE, and RADIUS modes (they all use click-drag). No change needed — the existing code works for all drag-based modes. The PATH mode branching will be added in Plan 02.

5. **handleMouseMove** — The existing ruler block at ~line 1092 updates `rulerStateRef.current.endX/endY` and calls `setRulerMeasurement`. Branch the measurement calculation based on `rulerMode`:
```typescript
} else if (rulerStateRef.current.active) {
  const prev = rulerStateRef.current;
  if (prev.endX !== x || prev.endY !== y) {
    rulerStateRef.current = { ...prev, endX: x, endY: y };

    if (rulerMode === RulerMode.LINE) {
      const dx = Math.abs(x - prev.startX);
      const dy = Math.abs(y - prev.startY);
      const manhattan = dx + dy;
      const euclidean = Math.hypot(dx, dy);
      setRulerMeasurement({
        mode: RulerMode.LINE,
        dx, dy, manhattan, euclidean,
        startX: prev.startX, startY: prev.startY, endX: x, endY: y
      });
    } else if (rulerMode === RulerMode.RECTANGLE) {
      // +1 for inclusive tile counting: dragging from tile 2 to tile 5 spans 4 tiles
      // (2,3,4,5), not 3. RESEARCH.md uses raw delta without +1, but inclusive bounds
      // match user expectation for "how many tiles does this rectangle cover?"
      const width = Math.abs(x - prev.startX) + 1;
      const height = Math.abs(y - prev.startY) + 1;
      setRulerMeasurement({
        mode: RulerMode.RECTANGLE,
        width, height, tileCount: width * height,
        startX: prev.startX, startY: prev.startY, endX: x, endY: y
      });
    } else if (rulerMode === RulerMode.RADIUS) {
      const rdx = x - prev.startX;
      const rdy = y - prev.startY;
      const radius = Math.hypot(rdx, rdy);
      const area = Math.PI * radius * radius;
      setRulerMeasurement({
        mode: RulerMode.RADIUS,
        centerX: prev.startX, centerY: prev.startY,
        radius, area,
        startX: prev.startX, startY: prev.startY, endX: x, endY: y
      });
    }

    requestUiRedraw();
  }
}
```

6. **drawUiLayer** — Replace the single ruler overlay block (~line 619-690) with mode-branched rendering:

**Line mode** (existing, just wrap in `if (rulerMode === RulerMode.LINE)` or no mode check needed since it's the existing code):
Keep existing yellow line + crosshairs + floating label. Update the floating label to read from the new measurement fields.

**Rectangle mode:**
- Draw a yellow stroked rectangle from start tile to end tile (use `tileToScreen` for both corners)
- The rectangle should cover the full tile areas (not just centers): from `startScreen.x` to `endScreen.x + tilePixels`, swapping min/max as needed
- Draw a floating label at the center showing "Rect: WxH (N tiles)"
- Use same label background/styling as line mode

**Radius mode:**
- Draw a yellow stroked circle: center at `startScreen` tile center, radius calculated as screen-space distance from center to end tile center
- Draw a radius line from center to end point
- Draw crosshair at center
- Draw a floating label near the circle showing "Radius: R.XX (Area: A.XX)"

For all modes, use `ctx.strokeStyle = '#FFD700'`, `ctx.lineWidth = 2`, `ctx.setLineDash([])`.

7. **Tool switch cleanup** (useEffect at ~line 1442) — Update the ruler cleanup to also clear waypoints:
```typescript
rulerStateRef.current = { active: false, startX: 0, startY: 0, endX: 0, endY: 0, waypoints: [] };
```

8. **Escape handler** (~line 1549) — Same update for waypoints reset.

9. Add `rulerMode` to the dependency arrays of `drawUiLayer` useCallback.

**StatusBar.tsx changes:**

10. Import `RulerMode` from globalSlice. Subscribe to `rulerMode`:
```typescript
const rulerMode = useEditorStore((state) => state.rulerMode);
```

11. Update the ruler measurement display (at ~line 174) to show mode-specific text:
```typescript
{rulerMeasurement && (
  <>
    <div className="status-separator">|</div>
    <div className="status-field">
      {rulerMeasurement.mode === RulerMode.LINE && (
        <>Ruler: {rulerMeasurement.dx}x{rulerMeasurement.dy} (Tiles: {rulerMeasurement.manhattan}, Dist: {rulerMeasurement.euclidean?.toFixed(2)})</>
      )}
      {rulerMeasurement.mode === RulerMode.RECTANGLE && (
        <>Rect: {rulerMeasurement.width}x{rulerMeasurement.height} ({rulerMeasurement.tileCount} tiles)</>
      )}
      {rulerMeasurement.mode === RulerMode.RADIUS && (
        <>Radius: {rulerMeasurement.radius?.toFixed(2)} (Area: {rulerMeasurement.area?.toFixed(1)})</>
      )}
    </div>
  </>
)}
```

**Important: Do NOT change the ToolType enum or ToolBar.tsx** — the ruler tool button remains the same; modes are selected via the mode selector UI (added in Plan 02).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npm run electron:dev`, select ruler tool, and verify:
1. Default behavior is line mode (unchanged from Phase 58)
2. Rectangle and radius modes work when rulerMode is changed (test via devtools: `useEditorStore.getState().setRulerMode('rectangle')`)
3. Mode-specific overlays render correctly
4. Mode-specific status bar text displays
5. Tool switch and Escape both clear measurement cleanly</verify>
  <done>MapCanvas renders rectangle (stroked rect with WxH label) and radius (stroked circle with radius/area label) overlays. Status bar shows mode-specific compact measurement text. Mode switch clears transient state. All three drag-based modes (line/rectangle/radius) share the same mousedown/mouseup pattern with mode-branched mousemove and rendering.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Line mode works exactly as before (Phase 58 behavior preserved)
3. Rectangle mode: drag shows yellow rectangle outline, floating label "Rect: WxH (N tiles)", status bar shows same
4. Radius mode: drag shows yellow circle from center, floating label "Radius: R.XX (Area: A.XX)", status bar shows same
5. Switching rulerMode clears active measurement (no leftover artifacts)
6. Tool switch clears ruler state for all modes
7. Escape clears ruler state for all modes
</verification>

<success_criteria>
- RulerMode enum exists with LINE, RECTANGLE, PATH, RADIUS values
- Rectangle drag produces accurate WxH measurement with tile count
- Radius drag produces accurate radius and area calculation
- Status bar displays mode-specific measurement format
- No visual artifacts when switching between modes
- Pinned measurements infrastructure exists in Zustand (used by Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/59-ruler-tool-advanced-modes/59-01-SUMMARY.md`
</output>
