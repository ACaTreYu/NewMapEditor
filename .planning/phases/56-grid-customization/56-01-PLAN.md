---
phase: 56-grid-customization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/globalSlice.ts
  - src/core/editor/EditorState.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Grid renders with configurable opacity, line weight, and color instead of hardcoded values"
    - "Grid settings persist to localStorage and restore on application restart"
    - "Grid pattern cache invalidates when any setting changes, not just zoom"
  artifacts:
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "gridOpacity, gridLineWeight, gridColor state fields and setter actions"
      contains: "gridOpacity|gridLineWeight|gridColor"
    - path: "src/core/editor/EditorState.ts"
      provides: "localStorage persistence for grid settings"
      contains: "ac-map-editor-grid"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Dynamic grid rendering using store settings"
      contains: "gridOpacity|gridLineWeight|gridColor"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "useEditorStore selectors for gridOpacity, gridLineWeight, gridColor"
      pattern: "state\\.grid(Opacity|LineWeight|Color)"
    - from: "src/core/editor/EditorState.ts"
      to: "localStorage"
      via: "store.subscribe persists grid settings on change"
      pattern: "localStorage\\.setItem.*grid"
---

<objective>
Add grid customization state (opacity, line weight, color) to GlobalSlice, wire dynamic rendering in MapCanvas, and persist settings to localStorage.

Purpose: Foundation for grid customization — state management, rendering, and persistence must exist before UI controls can be added in Plan 02.
Output: Grid renders with configurable settings (still using hardcoded defaults until UI added), settings survive restart.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/core/editor/slices/globalSlice.ts
@src/core/editor/EditorState.ts
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grid settings state to GlobalSlice and persist to localStorage</name>
  <files>
    src/core/editor/slices/globalSlice.ts
    src/core/editor/EditorState.ts
  </files>
  <action>
**globalSlice.ts — Add 3 state fields and 3 setter actions to GlobalSlice interface and createGlobalSlice:**

1. Add to `GlobalSlice` interface (after the `showGrid: boolean` field):
   - `gridOpacity: number;` — 0-100 (percentage, default 10 to match current rgba 0.1)
   - `gridLineWeight: number;` — 1-3 (pixels, default 1 to match current lineWidth 1)
   - `gridColor: string;` — hex string (default '#FFFFFF' to match current white)

2. Add to `GlobalSlice` interface actions section (after `toggleGrid`):
   - `setGridOpacity: (opacity: number) => void;`
   - `setGridLineWeight: (weight: number) => void;`
   - `setGridColor: (color: string) => void;`

3. Add initial values in `createGlobalSlice` (after `showGrid: false`):
   - `gridOpacity: 10,`
   - `gridLineWeight: 1,`
   - `gridColor: '#FFFFFF',`

4. Add setter implementations in `createGlobalSlice` (after `toggleGrid` action):
   - `setGridOpacity: (opacity) => set({ gridOpacity: Math.max(0, Math.min(100, opacity)) }),`
   - `setGridLineWeight: (weight) => set({ gridLineWeight: Math.max(1, Math.min(3, weight)) }),`
   - `setGridColor: (color) => set({ gridColor: color.toUpperCase() }),`
   Note: `toUpperCase()` on color normalizes case for cache key comparison (prevents unnecessary cache invalidation).

**EditorState.ts — Add localStorage persistence via store.subscribe:**

1. After the `useEditorStore = create<EditorState>()(...)` call (after line 453), add localStorage load + subscribe:

```typescript
// --- Grid settings persistence ---
const GRID_STORAGE_KEY = 'ac-map-editor-grid-settings';

// Load persisted grid settings and apply to store
try {
  const stored = localStorage.getItem(GRID_STORAGE_KEY);
  if (stored) {
    const parsed = JSON.parse(stored);
    const updates: Record<string, unknown> = {};
    if (typeof parsed.opacity === 'number') updates.gridOpacity = Math.max(0, Math.min(100, parsed.opacity));
    if (typeof parsed.lineWeight === 'number') updates.gridLineWeight = Math.max(1, Math.min(3, parsed.lineWeight));
    if (typeof parsed.color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(parsed.color)) updates.gridColor = parsed.color.toUpperCase();
    if (Object.keys(updates).length > 0) {
      useEditorStore.setState(updates);
    }
  }
} catch {
  // Ignore corrupt localStorage
}

// Persist grid settings on change
useEditorStore.subscribe((state, prevState) => {
  if (
    state.gridOpacity !== prevState.gridOpacity ||
    state.gridLineWeight !== prevState.gridLineWeight ||
    state.gridColor !== prevState.gridColor
  ) {
    try {
      localStorage.setItem(GRID_STORAGE_KEY, JSON.stringify({
        opacity: state.gridOpacity,
        lineWeight: state.gridLineWeight,
        color: state.gridColor,
      }));
    } catch {
      // Ignore quota exceeded
    }
  }
});
```

Key points:
- Load runs ONCE after store creation (not on every render)
- Validates types and ranges before applying (prevents corrupt data)
- Validates hex color format with regex
- Both load and save wrapped in try/catch (localStorage can throw)
- Subscribe fires on every state change, only writes when grid settings actually changed
  </action>
  <verify>
Run `npx tsc --noEmit` — zero new errors. Grep for `gridOpacity` in globalSlice.ts and EditorState.ts to confirm fields exist.
  </verify>
  <done>
GlobalSlice has gridOpacity (0-100), gridLineWeight (1-3), gridColor (hex) fields with clamped setters. EditorState.ts loads grid settings from localStorage on init and persists changes via subscribe.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dynamic grid rendering in MapCanvas</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
**Replace hardcoded grid rendering with dynamic settings from Zustand store.**

1. **Add grid settings to existing subscriptions (around line 101):** After the `showGrid` selector, add three more selectors:
```typescript
const gridOpacity = useEditorStore(state => state.gridOpacity);
const gridLineWeight = useEditorStore(state => state.gridLineWeight);
const gridColor = useEditorStore(state => state.gridColor);
```

2. **Replace gridPatternZoomRef with composite cache key ref (line 44):**
Change:
```typescript
const gridPatternZoomRef = useRef<number>(-1);
```
To:
```typescript
const gridCacheKeyRef = useRef<string>('');
```

3. **Update grid rendering block (lines 233-265):** Replace the hardcoded pattern generation:

Old pattern condition (line 238):
```typescript
if (gridPatternZoomRef.current !== tilePixelSize) {
```
New:
```typescript
const cacheKey = `${tilePixelSize}-${gridOpacity}-${gridLineWeight}-${gridColor}`;
if (gridCacheKeyRef.current !== cacheKey) {
```

Old stroke style (line 244):
```typescript
pctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
pctx.lineWidth = 1;
```
New (convert hex+opacity to rgba):
```typescript
const r = parseInt(gridColor.slice(1, 3), 16);
const g = parseInt(gridColor.slice(3, 5), 16);
const b = parseInt(gridColor.slice(5, 7), 16);
pctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${gridOpacity / 100})`;
pctx.lineWidth = gridLineWeight;
```

Old cache key update (line 253):
```typescript
gridPatternZoomRef.current = tilePixelSize;
```
New:
```typescript
gridCacheKeyRef.current = cacheKey;
```

4. **Update ResizeObserver cache invalidation (around line 1424):**
Change:
```typescript
gridPatternZoomRef.current = -1;
```
To:
```typescript
gridCacheKeyRef.current = '';
```

5. **Add grid settings to drawUiLayer dependency array (line 566):**
The existing dependency array is:
```typescript
}, [currentTool, tileSelection, gameObjectToolState, selection, viewport, tilesetImage, isPasting, clipboard, showGrid, getLineTiles, tileToScreen]);
```
Add the three new settings after `showGrid`:
```typescript
}, [currentTool, tileSelection, gameObjectToolState, selection, viewport, tilesetImage, isPasting, clipboard, showGrid, gridOpacity, gridLineWeight, gridColor, getLineTiles, tileToScreen]);
```
This ensures drawUiLayer is recreated when grid settings change, which triggers the useEffect at line 654-656 to redraw the UI layer.

Key pitfall avoidance:
- Cache key is composite string including ALL grid settings + zoom — prevents stale pattern
- lineWidth uses physical pixels (not scaled by zoom) — pattern repeat handles scale
- Color normalized to uppercase in setter — cache key comparison is case-consistent
  </action>
  <verify>
Run `npx tsc --noEmit` — zero new errors. Grep for `gridCacheKeyRef` in MapCanvas.tsx — should appear 3 times (declaration, set, reset). Grep for `gridPatternZoomRef` — should appear 0 times (fully replaced).
  </verify>
  <done>
Grid rendering uses gridOpacity, gridLineWeight, gridColor from Zustand store instead of hardcoded values. Pattern cache invalidates on any setting change via composite cache key string.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero new errors
2. `gridPatternZoomRef` no longer exists in codebase (fully replaced by `gridCacheKeyRef`)
3. `gridOpacity`, `gridLineWeight`, `gridColor` exist in globalSlice.ts interface and implementation
4. `localStorage` persistence code exists in EditorState.ts with both load and subscribe
5. `drawUiLayer` dependency array includes `gridOpacity`, `gridLineWeight`, `gridColor`
</verification>

<success_criteria>
- Grid renders using configurable opacity/weight/color (defaults match previous hardcoded values)
- Grid pattern cache uses composite key (zoom + opacity + weight + color)
- Settings persist to localStorage and restore on app restart
- TypeScript compilation passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/56-grid-customization/56-01-SUMMARY.md`
</output>
