---
phase: 50-buffer-zone-over-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/components/MapCanvas/MapCanvas.tsx]
autonomous: true

must_haves:
  truths:
    - "Visible tile range is expanded by 3 tiles in each direction beyond viewport edges"
    - "Pre-rendered buffer tiles slide into view during pan without triggering buffer rebuild"
    - "Buffer rebuilds only when viewport exits the buffer margin zone"
    - "All existing tools work correctly (pencil, fill, wall, line, select, paste, conveyor, game objects)"
    - "Animated tiles animate correctly within the buffered region"
    - "Zoom to cursor works at all zoom levels (0.25x to 4x)"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Dynamic buffer zone rendering with viewport-relative coordinates"
      contains: "BUFFER_MARGIN"
  key_links:
    - from: "drawMapLayer buffer creation"
      to: "drawMapLayer blit operation"
      via: "bufferStateRef tracking buffer origin (startX, startY)"
      pattern: "vp\\.x - buffer.*startX"
    - from: "drawMapLayer invalidation check"
      to: "buffer rebuild"
      via: "viewport-exited-buffer-zone detection"
      pattern: "bufferStateRef"
    - from: "animation tick"
      to: "buffer patching"
      via: "buffer-relative tile coordinates for animated tile updates"
      pattern: "bufferState.*startX"
---

<objective>
Replace the fixed 4096x4096 full-map buffer with a dynamic viewport-sized buffer that pre-renders 3 tiles beyond viewport edges in each direction. Buffer tiles slide into view during pan, reducing re-render frequency from every frame to only when viewport exits the buffer margin.

Purpose: Reduce initial render from 65,536 tiles to ~400 tiles (~160x faster). Save ~16MB GPU memory. Pan drag stays smooth because buffer margin provides 3 tiles of "runway" before rebuild is needed.

Output: Updated MapCanvas.tsx with dynamic buffer zone rendering.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-buffer-zone-over-rendering/50-RESEARCH.md
@.planning/phases/49-canvas-optimization/49-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace full-map buffer with dynamic buffer zone</name>
  <files>src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
  Replace the fixed 4096x4096 off-screen buffer with a dynamic buffer sized to viewport + 3-tile margin. This task changes the buffer infrastructure, tile rendering coordinates, and blit operation.

  **Step 1: Add BUFFER_MARGIN constant and BufferState interface**

  Add near the top of the file (after existing constants):

  ```typescript
  const BUFFER_MARGIN = 3; // tiles pre-rendered beyond viewport edges

  interface BufferState {
    startX: number;  // Map tile coordinate of buffer's top-left corner
    startY: number;
    endX: number;    // Map tile coordinate of buffer's bottom-right corner (exclusive)
    endY: number;
  }
  ```

  **Step 2: Add bufferStateRef**

  Add a new ref alongside existing buffer refs (near line 76-79):

  ```typescript
  const bufferStateRef = useRef<BufferState | null>(null);
  ```

  **Step 3: Create calculateBufferBounds helper**

  Add a helper function (outside the component, pure function) that computes the expanded tile range:

  ```typescript
  function calculateBufferBounds(
    vpX: number, vpY: number, vpZoom: number,
    canvasWidth: number, canvasHeight: number
  ): BufferState {
    const tilePixels = TILE_SIZE * vpZoom;
    const tilesX = Math.ceil(canvasWidth / tilePixels) + 1;
    const tilesY = Math.ceil(canvasHeight / tilePixels) + 1;

    const startX = Math.max(0, Math.floor(vpX) - BUFFER_MARGIN);
    const startY = Math.max(0, Math.floor(vpY) - BUFFER_MARGIN);
    const endX = Math.min(MAP_WIDTH, Math.floor(vpX) + tilesX + BUFFER_MARGIN);
    const endY = Math.min(MAP_HEIGHT, Math.floor(vpY) + tilesY + BUFFER_MARGIN);

    return { startX, startY, endX, endY };
  }
  ```

  **Step 4: Create isViewportInBuffer helper**

  Add a helper that checks if the current viewport is still within the buffered region with at least 1 tile of safety margin:

  ```typescript
  function isViewportInBuffer(
    vpX: number, vpY: number, vpZoom: number,
    canvasWidth: number, canvasHeight: number,
    buffer: BufferState
  ): boolean {
    const tilePixels = TILE_SIZE * vpZoom;
    const tilesX = Math.ceil(canvasWidth / tilePixels) + 1;
    const tilesY = Math.ceil(canvasHeight / tilePixels) + 1;
    const vpStartX = Math.floor(vpX);
    const vpStartY = Math.floor(vpY);

    return vpStartX >= buffer.startX + 1 &&
           vpStartY >= buffer.startY + 1 &&
           vpStartX + tilesX <= buffer.endX - 1 &&
           vpStartY + tilesY <= buffer.endY - 1;
  }
  ```

  **Step 5: Rewrite drawMapLayer**

  Replace the entire `drawMapLayer` function body. Key changes:

  1. **Buffer creation**: Size = `(endX - startX) * TILE_SIZE` by `(endY - startY) * TILE_SIZE` (dynamic, not fixed 4096x4096). Only recreate buffer when size changes (different tile count, not every viewport change).

  2. **Full build trigger**: Triggered when `needsFullBuild` OR viewport has exited the buffer zone (check via `isViewportInBuffer`). On full build, recalculate buffer bounds, resize canvas if needed, render only tiles within bounds using buffer-relative coordinates:
     ```typescript
     // Buffer-relative rendering
     const bufX = (x - bounds.startX) * TILE_SIZE;
     const bufY = (y - bounds.startY) * TILE_SIZE;
     renderTile(bufCtx, tilesetImage, tile, bufX, bufY, TILE_SIZE, curAnimFrame);
     ```

  3. **Incremental patch**: Only diff tiles within current buffer bounds (`bufferState.startX..endX`, `startY..endY`), NOT the entire 65K tile array. Use buffer-relative coordinates for patch rendering:
     ```typescript
     for (let y = bufferState.startY; y < bufferState.endY; y++) {
       for (let x = bufferState.startX; x < bufferState.endX; x++) {
         const idx = y * MAP_WIDTH + x;
         if (map.tiles[idx] !== prev[idx]) {
           const bufX = (x - bufferState.startX) * TILE_SIZE;
           const bufY = (y - bufferState.startY) * TILE_SIZE;
           bufCtx.clearRect(bufX, bufY, TILE_SIZE, TILE_SIZE);
           renderTile(bufCtx, tilesetImage, map.tiles[idx], bufX, bufY, TILE_SIZE, curAnimFrame);
           prev[idx] = map.tiles[idx];
         }
       }
     }
     ```

  4. **Blit**: Use buffer-relative source coordinates:
     ```typescript
     const srcX = (vp.x - bufferState.startX) * TILE_SIZE;
     const srcY = (vp.y - bufferState.startY) * TILE_SIZE;
     const srcW = canvas.width / vp.zoom;
     const srcH = canvas.height / vp.zoom;
     ctx.drawImage(buffer, srcX, srcY, srcW, srcH, 0, 0, canvas.width, canvas.height);
     ```

  5. **Update bufferStateRef** after each full build so subsequent calls know the buffered region.

  **Step 6: Update animation tick useEffect**

  The animation tick (lines 706-759) currently uses absolute map coordinates for buffer patching (`x * TILE_SIZE, y * TILE_SIZE`). Change to buffer-relative coordinates:

  ```typescript
  // Read buffer state
  const bufferState = bufferStateRef.current;
  if (!bufferState) return;

  // Clamp animation visible range to buffer bounds
  const startX = Math.max(bufferState.startX, Math.floor(vp.x));
  const startY = Math.max(bufferState.startY, Math.floor(vp.y));
  const endX = Math.min(bufferState.endX, Math.floor(vp.x) + tilesX);
  const endY = Math.min(bufferState.endY, Math.floor(vp.y) + tilesY);

  // Patch with buffer-relative coordinates
  bufCtx.clearRect(
    (x - bufferState.startX) * TILE_SIZE,
    (y - bufferState.startY) * TILE_SIZE,
    TILE_SIZE, TILE_SIZE
  );
  renderTile(bufCtx, tilesetImage, tile,
    (x - bufferState.startX) * TILE_SIZE,
    (y - bufferState.startY) * TILE_SIZE,
    TILE_SIZE, curAnimFrame
  );
  ```

  Also update the blit in the animation tick to use buffer-relative source coordinates:
  ```typescript
  const srcX = (vp.x - bufferState.startX) * TILE_SIZE;
  const srcY = (vp.y - bufferState.startY) * TILE_SIZE;
  ```

  **Step 7: Update cleanup effect**

  Add `bufferStateRef.current = null;` to the cleanup effect (alongside existing buffer cleanup at lines 1327-1337).

  **CRITICAL: What NOT to change:**
  - Do NOT change drawUiLayer (grid, overlays, cursors) - it uses screen coordinates, not buffer
  - Do NOT change progressive render (requestProgressiveRender) - it calls drawMapLayer which handles buffer internally
  - Do NOT change commitPan - it calls drawMapLayer/drawUiLayer which handle buffer internally
  - Do NOT change CSS transform pan behavior
  - Do NOT change tool handlers (mouse events)
  - Do NOT change scrollbar code

  **CRITICAL: Integer coordinate safety:**
  - Always use `Math.floor(vp.x)` before subtracting BUFFER_MARGIN (prevent fractional tile coords)
  - Always clamp with `Math.max(0, ...)` and `Math.min(MAP_WIDTH/HEIGHT, ...)`
  - Buffer-relative blit uses `(vp.x - bufferState.startX) * TILE_SIZE` (vp.x can be fractional, that's correct for sub-pixel positioning)
  </action>
  <verify>
  1. Run `npm run typecheck` - must pass with zero errors
  2. Run `npm run electron:dev` - app must launch
  3. Open a map - tiles must render correctly (no blank screen, no wrong tiles)
  4. Pan via right-click drag - tiles must slide smoothly, no visual glitches
  5. Zoom in/out via mouse wheel - must work at all zoom levels (0.25x to 4x)
  6. Draw with pencil tool - tile edits must appear immediately
  7. Test wall tool, line tool, fill tool, select tool - all must work
  8. Navigate to map edges (0,0 and 255,255) - no out-of-bounds errors
  </verify>
  <done>
  - BUFFER_MARGIN constant (3) defined and used in buffer bounds calculation
  - Buffer canvas sized dynamically to (viewport + margin) instead of fixed 4096x4096
  - Buffer origin tracked in bufferStateRef for correct blit coordinates
  - Incremental tile patching scopes to buffer bounds only (not entire 65K array)
  - Animation tick uses buffer-relative coordinates for tile patching
  - Viewport can pan 3 tiles before buffer rebuild is triggered
  - All existing tools and features continue working correctly
  </done>
</task>

</tasks>

<verification>
1. **Buffer zone visible:** At default zoom (1x), buffer should render ~36x26 tiles instead of 65,536. Verify by adding temporary `console.log` in drawMapLayer showing tile count rendered during full build.
2. **Smooth pan:** Right-click drag should pan smoothly. Buffer tiles slide into view without stutter. Buffer rebuilds only when pan exceeds 3 tiles from buffer center.
3. **Tile editing:** Pencil tool edits appear immediately (incremental patch within buffer bounds). No need to rebuild entire buffer for single tile change.
4. **Animation:** Animated tiles continue to animate within visible area. No flicker, no wrong frames.
5. **Zoom:** Zooming triggers buffer rebuild (different visible tile count). No visual artifacts during zoom transition.
6. **Map edges:** Pan to corners (0,0), (255,255). Buffer clamps correctly, no canvas out-of-bounds.
7. **Window resize:** ResizeObserver triggers buffer resize and full redraw correctly.
</verification>

<success_criteria>
- BUF-01: Visible tile range expanded by 3 tiles in each direction beyond viewport edges
- BUF-02: Pre-rendered buffer tiles slide into view during pan, reducing re-render frequency
- All pre-existing functionality preserved (tools, zoom, animation, scrollbars)
- Buffer memory usage proportional to viewport size (not fixed 16MB for full map)
</success_criteria>

<output>
After completion, create `.planning/phases/50-buffer-zone-over-rendering/50-01-SUMMARY.md`
</output>
