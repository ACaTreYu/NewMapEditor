---
phase: 101-canvas-background-mode-selector
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/globalSlice.ts
  - src/core/canvas/CanvasEngine.ts
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Changing canvasBackgroundMode in Zustand immediately re-renders the canvas with the correct background fill"
    - "Farplane mode shows the current patch's farplane image behind empty tile areas, scrolling correctly with viewport pan"
    - "Classic mode fills empty tile areas with #FF00FF, color mode fills with the user's chosen color"
    - "Animation ticks (blitDirtyRect path) never flash or lose the background — background is drawn between clearRect and drawImage"
    - "Background mode and color persist across app restarts via localStorage"
  artifacts:
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "canvasBackgroundMode + canvasBackgroundColor state and setters with localStorage persistence"
      contains: "canvasBackgroundMode"
    - path: "src/core/canvas/CanvasEngine.ts"
      provides: "drawScreenBackground helper, farplaneImage/customBgImage setters, bg mode subscription"
      contains: "drawScreenBackground"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "farplaneImage + customBgImage prop wiring to engine setters"
      contains: "setFarplaneImage"
  key_links:
    - from: "src/core/editor/slices/globalSlice.ts"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "Zustand subscription in setupSubscriptions"
      pattern: "canvasBackgroundMode.*canvasBackgroundColor"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "src/core/canvas/CanvasEngine.ts"
      via: "useEffect calling engine.setFarplaneImage/setCustomBgImage"
      pattern: "setFarplaneImage|setCustomBgImage"
---

<objective>
Add the canvas background rendering infrastructure: Zustand state for background mode and color (with localStorage persistence), CanvasEngine background drawing in both blitToScreen and blitDirtyRect paths, and prop wiring for farplane/custom images through MapCanvas.

Purpose: This is the rendering backbone — once complete, the UI dropdown (Plan 02) can immediately control the canvas background without any rendering work remaining.
Output: Working background rendering for all five modes, reactive to Zustand state changes, with no background flicker during animation ticks.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-canvas-background-mode-selector/101-RESEARCH.md
@src/core/editor/slices/globalSlice.ts
@src/core/canvas/CanvasEngine.ts
@src/components/MapCanvas/MapCanvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: GlobalSlice state + CanvasEngine background rendering</name>
  <files>src/core/editor/slices/globalSlice.ts, src/core/canvas/CanvasEngine.ts</files>
  <action>
**GlobalSlice (globalSlice.ts):**

1. Add two state fields to the `GlobalSlice` interface:
   ```typescript
   canvasBackgroundMode: string;    // 'transparent' | 'classic' | 'farplane' | 'color' | 'image'
   canvasBackgroundColor: string;   // hex color for 'color' mode
   ```

2. Add two action signatures:
   ```typescript
   setCanvasBackgroundMode: (mode: string) => void;
   setCanvasBackgroundColor: (color: string) => void;
   ```

3. In `createGlobalSlice` initial state, initialize from localStorage:
   ```typescript
   canvasBackgroundMode: localStorage.getItem('ac-editor-canvas-bg-mode') || 'transparent',
   canvasBackgroundColor: localStorage.getItem('ac-editor-canvas-bg-color') || '#000000',
   ```

4. Add action implementations that persist to localStorage:
   ```typescript
   setCanvasBackgroundMode: (mode) => {
     localStorage.setItem('ac-editor-canvas-bg-mode', mode);
     set({ canvasBackgroundMode: mode });
   },
   setCanvasBackgroundColor: (color) => {
     localStorage.setItem('ac-editor-canvas-bg-color', color);
     set({ canvasBackgroundColor: color });
   },
   ```

**CanvasEngine (CanvasEngine.ts):**

1. Add private fields after `tilesetImage`:
   ```typescript
   private farplaneImage: HTMLImageElement | null = null;
   private customBgImage: HTMLImageElement | null = null;
   private backgroundMode: string = 'transparent';
   private backgroundColor: string = '#000000';
   ```

2. Add public setter methods (follow `setTilesetImage` pattern):
   ```typescript
   setFarplaneImage(img: HTMLImageElement | null): void {
     this.farplaneImage = img;
     // Trigger re-blit if in farplane mode
     if (this.backgroundMode === 'farplane' && this.screenCtx) {
       const vp = this.getViewport(useEditorStore.getState());
       this.blitToScreen(vp, this.screenCtx.canvas.width, this.screenCtx.canvas.height);
     }
   }

   setCustomBgImage(img: HTMLImageElement | null): void {
     this.customBgImage = img;
     // Trigger re-blit if in image mode
     if (this.backgroundMode === 'image' && this.screenCtx) {
       const vp = this.getViewport(useEditorStore.getState());
       this.blitToScreen(vp, this.screenCtx.canvas.width, this.screenCtx.canvas.height);
     }
   }
   ```

3. Add `drawScreenBackground` private method. This draws the background for a screen-space rectangle. CRITICAL: draw only for in-map regions; out-of-map strips are handled by existing code.

   ```typescript
   private drawScreenBackground(
     ctx: CanvasRenderingContext2D,
     viewport: { x: number; y: number; zoom: number },
     destX: number, destY: number, destW: number, destH: number,
   ): void {
     switch (this.backgroundMode) {
       case 'transparent':
         return; // Canvas already cleared

       case 'classic':
         ctx.fillStyle = '#FF00FF';
         ctx.fillRect(destX, destY, destW, destH);
         break;

       case 'color':
         ctx.fillStyle = this.backgroundColor;
         ctx.fillRect(destX, destY, destW, destH);
         break;

       case 'farplane':
         if (!this.farplaneImage) return;
         {
           const mapPxX = destX / viewport.zoom + viewport.x * TILE_SIZE;
           const mapPxY = destY / viewport.zoom + viewport.y * TILE_SIZE;
           const mapPxW = destW / viewport.zoom;
           const mapPxH = destH / viewport.zoom;
           const FULL_MAP_PX = MAP_WIDTH * TILE_SIZE; // 4096
           const scaleX = this.farplaneImage.naturalWidth / FULL_MAP_PX;
           const scaleY = this.farplaneImage.naturalHeight / FULL_MAP_PX;
           ctx.drawImage(
             this.farplaneImage,
             mapPxX * scaleX, mapPxY * scaleY,
             mapPxW * scaleX, mapPxH * scaleY,
             destX, destY, destW, destH
           );
         }
         break;

       case 'image':
         if (!this.customBgImage) return;
         {
           const tilePixels = TILE_SIZE * viewport.zoom;
           const mapScreenW = MAP_WIDTH * tilePixels;
           const mapScreenH = MAP_HEIGHT * tilePixels;
           const mapScreenX = -viewport.x * tilePixels;
           const mapScreenY = -viewport.y * tilePixels;
           const imgSrcX = (destX - mapScreenX) / mapScreenW * this.customBgImage.naturalWidth;
           const imgSrcY = (destY - mapScreenY) / mapScreenH * this.customBgImage.naturalHeight;
           const imgSrcW = destW / mapScreenW * this.customBgImage.naturalWidth;
           const imgSrcH = destH / mapScreenH * this.customBgImage.naturalHeight;
           ctx.drawImage(
             this.customBgImage,
             imgSrcX, imgSrcY, imgSrcW, imgSrcH,
             destX, destY, destW, destH
           );
         }
         break;
     }
   }
   ```

4. **Modify `blitToScreen`:** After `screenCtx.clearRect(0, 0, canvasWidth, canvasHeight)` and BEFORE `screenCtx.drawImage(buffer, ...)`, insert the background draw for the in-map region:

   ```typescript
   // Draw canvas background for in-map region (Phase 101)
   if (this.backgroundMode !== 'transparent') {
     const tilePixels = TILE_SIZE * viewport.zoom;
     const mapLeft   = (0 - viewport.x) * tilePixels;
     const mapTop    = (0 - viewport.y) * tilePixels;
     const mapRight  = (MAP_WIDTH - viewport.x) * tilePixels;
     const mapBottom = (MAP_HEIGHT - viewport.y) * tilePixels;
     const fillX = Math.max(0, mapLeft);
     const fillY = Math.max(0, mapTop);
     const fillW = Math.min(canvasWidth, mapRight) - fillX;
     const fillH = Math.min(canvasHeight, mapBottom) - fillY;
     if (fillW > 0 && fillH > 0) {
       this.drawScreenBackground(screenCtx, viewport, fillX, fillY, fillW, fillH);
     }
   }
   ```

   This goes between the `clearRect` line and the `drawImage(buffer, ...)` line. The out-of-map strip fills remain at the END of blitToScreen, unchanged.

5. **Modify `blitDirtyRect`:** After `screenCtx.clearRect(clipX, clipY, ...)` and BEFORE `screenCtx.drawImage(buffer, ...)`, insert:

   ```typescript
   // Draw background under dirty rect (Phase 101 — prevents flicker during animation)
   if (this.backgroundMode !== 'transparent') {
     this.drawScreenBackground(screenCtx, viewport, clipX, clipY, clipR - clipX, clipB - clipY);
   }
   ```

6. **Add subscription in `setupSubscriptions`:** After the animation subscription, add:

   ```typescript
   // Subscription 4: Background mode changes (immediate re-blit)
   const unsubBgMode = useEditorStore.subscribe((state, prevState) => {
     if (state.canvasBackgroundMode !== prevState.canvasBackgroundMode ||
         state.canvasBackgroundColor !== prevState.canvasBackgroundColor) {
       this.backgroundMode = state.canvasBackgroundMode;
       this.backgroundColor = state.canvasBackgroundColor;
       if (this.screenCtx) {
         const vp = this.getViewport(state);
         this.blitToScreen(vp, this.screenCtx.canvas.width, this.screenCtx.canvas.height);
       }
     }
   });
   this.unsubscribers.push(unsubBgMode);
   ```

7. **Initialize bg fields in `attach`:** After `this.setupSubscriptions()`, read current state:
   ```typescript
   const currentState = useEditorStore.getState();
   this.backgroundMode = currentState.canvasBackgroundMode;
   this.backgroundColor = currentState.canvasBackgroundColor;
   ```

8. **Clean up in `detach`:** After setting `this.lastBlitVp = null`, add:
   ```typescript
   this.farplaneImage = null;
   this.customBgImage = null;
   ```
  </action>
  <verify>
Run `npm run typecheck` — no TypeScript errors. Verify globalSlice.ts has canvasBackgroundMode/Color with localStorage init, and CanvasEngine.ts has drawScreenBackground + blitToScreen/blitDirtyRect insertion points + bg subscription.
  </verify>
  <done>
GlobalSlice has canvasBackgroundMode and canvasBackgroundColor with localStorage persistence. CanvasEngine draws background in both blitToScreen and blitDirtyRect paths, subscribes to bg mode changes, and has setFarplaneImage/setCustomBgImage setters. Typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire farplaneImage and customBgImage props through MapCanvas</name>
  <files>src/components/MapCanvas/MapCanvas.tsx, src/components/Workspace/ChildWindow.tsx</files>
  <action>
**MapCanvas.tsx:**

1. Add `farplaneImage` and `customBgImage` to the `Props` interface:
   ```typescript
   interface Props {
     tilesetImage: HTMLImageElement | null;
     farplaneImage?: HTMLImageElement | null;
     customBgImage?: HTMLImageElement | null;
     onCursorMove?: (x: number, y: number) => void;
     documentId?: string;
   }
   ```

2. Destructure the new props in the component:
   ```typescript
   export const MapCanvas: React.FC<Props> = ({ tilesetImage, farplaneImage, customBgImage, onCursorMove, documentId }) => {
   ```

3. In the engine mount useEffect (the one that creates `new CanvasEngine()` and calls `engine.attach`), after the existing `if (tilesetImage) engine.setTilesetImage(tilesetImage)` line, add:
   ```typescript
   if (farplaneImage) engine.setFarplaneImage(farplaneImage);
   if (customBgImage) engine.setCustomBgImage(customBgImage);
   ```

4. Add a useEffect for farplaneImage changes (mirror the existing tilesetImage useEffect pattern):
   ```typescript
   useEffect(() => {
     engineRef.current?.setFarplaneImage(farplaneImage ?? null);
   }, [farplaneImage]);
   ```

5. Add a useEffect for customBgImage changes:
   ```typescript
   useEffect(() => {
     engineRef.current?.setCustomBgImage(customBgImage ?? null);
   }, [customBgImage]);
   ```

**ChildWindow.tsx:**

6. The ChildWindow component renders `<MapCanvas tilesetImage={tilesetImage} ...>`. Add the new props:
   - Find the ChildWindow's Props interface and add `farplaneImage?: HTMLImageElement | null` and `customBgImage?: HTMLImageElement | null`
   - Pass them through to `<MapCanvas farplaneImage={farplaneImage} customBgImage={customBgImage} ...>`
   - Note: These will be wired from App.tsx in Plan 02. For now, they are optional props defaulting to undefined/null, which is safe — the engine setters handle null gracefully.
  </action>
  <verify>
Run `npm run typecheck` — no TypeScript errors. Verify MapCanvas accepts farplaneImage + customBgImage props and wires them to engine setters via useEffect.
  </verify>
  <done>
MapCanvas and ChildWindow accept farplaneImage and customBgImage optional props. MapCanvas wires them to CanvasEngine via useEffect (same pattern as tilesetImage). The engine receives image updates reactively and triggers re-blit when in the corresponding mode. Typecheck passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. GlobalSlice interface includes canvasBackgroundMode, canvasBackgroundColor, setCanvasBackgroundMode, setCanvasBackgroundColor
3. CanvasEngine has drawScreenBackground private method with all 5 mode branches
4. blitToScreen draws background after clearRect, before drawImage(buffer)
5. blitDirtyRect draws background after clearRect, before drawImage(buffer) — preventing animation flicker
6. CanvasEngine.setupSubscriptions has bg mode subscription triggering blitToScreen
7. MapCanvas.tsx Props interface includes farplaneImage and customBgImage
8. localStorage keys 'ac-editor-canvas-bg-mode' and 'ac-editor-canvas-bg-color' are read on init and written on change
</verification>

<success_criteria>
- TypeScript compiles with no errors
- All five background modes are implemented in CanvasEngine.drawScreenBackground
- Background renders in both blitToScreen and blitDirtyRect code paths
- farplaneImage and customBgImage can be passed through MapCanvas to CanvasEngine
- Background mode and color persist via localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/101-canvas-background-mode-selector/101-01-SUMMARY.md`
</output>
