---
phase: 06-smart-crop-and-export-modes
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - ac-map-render/src/core/store.ts
  - ac-map-render/src/components/ExportControls/ExportControls.tsx
  - ac-map-render/src/components/ExportControls/ExportControls.css
autonomous: true

must_haves:
  truths:
    - "User can toggle export mode between full, cropped, and both -- and the correct file(s) are produced on disk"
    - "User can toggle transparent background on/off and the exported PNG reflects the choice (no farplane when on)"
    - "When export mode is 'cropped' or 'both', the BFS smart crop runs and excludes holding pen areas"
    - "When export mode is 'both', two files are written: {name} - {patch}.png (full) and {name} - {patch}_cropped.png"
    - "Export mode and transparent background preferences persist across sessions via localStorage"
  artifacts:
    - path: "ac-map-render/src/core/store.ts"
      provides: "ExportMode type, exportMode/transparentBackground state, cachedTileset/cachedFarplane asset refs, updated exportCurrentRender with smart crop and transparency"
      contains: "ExportMode"
    - path: "ac-map-render/src/components/ExportControls/ExportControls.tsx"
      provides: "Export mode selector (full/cropped/both) and transparent background checkbox"
      contains: "exportMode"
    - path: "ac-map-render/src/components/ExportControls/ExportControls.css"
      provides: "Styling for new export mode controls"
      contains: "export-mode"
  key_links:
    - from: "ac-map-render/src/core/store.ts"
      to: "ac-map-render/src/core/smart-crop.ts"
      via: "findMainAreaBounds() called during export when mode is cropped/both"
      pattern: "import.*findMainAreaBounds.*from.*smart-crop"
    - from: "ac-map-render/src/core/store.ts"
      to: "ac-map-render/src/core/export-renderer.ts"
      via: "renderExportCanvas() replaces direct canvas.toBlob on renderedCanvas"
      pattern: "import.*renderExportCanvas.*from.*export-renderer"
    - from: "ac-map-render/src/components/ExportControls/ExportControls.tsx"
      to: "ac-map-render/src/core/store.ts"
      via: "Zustand selectors for exportMode, transparentBackground, setExportMode, setTransparentBackground"
      pattern: "useAppStore.*exportMode"
---

<objective>
Wire the smart crop and export rendering into the store and UI, giving users export mode selection (full/cropped/both) and transparent background toggle.

Purpose: This plan connects the pure algorithm (Plan 01) to the existing export pipeline and UI, completing the Phase 6 feature set. After this plan, users have full control over export modes and transparent backgrounds.

Output: Updated store with multi-mode export logic, updated ExportControls with mode selector and transparency checkbox.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-smart-crop-and-export-modes/06-RESEARCH.md
@.planning/phases/06-smart-crop-and-export-modes/06-01-SUMMARY.md
@.planning/phases/05-single-export/05-01-SUMMARY.md
@ac-map-render/src/core/store.ts
@ac-map-render/src/components/ExportControls/ExportControls.tsx
@ac-map-render/src/components/ExportControls/ExportControls.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update store with export mode state and multi-mode export pipeline</name>
  <files>ac-map-render/src/core/store.ts</files>
  <action>
Extend the store with export mode and transparent background state, and rewrite `exportCurrentRender` to support all three export modes using the smart crop and export renderer from Plan 01.

**New imports:**
```typescript
import { findMainAreaBounds } from '@core/smart-crop';
import { renderExportCanvas } from '@core/export-renderer';
```

**New types (define above AppState):**
```typescript
type ExportMode = 'full' | 'cropped' | 'both';
```

**New state fields in AppState interface:**
```typescript
exportMode: ExportMode;
transparentBackground: boolean;
setExportMode: (mode: ExportMode) => void;
setTransparentBackground: (value: boolean) => void;
```

**Initial state:**
```typescript
exportMode: (localStorage.getItem('ac-render-export-mode') as ExportMode) || 'full',
transparentBackground: localStorage.getItem('ac-render-transparent-bg') === 'true',
```

**Setters:**
```typescript
setExportMode: (mode) => {
  localStorage.setItem('ac-render-export-mode', mode);
  set({ exportMode: mode });
},
setTransparentBackground: (value) => {
  localStorage.setItem('ac-render-transparent-bg', String(value));
  set({ transparentBackground: value });
},
```

**RenderAssets access strategy (CRITICAL):**

The current codebase holds `tilesetImage` and `farplaneImage` in React component state (App.tsx), NOT in the Zustand store. The `exportCurrentRender` function runs inside the store and needs access to these images to call `renderExportCanvas()`.

**Approach: Cache render assets in the store.** Add two new state fields:
```typescript
// Non-serializable transient state (not persisted)
cachedTileset: HTMLImageElement | null;
cachedFarplane: HTMLImageElement | null;
setCachedAssets: (tileset: HTMLImageElement | null, farplane: HTMLImageElement | null) => void;
```

Then in `App.tsx` (or the component that loads patch images), call `setCachedAssets(tilesetImage, farplaneImage)` whenever tileset or farplane changes. This is a lightweight sync -- just storing image element references, not copying pixel data.

Inside `exportCurrentRender`, read `cachedTileset` and `cachedFarplane` from `get()` state. If `cachedTileset` is null, set export error "No tileset loaded" and return. Build the assets object: `{ tileset: cachedTileset, farplane: transparent ? null : cachedFarplane }`.

**Rewrite `exportCurrentRender`:**

The export pipeline changes significantly. Instead of using the existing `renderedCanvas` from the store (which is the preview canvas), it now renders fresh export canvases using `renderExportCanvas()`.

Steps:
1. Check preconditions: `tiles` and `mapFileName` must exist. `cachedTileset` must be non-null (error if not). If no `outputDir`, auto-prompt via `chooseOutputDir`.
2. Set `isExporting: true`.
3. Build assets from cached state: `const assets = { tileset: get().cachedTileset!, farplane: get().cachedFarplane }`. No re-loading needed -- the images are already cached from display rendering.
4. Determine what to export based on `exportMode`:

   **Mode 'full':**
   - Call `renderExportCanvas(tiles, assets, null, transparentBackground)` -- null bounds = full map.
   - Export as `buildExportFileName(mapFileName, selectedPatch)` (same as before).

   **Mode 'cropped':**
   - Call `findMainAreaBounds(tiles)` to get smart crop bounds.
   - If `paddedBounds` is null (empty map), set export error "No content to crop" and return.
   - Call `renderExportCanvas(tiles, assets, paddedBounds, transparentBackground)`.
   - Export as `buildExportFileName(mapFileName, selectedPatch)` (same filename -- when mode is cropped-only, the user just gets the cropped version with the normal name).

   **Mode 'both':**
   - Render and export FULL first, then dispose:
     - `renderExportCanvas(tiles, assets, null, transparentBackground)` -> blob -> base64 -> writePng
     - Filename: `buildExportFileName(mapFileName, selectedPatch)` (normal name for full)
   - Then render and export CROPPED:
     - `findMainAreaBounds(tiles)` to get bounds
     - `renderExportCanvas(tiles, assets, paddedBounds, transparentBackground)` -> blob -> base64 -> writePng
     - Filename: `buildCroppedExportFileName(mapFileName, selectedPatch)` -- new helper

   **IMPORTANT memory pattern for 'both' mode:** Render one canvas, export it (toBlob + base64 + IPC), then let it be GC'd before creating the second canvas. Never hold two 4096x4096 canvases simultaneously. Achieve this by awaiting each export step fully before starting the next.

5. Add a new utility function:
```typescript
function buildCroppedExportFileName(mapFileName: string, patchName: string): string {
  const baseName = mapFileName.replace(/\.map$/i, '');
  return `${baseName} - ${patchName}_cropped.png`;
}
```

6. Update `lastExportPath` to show the last file written (for 'both' mode, show the second file or a combined message). For simplicity, on 'both' mode set `lastExportPath` to a string like `"2 files exported"` instead of a single path.

7. Export the `ExportMode` type so ExportControls can use it.

**Do NOT change:** `loadMap`, `clearMap`, `renderCurrentMap`, `loadFallbackTileset`, `chooseOutputDir`, `clearExportStatus`, `setSelectedPatch`. These remain untouched.
  </action>
  <verify>TypeScript compiles clean: `cd ac-map-render && npx tsc --noEmit`.</verify>
  <done>exportCurrentRender handles full/cropped/both modes using renderExportCanvas and findMainAreaBounds. Export mode and transparent bg persist in localStorage. 'both' mode exports two files sequentially without holding two large canvases simultaneously.</done>
</task>

<task type="auto">
  <name>Task 2: Update ExportControls UI with mode selector and transparency toggle</name>
  <files>
    ac-map-render/src/components/ExportControls/ExportControls.tsx
    ac-map-render/src/components/ExportControls/ExportControls.css
  </files>
  <action>
Update ExportControls to add export mode selection and transparent background toggle.

**ExportControls.tsx changes:**

1. Add new Zustand selectors:
```typescript
const exportMode = useAppStore((s) => s.exportMode);
const transparentBackground = useAppStore((s) => s.transparentBackground);
const setExportMode = useAppStore((s) => s.setExportMode);
const setTransparentBackground = useAppStore((s) => s.setTransparentBackground);
```

2. Add an export mode selector -- use a native `<select>` element (consistent with the app's minimal UI approach, no custom dropdowns):
```tsx
<select
  className="export-mode-select"
  value={exportMode}
  onChange={(e) => setExportMode(e.target.value as ExportMode)}
>
  <option value="full">Full</option>
  <option value="cropped">Cropped</option>
  <option value="both">Both</option>
</select>
```

3. Add a transparent background checkbox:
```tsx
<label className="export-transparent-label" title="Export with transparent background (no farplane)">
  <input
    type="checkbox"
    checked={transparentBackground}
    onChange={(e) => setTransparentBackground(e.target.checked)}
  />
  Transparent
</label>
```

4. Update the Export button text to reflect mode:
   - 'full': "Export PNG"
   - 'cropped': "Export Cropped"
   - 'both': "Export Both"

5. Layout order in the component (left to right):
   - Directory button (existing)
   - Mode selector (`<select>`)
   - Transparent checkbox
   - Export button (existing, with updated text)
   - Status message (existing)

Import ExportMode type from `@core/store` (or define inline if needed).

**ExportControls.css changes:**

Add styles for the new controls:

```css
.export-mode-select {
  background: var(--bg-surface);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  padding: var(--space-0_5) var(--space-1);
  font-size: var(--font-size-xs);
  color: var(--text-primary);
  cursor: pointer;
}

.export-transparent-label {
  display: flex;
  align-items: center;
  gap: var(--space-0_5);
  font-size: var(--font-size-xs);
  color: var(--text-secondary);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

.export-transparent-label input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}
```

Keep the existing styles for `.export-controls`, `.export-dir-btn`, `.export-btn`, `.export-status`, etc. Do not remove or rewrite them.
  </action>
  <verify>TypeScript compiles clean: `cd ac-map-render && npx tsc --noEmit`. Vite dev build succeeds: `cd ac-map-render && npx vite build`. Verify ExportControls.tsx contains: (1) a `<select>` element with value bound to `exportMode`, (2) an `<input type="checkbox">` bound to `transparentBackground`, (3) button text that varies by export mode.</verify>
  <done>ExportControls shows mode selector (Full/Cropped/Both) and transparent background checkbox. Export button text updates based on mode ('Export PNG' / 'Export Cropped' / 'Export Both'). All controls use Zustand fine-grained selectors. Styles use existing design tokens (--bg-surface, --border-default, --font-size-xs). Mode selector and checkbox are positioned between directory button and export button. ExportControls.css contains .export-mode-select and .export-transparent-label classes using existing design tokens.</done>
</task>

</tasks>

<verification>
1. `cd ac-map-render && npx tsc --noEmit` -- zero errors
2. `cd ac-map-render && npx vite build` -- production build succeeds
3. Store exports ExportMode type
4. ExportControls renders mode selector and transparency checkbox
5. exportCurrentRender handles all three modes (full, cropped, both)
6. localStorage keys: `ac-render-export-mode`, `ac-render-transparent-bg`
7. 'both' mode produces two files: normal name + `_cropped` suffix
</verification>

<success_criteria>
- Export mode toggle works (full/cropped/both) with correct file output per mode
- Transparent background toggle produces alpha-channel PNGs without farplane
- Smart crop BFS excludes holding pens matching Python reference behavior
- All preferences persist across sessions via localStorage
- Production build succeeds with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-crop-and-export-modes/06-02-SUMMARY.md`
</output>
