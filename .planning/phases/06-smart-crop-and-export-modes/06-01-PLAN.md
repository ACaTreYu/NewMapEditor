---
phase: 06-smart-crop-and-export-modes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ac-map-render/src/core/smart-crop.ts
  - ac-map-render/src/core/export-renderer.ts
autonomous: true

must_haves:
  truths:
    - "findMainAreaBounds() identifies the largest cluster as the main play area and excludes distant clusters as holding pens"
    - "isContentTile() returns false for tile 0, tile 280, and tile 0xFFFF -- matching the Python reference"
    - "BFS flood-fill uses iterative queue (not recursion) and handles 65536-tile maps without stack overflow"
    - "Clusters with fewer than 10 tiles are discarded (min_cluster_size=10, matching Python reference)"
    - "Crop bounds include CROP_PADDING of 2 tiles, clamped to 0..255"
    - "renderExportCanvas() produces a correctly-sized canvas for arbitrary bounds with optional transparent background"
  artifacts:
    - path: "ac-map-render/src/core/smart-crop.ts"
      provides: "BFS flood-fill cluster detection, distance-based holding pen exclusion, crop bounds with padding"
      exports: ["findMainAreaBounds", "isContentTile", "SmartCropResult", "Bounds"]
    - path: "ac-map-render/src/core/export-renderer.ts"
      provides: "Off-screen export canvas rendering with bounds cropping and transparent background support"
      exports: ["renderExportCanvas"]
  key_links:
    - from: "ac-map-render/src/core/smart-crop.ts"
      to: "ac-map-render/src/core/types.ts"
      via: "MAP_WIDTH, MAP_HEIGHT constants"
      pattern: "import.*MAP_WIDTH.*from.*types"
    - from: "ac-map-render/src/core/export-renderer.ts"
      to: "ac-map-render/src/core/animation-table.ts"
      via: "Imports ANIMATION_DEFINITIONS, TRANSPARENT_TILES for inline tile rendering (duplicates CanvasEngine.renderTile logic as a standalone loop -- approach B: self-contained per-tile rendering with bounds injection, not refactoring CanvasEngine)"
      pattern: "import.*ANIMATION_DEFINITIONS.*from.*animation"
---

<objective>
Port the BFS smart crop algorithm from the Python reference and create the export rendering function with bounds/transparency support.

Purpose: These are the two core algorithmic pieces needed for Phase 6 -- the smart crop detection (pure data logic) and the export canvas renderer (pure rendering logic). Both are stateless functions with well-defined inputs/outputs, ideal for TDD.

Output: `smart-crop.ts` with BFS cluster detection and holding pen exclusion, `export-renderer.ts` with bounded/transparent canvas rendering.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-smart-crop-and-export-modes/06-RESEARCH.md
@.planning/phases/03-tile-rendering-engine/03-01-SUMMARY.md
@.planning/phases/05-single-export/05-01-SUMMARY.md
@ac-map-render/src/core/types.ts
@ac-map-render/src/core/animation-table.ts
@src/core/canvas/CanvasEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BFS smart crop algorithm</name>
  <files>ac-map-render/src/core/smart-crop.ts</files>
  <action>
Create `src/core/smart-crop.ts` as a pure function module porting the Python BFS flood-fill logic from `D:\ac-tools\AC_Map_Render-main\scripts\map_render_core.py` lines 103-250.

**Constants:**
- `CROP_PADDING = 2` (tiles of padding around crop bounds, matching Python)
- `DISTANCE_THRESHOLD = 30` (max tile-distance to include a cluster near the main area)
- `MIN_CLUSTER_SIZE = 10` (ignore tiny clusters)

**Types:**
```typescript
export interface Bounds {
  minX: number; minY: number; maxX: number; maxY: number;
}

export interface SmartCropResult {
  allBounds: Bounds | null;       // Bounding box of ALL content tiles
  mainBounds: Bounds | null;      // Bounding box after excluding holding pens
  excludedClusters: number;       // Count of excluded distant clusters
  paddedBounds: Bounds | null;    // mainBounds + CROP_PADDING, clamped to 0..255
}
```

**Functions to implement:**

1. `isContentTile(tid: number): boolean` -- Returns false for tile 0, tiles in TRANSPARENT_TILES (280, 0xFFFF). Import TRANSPARENT_TILES from `animation-table.ts`. Match Python `is_content_tile()` exactly.

2. `findClusters(tiles: Uint16Array, minClusterSize = MIN_CLUSTER_SIZE): Set<number>[]` -- Iterative BFS flood-fill with 4-directional connectivity. Use a flat index (y * MAP_WIDTH + x) to avoid (x,y) tuple overhead. Use an array-as-queue with head pointer (not Array.shift() which is O(n)). Return clusters sorted by size (largest first). Import MAP_WIDTH, MAP_HEIGHT from types.ts.

3. `getClusterBounds(cluster: Set<number>): Bounds | null` -- Convert flat indices back to (x,y) and find min/max. Return null for empty sets.

4. `addPadding(bounds: Bounds, padding = CROP_PADDING): Bounds` -- Add padding tiles, clamped: `max(0, minX - padding)`, `min(MAP_WIDTH - 1, maxX + padding)`, same for Y with MAP_HEIGHT.

5. `findMainAreaBounds(tiles: Uint16Array, distanceThreshold = DISTANCE_THRESHOLD): SmartCropResult` -- The main entry point. Calls findClusters, identifies largest as main area, includes nearby clusters within distanceThreshold (using distance from cluster center to nearest edge of main bounds, matching Python formula), excludes distant ones. Returns SmartCropResult with allBounds, mainBounds, excludedClusters count, and paddedBounds.

**Critical matching details vs Python reference:**
- Distance calculation: `cx = (clusterBounds.minX + clusterBounds.maxX) / 2`, `cy = (clusterBounds.minY + clusterBounds.maxY) / 2`, then `dx = max(mainBounds.minX - cx, 0, cx - mainBounds.maxX)`, `dy = max(mainBounds.minY - cy, 0, cy - mainBounds.maxY)`, `distance = sqrt(dx*dx + dy*dy)`.
- Single cluster case: return that cluster's bounds with excludedClusters = 0.
- No clusters: return all nulls with excludedClusters = 0.
- allBounds is the union of ALL clusters (before exclusion).

Do NOT import anything from tile-renderer.ts. This module must be pure data logic with zero rendering dependencies.
  </action>
  <verify>TypeScript compiles clean: `cd ac-map-render && npx tsc --noEmit`. All exports are importable.</verify>
  <done>smart-crop.ts exports findMainAreaBounds, isContentTile, Bounds, SmartCropResult. BFS uses iterative queue. Constants match Python reference (CROP_PADDING=2, DISTANCE_THRESHOLD=30, MIN_CLUSTER_SIZE=10).</done>
</task>

<task type="auto">
  <name>Task 2: Create export rendering function with bounds and transparency support</name>
  <files>ac-map-render/src/core/export-renderer.ts</files>
  <action>
Create `src/core/export-renderer.ts` that renders a map to an off-screen canvas with support for arbitrary bounds (for cropped export) and transparent backgrounds.

**Function signature:**
```typescript
export function renderExportCanvas(
  tiles: Uint16Array,
  assets: RenderAssets,
  bounds: Bounds | null,     // null = full 256x256 map
  transparent: boolean        // true = no farplane, transparent background
): HTMLCanvasElement
```

**Implementation:**

1. **Determine render region:**
   - If bounds is null: render full map (0,0) to (MAP_WIDTH-1, MAP_HEIGHT-1).
   - If bounds provided: use bounds.minX/minY/maxX/maxY directly (these already have padding applied from SmartCropResult.paddedBounds).

2. **Create output canvas:**
   - Width: `(maxX - minX + 1) * TILE_SIZE`
   - Height: `(maxY - minY + 1) * TILE_SIZE`
   - Set `ctx.imageSmoothingEnabled = false`

3. **Background layer:**
   - If `!transparent && assets.farplane`: Scale farplane to full 4096x4096, then drawImage with source rect matching the crop bounds. Source rect: `(minX * TILE_SIZE, minY * TILE_SIZE, width, height)`. This matches the Python pattern: `fp_resized = farplane.resize((MAP_W * TILE_SIZE, MAP_H * TILE_SIZE)); out_img = fp_resized.crop(crop_box)`. Use `ctx.drawImage(farplane, 0, 0, 4096, 4096)` on a temp canvas, then copy the subregion -- OR use the 9-arg drawImage to extract the correct portion by computing source coordinates from the farplane's natural dimensions.
   - If `transparent`: leave canvas transparent (default RGBA 0,0,0,0). Do NOT call `ctx.clearRect` (it's already clear).

4. **Tile rendering loop (approach B -- self-contained per-tile rendering):**
   - The existing tile rendering logic lives in `CanvasEngine.renderTile()` (an instance method coupled to display state). Rather than refactoring CanvasEngine, export-renderer.ts implements its own per-tile rendering loop inline. This duplicates ~30 lines of tile rendering logic but keeps export-renderer.ts fully self-contained with no dependency on the display engine class.
   - Iterate `y` from `minY` to `maxY`, `x` from `minX` to `maxX`.
   - For each tile: resolve animations using ANIMATION_DEFINITIONS (check `tile & 0x8000`, extract animId = `tile & 0xFF`, resolve to frame-0 static tile), skip transparent tiles (tile 0, 280, 0xFFFF), compute source coordinates from tileset (`srcX = (tile % TILES_PER_ROW) * TILE_SIZE`, `srcY = Math.floor(tile / TILES_PER_ROW) * TILE_SIZE`). This logic MUST match `CanvasEngine.renderTile()` behavior exactly. Read CanvasEngine.ts lines 119-156 as the reference implementation.
   - Destination coordinates offset by minX/minY: `dx = (x - minX) * TILE_SIZE`, `dy = (y - minY) * TILE_SIZE`.

5. **Farplane cropping approach (IMPORTANT):**
   The farplane image is typically small (e.g., 640x480) and needs to be scaled to 4096x4096 before extracting the crop region. Use a temporary canvas approach:
   ```
   const fpCanvas = document.createElement('canvas');
   fpCanvas.width = MAP_WIDTH * TILE_SIZE;  // 4096
   fpCanvas.height = MAP_HEIGHT * TILE_SIZE; // 4096
   fpCtx.drawImage(farplane, 0, 0, 4096, 4096);
   // Then copy the correct sub-region to the export canvas:
   ctx.drawImage(fpCanvas, minX*TILE_SIZE, minY*TILE_SIZE, width, height, 0, 0, width, height);
   ```
   This avoids complex source rect math on the unscaled farplane and matches the Python `fp_resized.crop()` approach.

Import Bounds from `./smart-crop`, TILE_SIZE/MAP_WIDTH/MAP_HEIGHT from `@core/map`, ANIMATION_DEFINITIONS from `@core/map/AnimationDefinitions`. Define `TILES_PER_ROW = 40` locally (same as CanvasEngine). Define a local `RenderAssets` interface or import from types if available: `{ tileset: HTMLImageElement; farplane: HTMLImageElement | null }`.

Do NOT import from CanvasEngine -- export-renderer.ts must be a standalone pure function with no class dependencies. DO import animation constants from existing modules rather than duplicating data.
  </action>
  <verify>TypeScript compiles clean: `cd ac-map-render && npx tsc --noEmit`. The function is importable from `@core/export-renderer`.</verify>
  <done>renderExportCanvas() produces correctly-sized canvas for full map (4096x4096) and arbitrary bounds. Transparent mode omits farplane. Farplane correctly scaled-then-cropped for bounded exports. Animation resolution and collision fallback match renderMap() behavior.</done>
</task>

</tasks>

<verification>
1. `cd ac-map-render && npx tsc --noEmit` -- zero errors
2. smart-crop.ts exports: findMainAreaBounds, isContentTile, Bounds, SmartCropResult
3. export-renderer.ts exports: renderExportCanvas
4. No circular imports between modules
5. Constants match Python: CROP_PADDING=2, DISTANCE_THRESHOLD=30, MIN_CLUSTER_SIZE=10
</verification>

<success_criteria>
- BFS smart crop algorithm is a pure function module with zero rendering dependencies
- Export renderer produces correctly-sized canvases with bounds support and transparent background option
- Both modules compile cleanly and are ready for store integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-crop-and-export-modes/06-01-SUMMARY.md`
</output>
