---
phase: 47-ui-cleanup-scrollbar-math-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Minimap/Minimap.tsx
  - src/components/Minimap/Minimap.css
  - src/components/MapCanvas/MapCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Minimap empty state shows checkerboard pattern only, no text label"
    - "Scrollbar thumb size shrinks proportionally as zoom increases (viewport covers less of map)"
    - "Scrollbar thumb reaches the end of track when viewport is scrolled to maximum offset"
    - "Dragging scrollbar thumb to end of track scrolls viewport to end of map content"
    - "Scrollbar thumb position updates immediately when viewport changes via zoom wheel, minimap click, or keyboard"
  artifacts:
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "Empty state without text label"
      contains: "no minimap-empty-label JSX"
    - path: "src/components/Minimap/Minimap.css"
      provides: "No empty label CSS rule"
      contains: "no .minimap-empty-label rule"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Correct scrollbar metrics and drag handler"
      contains: "maxOffset.*MAP_WIDTH.*visibleTiles"
  key_links:
    - from: "getScrollMetrics()"
      to: "scroll-thumb-h/v style bindings"
      via: "pixel values returned directly, used in inline style"
      pattern: "thumbLeft.*px|thumbTop.*px|thumbWidth.*px|thumbHeight.*px"
    - from: "handleScrollMouseMove()"
      to: "setViewport()"
      via: "scrollableRange-based delta calculation"
      pattern: "scrollableRange|trackSize.*thumbSize"
    - from: "viewport state changes"
      to: "getScrollMetrics() re-evaluation"
      via: "React re-render from Zustand viewport selector"
      pattern: "useCallback.*\\[viewport\\]"
---

<objective>
Remove the minimap empty state text label and fix all scrollbar thumb math (size, position, drag sensitivity, track click detection, scroll clamping) to use standard formulas.

Purpose: The minimap shows a redundant "Minimap" text label over the checkerboard empty state. Scrollbar thumb size/position use approximate formulas that break at various zoom levels -- thumb doesn't reach track ends, drag sensitivity is wrong, and clamping uses hardcoded values instead of dynamic viewport-based maxOffset.

Output: Clean minimap empty state; scrollbar thumb that accurately reflects viewport-to-map ratio, positions correctly using offset/maxOffset formula, and drags with proper sensitivity at all zoom levels.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-ui-cleanup-scrollbar-math-fix/47-RESEARCH.md
@src/components/Minimap/Minimap.tsx
@src/components/Minimap/Minimap.css
@src/components/MapCanvas/MapCanvas.tsx
@src/components/MapCanvas/MapCanvas.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove minimap empty state text label</name>
  <files>
    src/components/Minimap/Minimap.tsx
    src/components/Minimap/Minimap.css
  </files>
  <action>
    In Minimap.tsx, delete the conditional JSX block that renders the "Minimap" text label when no map is loaded. This is at approximately line 484-486:
    ```tsx
    {!map && (
      <div className="minimap-empty-label">Minimap</div>
    )}
    ```
    Delete these 3 lines entirely. The checkerboard pattern already renders in the canvas when no map is loaded (drawn in the useEffect around line 287-295), providing a sufficient empty state indicator.

    In Minimap.css, delete the `.minimap-empty-label` CSS rule block (approximately lines 18-28):
    ```css
    .minimap-empty-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--text-primary);
      font-size: var(--font-size-base);
      pointer-events: none;
      user-select: none;
      font-weight: 500;
    }
    ```
    Delete this entire rule block.
  </action>
  <verify>
    1. Grep for "minimap-empty-label" in both Minimap.tsx and Minimap.css -- should return zero results
    2. Grep for "Minimap" string literal in Minimap.tsx -- should only appear in import/component name, not as a user-visible label
    3. `npm run typecheck` passes
  </verify>
  <done>
    Minimap empty state shows only the checkerboard canvas pattern with no text overlay. The string "Minimap" does not appear as rendered UI text anywhere.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix scrollbar thumb math (size, position, drag, track click, clamping)</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
    This task fixes 5 interconnected scrollbar math issues in MapCanvas.tsx. All changes use the standard scrollbar formulas from Windows/WPF documentation.

    **2a. Rewrite `getScrollMetrics()` (around line 685-699)**

    Replace the current percentage-based implementation with pixel-based standard formulas:

    ```typescript
    const getScrollMetrics = useCallback(() => {
      const canvas = gridLayerRef.current;
      if (!canvas) return { thumbWidth: 20, thumbHeight: 20, thumbLeft: 10, thumbTop: 10 };

      const tilePixels = TILE_SIZE * viewport.zoom;
      const visibleTilesX = canvas.width / tilePixels;
      const visibleTilesY = canvas.height / tilePixels;

      // Maximum scrollable offset (0 when viewport covers entire map)
      const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTilesX);
      const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTilesY);

      // Track size in pixels (track element size minus two 10px arrow buttons)
      // Horizontal track: canvas.width - 10px (vertical scrollbar width) - 20px (arrows)
      // Vertical track: canvas.height - 10px (horizontal scrollbar height) - 20px (arrows)
      const trackWidthPx = canvas.width - 10 - 20;
      const trackHeightPx = canvas.height - 10 - 20;

      // Thumb size: proportional to viewport-to-map ratio, minimum 20px
      const thumbWidthPx = Math.max(20, (visibleTilesX / MAP_WIDTH) * trackWidthPx);
      const thumbHeightPx = Math.max(20, (visibleTilesY / MAP_HEIGHT) * trackHeightPx);

      // Scrollable range: track minus thumb (space available for thumb movement)
      const scrollableRangeX = trackWidthPx - thumbWidthPx;
      const scrollableRangeY = trackHeightPx - thumbHeightPx;

      // Thumb position: (offset / maxOffset) * scrollableRange + arrow offset
      const thumbLeftPx = maxOffsetX > 0
        ? (viewport.x / maxOffsetX) * scrollableRangeX + 10
        : 10;
      const thumbTopPx = maxOffsetY > 0
        ? (viewport.y / maxOffsetY) * scrollableRangeY + 10
        : 10;

      return {
        thumbWidth: thumbWidthPx,
        thumbHeight: thumbHeightPx,
        thumbLeft: thumbLeftPx,
        thumbTop: thumbTopPx
      };
    }, [viewport]);
    ```

    Key differences from current code:
    - Returns pixel values, not percentages
    - Uses `maxOffset = MAP_SIZE - visibleTiles` (not raw MAP_SIZE) for position
    - Accounts for arrow buttons (10px each = 20px) and opposite scrollbar (10px) in track size
    - Position formula: `(offset / maxOffset) * scrollableRange + arrowOffset`

    **2b. Update scrollbar JSX style bindings (around lines 1323-1351)**

    Replace the complex CSS `calc()` expressions with simple pixel values:

    For horizontal thumb (around line 1324-1326):
    ```tsx
    style={{
      left: `${scrollMetrics.thumbLeft}px`,
      width: `${scrollMetrics.thumbWidth}px`
    }}
    ```

    For vertical thumb (around line 1349-1351):
    ```tsx
    style={{
      top: `${scrollMetrics.thumbTop}px`,
      height: `${scrollMetrics.thumbHeight}px`
    }}
    ```

    **2c. Fix `handleScrollMouseMove()` drag sensitivity (around lines 1119-1136)**

    Replace the current implementation that divides by full trackSize with one that divides by scrollableRange:

    ```typescript
    const handleScrollMouseMove = useCallback((e: MouseEvent) => {
      if (!scrollDrag) return;
      const canvas = gridLayerRef.current;
      if (!canvas) return;

      const axis = scrollDrag.axis;
      const tilePixels = TILE_SIZE * viewport.zoom;

      const visibleTiles = axis === 'h'
        ? canvas.width / tilePixels
        : canvas.height / tilePixels;
      const mapSize = axis === 'h' ? MAP_WIDTH : MAP_HEIGHT;
      const maxOffset = Math.max(0, mapSize - visibleTiles);

      if (maxOffset === 0) return;

      // Track size minus arrow buttons and opposite scrollbar
      const trackSizePx = (axis === 'h' ? canvas.width : canvas.height) - 10 - 20;
      const thumbSizePx = Math.max(20, (visibleTiles / mapSize) * trackSizePx);
      const scrollableRangePx = trackSizePx - thumbSizePx;

      if (scrollableRangePx <= 0) return;

      const pixelDelta = (axis === 'h' ? e.clientX : e.clientY) - scrollDrag.startPos;
      const viewportDelta = (pixelDelta / scrollableRangePx) * maxOffset;
      const newOffset = Math.max(0, Math.min(maxOffset, scrollDrag.startViewport + viewportDelta));

      if (axis === 'h') {
        setViewport({ x: newOffset });
      } else {
        setViewport({ y: newOffset });
      }
    }, [scrollDrag, viewport.zoom, setViewport]);
    ```

    Key changes:
    - Uses `gridLayerRef.current` (canvas) instead of `containerRef.current` (div)
    - Calculates `scrollableRange = trackSize - thumbSize` and divides by that
    - Clamps to `maxOffset` (dynamic) instead of `MAP_SIZE - 10` (hardcoded)
    - Added `viewport.zoom` to dependency array (needed for visibleTiles calculation)

    **2d. Fix `handleTrackClick()` thumb position detection (around lines 747-787)**

    The track click handler detects whether the click is before or after the thumb to page up/down. Update the thumb position calculation to use the same standard formula:

    For horizontal axis (around line 768):
    Replace: `const thumbLeft = (viewport.x / MAP_WIDTH) * (trackRect.width - 20);`
    With:
    ```typescript
    const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTiles);
    const trackWidthPx = trackRect.width - 20;
    const thumbWidthPx = Math.max(20, (visibleTiles / MAP_WIDTH) * trackWidthPx);
    const scrollableRangeX = trackWidthPx - thumbWidthPx;
    const thumbLeft = maxOffsetX > 0 ? (viewport.x / maxOffsetX) * scrollableRangeX : 0;
    ```

    For vertical axis (around line 779):
    Replace: `const thumbTop = (viewport.y / MAP_HEIGHT) * (trackRect.height - 20);`
    With:
    ```typescript
    const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTiles);
    const trackHeightPx = trackRect.height - 20;
    const thumbHeightPx = Math.max(20, (visibleTiles / MAP_HEIGHT) * trackHeightPx);
    const scrollableRangeY = trackHeightPx - thumbHeightPx;
    const thumbTop = maxOffsetY > 0 ? (viewport.y / maxOffsetY) * scrollableRangeY : 0;
    ```

    Also update the page scroll clamping in the same function:
    - Replace `Math.min(MAP_WIDTH - visibleTiles, ...)` (already correct for h track click)
    - Replace `Math.min(MAP_HEIGHT - visibleTiles, ...)` (already correct for v track click)
    These are already using dynamic visibleTiles, so they're fine. Just verify they stay consistent.

    **2e. Fix `scrollByTiles()` clamping (around lines 701-719)**

    Replace the hardcoded `MAP_WIDTH - 10` / `MAP_HEIGHT - 10` clamp values with dynamic maxOffset based on actual visible tiles:

    ```typescript
    const scrollByTiles = useCallback((direction: 'up' | 'down' | 'left' | 'right', tiles: number) => {
      const canvas = gridLayerRef.current;
      if (!canvas) return;

      const tilePixels = TILE_SIZE * viewport.zoom;
      const visibleTilesX = canvas.width / tilePixels;
      const visibleTilesY = canvas.height / tilePixels;
      const maxOffsetX = Math.max(0, MAP_WIDTH - visibleTilesX);
      const maxOffsetY = Math.max(0, MAP_HEIGHT - visibleTilesY);

      switch (direction) {
        case 'up':
          setViewport({ y: Math.max(0, Math.min(maxOffsetY, viewport.y - tiles)) });
          break;
        case 'down':
          setViewport({ y: Math.max(0, Math.min(maxOffsetY, viewport.y + tiles)) });
          break;
        case 'left':
          setViewport({ x: Math.max(0, Math.min(maxOffsetX, viewport.x - tiles)) });
          break;
        case 'right':
          setViewport({ x: Math.max(0, Math.min(maxOffsetX, viewport.x + tiles)) });
          break;
      }
    }, [viewport, setViewport]);
    ```

    Key change: `MAP_WIDTH - 10` becomes `MAP_WIDTH - visibleTilesX` (dynamic based on canvas size and zoom).

    **Important:** Do NOT change any other scrollbar behavior (arrow button repeat timing, scroll wheel handling, etc.). Only fix the math formulas.
  </action>
  <verify>
    1. `npm run typecheck` passes with no errors
    2. Grep for `MAP_WIDTH - 10` and `MAP_HEIGHT - 10` in MapCanvas.tsx -- should return zero results (replaced with dynamic maxOffset)
    3. Grep for `* 100` in getScrollMetrics -- should return zero results (no percentage conversion)
    4. Grep for `calc(` in scrollbar thumb style bindings -- should return zero results (replaced with pixel values)
    5. Grep for `scrollableRange` in MapCanvas.tsx -- should appear in both getScrollMetrics and handleScrollMouseMove
    6. Grep for `maxOffset` in MapCanvas.tsx -- should appear in getScrollMetrics, handleScrollMouseMove, scrollByTiles, and handleTrackClick
  </verify>
  <done>
    - Scrollbar thumb size reflects viewport-to-map ratio at all zoom levels (SCROLL-01)
    - Scrollbar thumb position uses standard offset/maxOffset formula and reaches track ends correctly (SCROLL-02)
    - Scrollbar thumb drag divides by scrollableRange for correct sensitivity (SCROLL-05)
    - Track click detects thumb position using consistent formula
    - Arrow button scrolling clamps to dynamic maxOffset
    - Scrollbars update reactively when viewport changes via any source (SCROLL-04) -- already worked via React/Zustand, now with correct math
  </done>
</task>

</tasks>

<verification>
Phase-level verification:

1. **UI-01**: Open the editor with no map loaded. Minimap area shows only the checkerboard pattern -- no "Minimap" text label visible.

2. **SCROLL-01**: Open a map. Zoom to 0.25x (viewport covers most of map) -- thumb should be large, nearly filling the track. Zoom to 4x (viewport covers small area) -- thumb should be small. Thumb size should smoothly scale with zoom.

3. **SCROLL-02**: Scroll to top-left corner -- both thumbs should be at the start of their tracks (against left/top arrow buttons). Scroll to bottom-right corner -- both thumbs should be at the end of their tracks (against right/bottom arrow buttons). No gaps between thumb and arrow buttons at extremes.

4. **SCROLL-04**: Change viewport via zoom wheel -- scrollbar thumbs update. Click minimap to navigate -- scrollbar thumbs update. Use keyboard arrow keys -- scrollbar thumbs update.

5. **SCROLL-05**: Drag horizontal thumb from start to end of track -- viewport should scroll from x=0 to x=maxOffset smoothly. Repeat for vertical. Sensitivity should feel natural at both 0.25x and 4x zoom.
</verification>

<success_criteria>
- Zero TypeScript errors
- Minimap empty state has no text label
- Scrollbar thumb size is proportional to viewport/map ratio at zoom levels 0.25x, 1x, 2x, 4x
- Scrollbar thumb reaches both ends of track when viewport is at min/max scroll position
- Scrollbar thumb drag from track start to track end scrolls viewport through full content range
- No percentage-based calc() expressions in scrollbar thumb styling
- All scroll clamping uses dynamic maxOffset, not hardcoded constants
</success_criteria>

<output>
After completion, create `.planning/phases/47-ui-cleanup-scrollbar-math-fix/47-01-SUMMARY.md`
</output>
