---
phase: 42-mirror-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/map/SelectionTransforms.ts
  - src/core/map/types.ts
  - src/core/editor/slices/documentsSlice.ts
  - src/components/ToolBar/ToolBar.tsx
  - public/assets/toolbar/mirror.svg
autonomous: true

must_haves:
  truths:
    - "User can mirror selection rightward -- mirrored copy appears adjacent to the right of the original"
    - "User can mirror selection leftward -- mirrored copy appears adjacent to the left of the original"
    - "User can mirror selection upward -- mirrored copy appears above the original"
    - "User can mirror selection downward -- mirrored copy appears below the original"
    - "Mirror toolbar button appears with dropdown listing all 4 directions (Right, Left, Up, Down)"
    - "Original selection remains intact after mirror -- only the adjacent copy is new"
    - "Selection bounds expand to encompass both original and mirrored copy"
  artifacts:
    - path: "src/core/map/SelectionTransforms.ts"
      provides: "Pure mirror algorithms (mirrorHorizontal, mirrorVertical, mirror dispatcher)"
      contains: "mirrorHorizontal"
      exports: ["mirrorHorizontal", "mirrorVertical", "mirror"]
    - path: "src/core/editor/slices/documentsSlice.ts"
      provides: "mirrorSelectionForDocument action"
      contains: "mirrorSelectionForDocument"
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "MIRROR tool button with variant dropdown"
      contains: "ToolType.MIRROR"
    - path: "src/core/map/types.ts"
      provides: "MIRROR tool enum value"
      contains: "MIRROR = 'mirror'"
    - path: "public/assets/toolbar/mirror.svg"
      provides: "Mirror toolbar icon"
  key_links:
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "documentsSlice.mirrorSelectionForDocument"
      via: "variant dropdown setter (action button, not mode)"
      pattern: "mirrorSelectionForDocument.*activeDocId"
    - from: "documentsSlice.mirrorSelectionForDocument"
      to: "SelectionTransforms.mirror"
      via: "mirror algorithm call"
      pattern: "SelectionTransforms\\.mirror"
    - from: "documentsSlice.mirrorSelectionForDocument"
      to: "pushUndoForDocument/commitUndoForDocument"
      via: "delta-based undo"
      pattern: "pushUndoForDocument.*commitUndoForDocument"
---

<objective>
Implement adjacent mirror-copy of selected map tiles with 4 directional options (Right, Left, Up, Down) accessible via toolbar button with variant dropdown.

Purpose: Enable users to create mirrored duplicates of selected tiles placed adjacent to the original selection in any of 4 directions, with full undo/redo support.

Output: Working mirror feature with toolbar UI, pure mirror algorithms in portable core layer, adjacent copy placement logic, selection expansion, and full undo/redo support via existing delta system.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:\NewMapEditor\.planning\PROJECT.md
@E:\NewMapEditor\.planning\ROADMAP.md
@E:\NewMapEditor\.planning\STATE.md
@E:\NewMapEditor\.planning\phases\42-mirror-tools\42-RESEARCH.md
@E:\NewMapEditor\.planning\phases\41-rotation-tools\41-01-SUMMARY.md

# Key source files
@E:\NewMapEditor\src\core\map\SelectionTransforms.ts
@E:\NewMapEditor\src\core\editor\slices\documentsSlice.ts
@E:\NewMapEditor\src\components\ToolBar\ToolBar.tsx
@E:\NewMapEditor\src\core\map\types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mirror algorithms to SelectionTransforms.ts and MIRROR tool enum</name>
  <files>
    src/core/map/SelectionTransforms.ts
    src/core/map/types.ts
  </files>
  <action>
**In `src/core/map/SelectionTransforms.ts`:**

Add a `MirrorResult` type alias (same shape as `RotationResult`: `{ tiles: Uint16Array; width: number; height: number }`). Reuse `RotationResult` directly or create a shared `TransformResult` type alias if preferred.

Add a `MirrorDirection` type: `'right' | 'left' | 'up' | 'down'`.

Add 3 exported functions after the existing rotation functions:

1. **`mirrorHorizontal(tiles: Uint16Array, width: number, height: number): RotationResult`**
   - Reverses each row independently (left-to-right flip).
   - Creates new `Uint16Array(width * height)`.
   - For each (x, y): `result[y * width + (width - 1 - x)] = tiles[y * width + x]`.
   - Returns `{ tiles: result, width, height }` (dimensions unchanged).
   - Used for Right and Left mirror directions.
   - Algorithm from existing `mirrorClipboardHorizontal` in globalSlice.ts (lines 151-165).

2. **`mirrorVertical(tiles: Uint16Array, width: number, height: number): RotationResult`**
   - Reverses row order (top-to-bottom flip).
   - Creates new `Uint16Array(width * height)`.
   - For each (x, y): `result[(height - 1 - y) * width + x] = tiles[y * width + x]`.
   - Returns `{ tiles: result, width, height }` (dimensions unchanged).
   - Used for Up and Down mirror directions.
   - Algorithm from existing `mirrorClipboardVertical` in globalSlice.ts (lines 167-181).

3. **`mirror(tiles: Uint16Array, width: number, height: number, direction: MirrorDirection): RotationResult`**
   - Dispatcher function that calls appropriate algorithm based on direction.
   - `'right'` and `'left'` -> `mirrorHorizontal` (the mirror algorithm is the same; the PLACEMENT differs, handled by the caller).
   - `'up'` and `'down'` -> `mirrorVertical` (same reasoning).
   - Returns the result from the appropriate function.

Use `Uint16Array` everywhere to preserve 16-bit tile encoding including animation flags (bit 15).

Add JSDoc comments with visualization examples matching the rotation function style:
- mirrorHorizontal: `[1 2 3] -> [3 2 1]`, `[4 5 6] -> [6 5 4]`
- mirrorVertical: `[1 2 3] / [4 5 6] / [7 8 9]` -> `[7 8 9] / [4 5 6] / [1 2 3]`

**In `src/core/map/types.ts`:**

Add `MIRROR = 'mirror'` to the `ToolType` enum immediately after `ROTATE = 'rotate'` (line 110). This keeps transform action tools grouped together.

No changes needed to `src/core/map/index.ts` -- SelectionTransforms is already exported from the barrel file.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero TypeScript errors.
2. Grep confirms all 3 mirror functions exist: `grep -E "(mirrorHorizontal|mirrorVertical|export function mirror)" src/core/map/SelectionTransforms.ts`
3. Grep confirms MirrorDirection type exists: `grep "MirrorDirection" src/core/map/SelectionTransforms.ts`
4. Grep confirms ToolType.MIRROR enum exists: `grep "MIRROR = 'mirror'" src/core/map/types.ts`
  </verify>
  <done>
SelectionTransforms.ts contains mirrorHorizontal, mirrorVertical, and mirror dispatcher functions using Uint16Array for 16-bit tile preservation. MirrorDirection type exported. ToolType.MIRROR enum value added after ROTATE. Zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add mirrorSelectionForDocument action, MIRROR toolbar button with variant dropdown, and mirror.svg icon</name>
  <files>
    src/core/editor/slices/documentsSlice.ts
    src/components/ToolBar/ToolBar.tsx
    public/assets/toolbar/mirror.svg
  </files>
  <action>
**In `src/core/editor/slices/documentsSlice.ts`:**

Add `mirrorSelectionForDocument: (id: DocumentId, direction: MirrorDirection) => void` to the `DocumentsSlice` interface (near `rotateSelectionForDocument` on line 64).

Import `MirrorDirection` from `SelectionTransforms` (or wherever the type is exported -- `@core/map` barrel). `SelectionTransforms` is already imported.

Implement the action following the adjacent-copy pattern (CRITICAL DIFFERENCE from rotation: do NOT clear original tiles):

```
mirrorSelectionForDocument: (id, direction) => {
  const doc = get().documents.get(id);
  if (!doc || !doc.map || !doc.selection.active || doc.isPasting) return;

  // 1. Calculate selection bounds (same pattern as rotation)
  const minX = Math.min(doc.selection.startX, doc.selection.endX);
  const minY = Math.min(doc.selection.startY, doc.selection.endY);
  const maxX = Math.max(doc.selection.startX, doc.selection.endX);
  const maxY = Math.max(doc.selection.startY, doc.selection.endY);
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;

  // 2. Extract selection into temp Uint16Array (same as rotation)
  const extracted = new Uint16Array(width * height);
  let pos = 0;
  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      extracted[pos++] = doc.map.tiles[y * MAP_WIDTH + x];
    }
  }

  // 3. Mirror the extracted tiles
  const mirrored = SelectionTransforms.mirror(extracted, width, height, direction);

  // 4. Calculate adjacent placement coordinates
  let copyX = minX;
  let copyY = minY;
  switch (direction) {
    case 'right': copyX = minX + width; break;
    case 'left':  copyX = minX - width; break;
    case 'up':    copyY = minY - height; break;
    case 'down':  copyY = minY + height; break;
  }

  // 5. Snapshot for undo BEFORE making changes
  get().pushUndoForDocument(id);

  // 6. Write mirrored copy to adjacent position (clip out-of-bounds)
  // NOTE: Do NOT clear original area -- this is a COPY operation
  const writeTiles: Array<{ x: number; y: number; tile: number }> = [];
  let idx = 0;
  for (let dy = 0; dy < mirrored.height; dy++) {
    for (let dx = 0; dx < mirrored.width; dx++) {
      const mapX = copyX + dx;
      const mapY = copyY + dy;
      if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
        writeTiles.push({ x: mapX, y: mapY, tile: mirrored.tiles[idx] });
      }
      idx++;
    }
  }
  get().setTilesForDocument(id, writeTiles);

  // 7. Update selection to encompass BOTH original and mirrored copy
  const updatedDoc = get().documents.get(id)!;
  const newStartX = Math.max(0, Math.min(minX, copyX));
  const newStartY = Math.max(0, Math.min(minY, copyY));
  const newEndX = Math.min(MAP_WIDTH - 1, Math.max(maxX, copyX + width - 1));
  const newEndY = Math.min(MAP_HEIGHT - 1, Math.max(maxY, copyY + height - 1));

  const finalDoc = {
    ...updatedDoc,
    selection: {
      startX: newStartX,
      startY: newStartY,
      endX: newEndX,
      endY: newEndY,
      active: true
    }
  };

  set((state) => {
    const newDocs = new Map(state.documents);
    newDocs.set(id, finalDoc);
    return { documents: newDocs };
  });

  // 8. Commit undo with descriptive message
  const dirLabel = direction.charAt(0).toUpperCase() + direction.slice(1);
  get().commitUndoForDocument(id, `Mirror ${dirLabel}`);
}
```

Key differences from `rotateSelectionForDocument`:
- NO clearing of original area (no clearTiles step)
- Write coordinates are `copyX + dx` / `copyY + dy` (adjacent, not minX/minY)
- Selection expands to encompass both original AND copy (not just the transformed area)
- Direction label capitalized for undo description

**In `src/components/ToolBar/ToolBar.tsx`:**

1. Add MIRROR to the `transformActionTools` array (after ROTATE):
```typescript
const transformActionTools: ToolButton[] = [
  { tool: ToolType.ROTATE, label: 'Rotate', icon: 'rotate', shortcut: '' },
  { tool: ToolType.MIRROR, label: 'Mirror', icon: 'mirror', shortcut: '' },
];
```

2. Add MIRROR variant config to `variantConfigs` array (after the ROTATE config, before the closing `]`):
```typescript
{
  tool: ToolType.MIRROR,
  settingName: 'Direction',
  getCurrentValue: () => 0, // No persistent value, action on click
  variants: [
    { label: 'Right', value: 0 },
    { label: 'Left', value: 1 },
    { label: 'Up', value: 2 },
    { label: 'Down', value: 3 },
  ],
  setter: (dirIndex) => {
    const directions = ['right', 'left', 'up', 'down'] as const;
    const activeDocId = useEditorStore.getState().activeDocumentId;
    if (!activeDocId) return;
    const doc = useEditorStore.getState().documents.get(activeDocId);
    if (!doc || !doc.selection.active || doc.isPasting) return;
    useEditorStore.getState().mirrorSelectionForDocument(
      activeDocId,
      directions[dirIndex] as 'right' | 'left' | 'up' | 'down'
    );
  }
},
```

The MIRROR button pattern is identical to ROTATE: action button that opens dropdown, each variant executes immediately, never shows as "active" tool, no persistent direction state.

**Create `public/assets/toolbar/mirror.svg`:**

Create a simple SVG icon representing mirror/reflection. Use the same viewBox and style as `rotate.svg`. A bidirectional horizontal arrow (left-right arrows with a vertical divider line) is a clear mirror icon. Keep it simple, monochrome, matching the existing toolbar icon style (24x24 viewBox, stroke-based, currentColor).

Example structure:
```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <!-- Vertical center line (mirror axis) -->
  <line x1="12" y1="4" x2="12" y2="20" stroke-dasharray="2,2"/>
  <!-- Left arrow -->
  <polyline points="6,8 2,12 6,16"/>
  <line x1="2" y1="12" x2="11" y2="12"/>
  <!-- Right arrow -->
  <polyline points="18,8 22,12 18,16"/>
  <line x1="22" y1="12" x2="13" y2="12"/>
</svg>
```

Adjust exact coordinates for visual clarity. The icon should be recognizable at 20x20px toolbar size.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero TypeScript errors.
2. Grep confirms mirrorSelectionForDocument exists: `grep "mirrorSelectionForDocument:" src/core/editor/slices/documentsSlice.ts`
3. Grep confirms MIRROR variant config: `grep -A 5 "tool: ToolType.MIRROR" src/components/ToolBar/ToolBar.tsx`
4. Grep confirms MIRROR in transformActionTools: `grep "ToolType.MIRROR" src/components/ToolBar/ToolBar.tsx`
5. Verify mirror.svg exists: `ls public/assets/toolbar/mirror.svg`
6. `npm run electron:dev` starts without errors.
7. Manual test -- Mirror Right: Create a selection with distinct tiles (e.g., 3x2 area with tiles [A B C / D E F]). Click Mirror button, select "Right". Verify:
   - Original tiles [A B C / D E F] remain at original position
   - Mirrored copy [C B A / F E D] appears immediately to the right
   - Selection marquee now covers both areas (6 tiles wide x 2 tall)
   - Ctrl+Z undoes the mirror (copy disappears, selection returns to original 3x2)
8. Manual test -- Mirror Left: Same selection near center of map. Mirror Left. Copy appears to the left, flipped horizontally.
9. Manual test -- Mirror Up: Mirror Up. Copy appears above, flipped vertically.
10. Manual test -- Mirror Down: Mirror Down. Copy appears below, flipped vertically.
11. Edge case: Mirror right near right edge (e.g., x=250, width=10). Tiles beyond x=255 are silently clipped.
12. Edge case: No selection active. Click Mirror dropdown variant. Nothing happens (no-op).
13. Edge case: Paste mode active (isPasting=true). Mirror variants no-op.
  </verify>
  <done>
mirrorSelectionForDocument action exists in documentsSlice implementing adjacent copy pattern (extract -> mirror -> write to adjacent position -> expand selection -> commit undo). NO clearing of original tiles. MIRROR toolbar button with 4-variant dropdown (Right, Left, Up, Down) executes immediately on variant click. Selection bounds expand to encompass both original and copy. Undo/redo works correctly. mirror.svg icon created. Zero TypeScript errors.
  </done>
</task>

</tasks>

<verification>
## Phase-Level Verification

After completing both tasks, verify the complete mirror feature:

**Functional verification:**
1. Open a map file
2. Use SELECT tool to create a rectangular selection (e.g., 3 tiles wide x 2 tiles tall)
3. Place distinct tiles in the selection area (different tile types so mirroring is visually obvious)
4. Click MIRROR toolbar button -> dropdown shows 4 options (Right, Left, Up, Down)
5. Select "Right" -> original tiles stay, horizontally-mirrored copy appears to the right, selection doubles in width
6. Press Ctrl+Z -> mirror undone, copy disappears, selection returns to original 3x2
7. Try "Left" -> copy appears to the left, horizontally flipped
8. Try "Down" -> copy appears below, vertically flipped
9. Try "Up" -> copy appears above, vertically flipped
10. Mirror near map edges -> out-of-bounds tiles clipped silently, no crashes
11. Verify animated tiles (bit 15 set) preserve animation flags in mirrored copy

**Selection expansion verification:**
- Mirror Right on 3x2 selection: result selection = 6 tiles wide x 2 tall
- Mirror Left on 3x2 selection: result selection = 6 tiles wide x 2 tall (shifted left)
- Mirror Down on 3x2 selection: result selection = 3 tiles wide x 4 tall
- Mirror Up on 3x2 selection: result selection = 3 tiles wide x 4 tall (shifted up)

**Edge cases:**
- No selection active -> MIRROR variants no-op (early return in setter + action)
- Paste mode active (isPasting=true) -> MIRROR variants no-op
- 1x1 selection -> mirror works, copy placed adjacent
- Mirror at map boundary -> partial copy, clipped tiles, no crash
- Sequential mirrors -> each mirror expands selection further (e.g., mirror right twice = 3x original width)

**Acceptance:**
- All MIR-01 through MIR-05 requirements met
- All must_haves truths observable
- All must_haves artifacts exist
- All key_links verified via grep patterns
</verification>

<success_criteria>
**Phase 42 complete when:**

1. User can mirror 3x2 selection rightward -> horizontally-flipped copy appears to the right
2. User can mirror selection leftward -> horizontally-flipped copy appears to the left
3. User can mirror selection downward -> vertically-flipped copy appears below
4. User can mirror selection upward -> vertically-flipped copy appears above
5. Original selection tiles remain intact after all mirror operations (COPY, not flip)
6. Selection bounds expand to encompass both original and mirrored copy
7. MIRROR toolbar button visible with dropdown listing all 4 directions
8. Undo/redo works correctly for all mirror operations
9. Mirrors preserve 16-bit tile encoding including animation flags
10. Out-of-bounds mirrored tiles silently clipped (no crashes near map edges)
11. Zero TypeScript errors, app starts and runs without issues
12. All 5 requirements (MIR-01 through MIR-05) verified as TRUE
</success_criteria>

<output>
After completion, create `.planning/phases/42-mirror-tools/42-01-SUMMARY.md` following the template at `C:\Users\arcje\.claude/get-shit-done/templates/summary.md`.

Summary should document:
- Task commits with mirror algorithm implementation and UI wiring
- Files created (mirror.svg) and modified (SelectionTransforms.ts, documentsSlice.ts, ToolBar.tsx, types.ts)
- Key decisions (adjacent copy vs in-place flip, selection expansion, horizontal vs vertical mirror selection per direction)
- Patterns established (adjacent copy placement, selection expansion after transform)
- Critical difference from rotation: NO clearing of original area, write to DIFFERENT coordinates, selection EXPANDS
</output>
