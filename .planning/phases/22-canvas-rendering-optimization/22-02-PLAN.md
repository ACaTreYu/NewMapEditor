---
phase: 22-canvas-rendering-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/Minimap/Minimap.tsx
  - src/components/AnimationPreview/AnimationPreview.tsx
  - src/components/AnimationPanel/AnimationPanel.tsx
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "Dragging on the minimap to navigate does NOT crash the app"
    - "Animations run at the correct speed (150ms per frame tick, not faster)"
    - "Only one animation timer exists regardless of how many animation components are mounted"
    - "Minimap redraws without creating temporary canvas elements on every tile"
  artifacts:
    - path: "src/components/Minimap/Minimap.tsx"
      provides: "Minimap that handles rapid viewport updates without crashing"
      contains: "throttle"
    - path: "src/components/AnimationPanel/AnimationPanel.tsx"
      provides: "Animation panel that consumes shared animation timer"
    - path: "src/components/AnimationPreview/AnimationPreview.tsx"
      provides: "Animation preview that consumes shared animation timer"
  key_links:
    - from: "src/components/AnimationPreview/AnimationPreview.tsx"
      to: "advanceAnimationFrame"
      via: "Single animation timer (only one component owns the RAF loop)"
      pattern: "advanceAnimationFrame"
    - from: "src/components/Minimap/Minimap.tsx"
      to: "setViewport"
      via: "Throttled viewport updates during drag"
      pattern: "setViewport"
---

<objective>
Fix two known issues from Phase 22 Plan 01: (1) app crash when dragging on minimap to navigate, and (2) animations running faster than expected.

Purpose: These are regression bugs introduced by the 4-layer canvas architecture that prevent Phase 22 from being considered complete.

Output: A stable minimap that handles rapid drag-navigation without crashing, and animations that run at the correct 150ms tick rate regardless of how many animation components are mounted.
</objective>

<execution_context>
@C:\Users\arcje\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\arcje\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-canvas-rendering-optimization/22-01-SUMMARY.md
@src/components/MapCanvas/MapCanvas.tsx
@src/components/Minimap/Minimap.tsx
@src/components/AnimationPreview/AnimationPreview.tsx
@src/components/AnimationPanel/AnimationPanel.tsx
@src/core/editor/EditorState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix minimap crash on drag-navigate and animation double-tick</name>
  <files>
    src/components/Minimap/Minimap.tsx
    src/components/AnimationPreview/AnimationPreview.tsx
    src/components/AnimationPanel/AnimationPanel.tsx
  </files>
  <action>
ROOT CAUSE ANALYSIS — MINIMAP CRASH:

The Minimap `draw()` function (lines 86-98 of Minimap.tsx) creates a temporary `document.createElement('canvas')` for EVERY tile that needs color sampling from the tileset. For a 256x256 map (sampling every 2nd tile = 16,384 tiles), this creates thousands of temporary canvas elements per draw call. During minimap drag-navigation, `setViewport` fires on every mouse move, which triggers Minimap to redraw (because `viewport` is in its `draw()` useCallback dependency array). The 4-layer MapCanvas architecture makes this worse because each `setViewport` call triggers 4 independent layer redraws AND the minimap redraw simultaneously, overwhelming the browser's memory and GC.

FIX — Minimap: Eliminate temporary canvas creation by building a tile color lookup table ONCE when the tileset loads, then reusing it on every draw:

1. In `Minimap.tsx`, add a `useRef` for a cached color lookup: `const tileColorCacheRef = useRef<Uint8Array | null>(null)` and a `const lastTilesetRef = useRef<HTMLImageElement | null>(null)`.

2. Add a `useEffect` that runs when `tilesetImage` changes. Inside it:
   - If `tilesetImage` is null, set `tileColorCacheRef.current = null` and return.
   - Create ONE temporary canvas (size 1x1).
   - Build a `Uint8Array(TOTAL_TILES * 3)` where TOTAL_TILES = the number of tiles in the tileset (calculate from tileset dimensions: `const totalTiles = Math.floor(tilesetImage.height / TILE_SIZE) * TILES_PER_ROW`).
   - Loop through all tile IDs, sample the center pixel (srcX+8, srcY+8) of each tile using the temp canvas, and store R/G/B in the array at `[tileId * 3]`, `[tileId * 3 + 1]`, `[tileId * 3 + 2]`.
   - Store the result in `tileColorCacheRef.current`.
   - Store `tilesetImage` in `lastTilesetRef.current`.
   - This runs ONCE per tileset load, not per draw.

3. In the `draw()` function, replace the per-tile temporary canvas creation block (the `else if (tilesetImage)` branch, lines 85-98) with a lookup into `tileColorCacheRef.current`:
   ```typescript
   } else if (tileColorCacheRef.current && tileId < totalTilesInCache) {
     const offset = tileId * 3;
     r = tileColorCacheRef.current[offset];
     g = tileColorCacheRef.current[offset + 1];
     b = tileColorCacheRef.current[offset + 2];
   }
   ```
   Remove the temporary canvas creation entirely from the draw loop.

4. Additionally, throttle the minimap redraw during drag by removing `viewport` from the `draw()` useCallback dependency array. Instead, separate the viewport rectangle drawing from the tile drawing:
   - Keep the tile pixel rendering in `draw()` with deps `[map, tilesetImage]` (only redraws when map data changes, NOT on every pan).
   - Create a separate `drawViewportRect()` useCallback that only draws the viewport rectangle overlay. This function should:
     a. Get the canvas context
     b. Call `draw()` first (or better: save/restore the tile imageData and redraw viewport rect on top)
     c. Actually, simplest approach: keep `draw()` with `viewport` in deps BUT since the temp canvas bottleneck is eliminated, the rapid redraws will no longer crash. The color cache makes each draw() call fast enough for 60fps.

   SIMPLIFIED APPROACH: Just eliminate the temp canvas creation (steps 1-3). This alone should fix the crash since the draw() function will be O(16384 lookups) instead of O(16384 canvas creations). Keep viewport in the draw() deps so the viewport rectangle updates correctly during drag.

ROOT CAUSE ANALYSIS — ANIMATION SPEED:

Both `AnimationPreview.tsx` and `AnimationPanel.tsx` each have their own independent RAF loop calling `advanceAnimationFrame()` every 150ms. When both components are mounted simultaneously (which is the normal case), the animation counter increments at ~2x the intended rate because TWO independent timers are both calling `advanceAnimationFrame()`.

FIX — Animation timer: Only ONE component should own the animation RAF loop. The other should be a passive consumer that reads `animationFrame` from the store.

1. In `AnimationPanel.tsx` — KEEP the RAF loop as-is. This is the "primary" animation timer since AnimationPanel is the main animation component.

2. In `AnimationPreview.tsx` — REMOVE the entire RAF loop useEffect (lines 29-46). The component already subscribes to `animationFrame` from the store (line 24: `const animationFrame = useEditorStore((state) => state.animationFrame)`), so it will automatically re-render when the AnimationPanel's timer advances the frame. Remove the `advanceAnimationFrame` import/subscription since AnimationPreview no longer needs it.

3. IMPORTANT: If AnimationPanel is not mounted but AnimationPreview IS mounted (edge case), animations should still work. Check if this can happen in the current layout. If AnimationPanel is always mounted when AnimationPreview is, then simply removing the timer from AnimationPreview is safe. If AnimationPreview can exist without AnimationPanel, then instead of removing the timer from AnimationPreview, add a guard: move the animation timer to a shared hook or to App.tsx.

   Looking at the component structure: AnimationPanel is in the right sidebar and AnimationPreview appears to be a compact version. Check if they're mutually exclusive or always co-mounted. If unclear, the SAFEST fix is:
   - Move the animation RAF loop into App.tsx (or create a small `useAnimationTimer()` hook called from App.tsx)
   - Remove the RAF loop from BOTH AnimationPreview and AnimationPanel
   - Both components just read `animationFrame` from the store

   RECOMMENDED APPROACH: Create a `useAnimationTimer` custom hook in `src/core/editor/useAnimationTimer.ts` that contains the RAF loop and calls `advanceAnimationFrame`. Call this hook from App.tsx (which is always mounted). Remove the RAF loops from both AnimationPreview.tsx and AnimationPanel.tsx. This guarantees exactly ONE timer regardless of which panels are visible.

   ACTUALLY, to keep the change minimal and avoid creating new files: Just put the RAF loop in App.tsx directly. App.tsx is always mounted and is the right place for a global animation timer.

   SIMPLEST APPROACH: Remove the RAF loop from AnimationPreview.tsx only. Keep it in AnimationPanel.tsx. AnimationPanel is always mounted in the current layout (it's in the sidebar). If a future phase changes that, the timer can be moved then. This is the minimal fix.

Pick the SIMPLEST APPROACH: Remove RAF loop from AnimationPreview.tsx, keep it in AnimationPanel.tsx.
  </action>
  <verify>
Run `npm run typecheck` — should pass with no errors.

Verify in code:
1. Minimap.tsx no longer has `document.createElement('canvas')` inside the draw loop
2. Minimap.tsx has a tileColorCacheRef with one-time cache building
3. AnimationPreview.tsx no longer has a RAF loop or advanceAnimationFrame call
4. AnimationPanel.tsx still has its RAF loop (unchanged)
5. Only ONE call to `advanceAnimationFrame` exists in the entire codebase (in AnimationPanel.tsx)
  </verify>
  <done>
Minimap draw() uses cached color lookup table instead of creating temporary canvases. Only one animation RAF loop exists (in AnimationPanel.tsx). Both issues from 22-01 verification are resolved.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Fixed two issues from Phase 22 Plan 01:
1. Minimap crash on drag-navigate — eliminated per-tile temporary canvas creation, replaced with one-time color lookup cache
2. Animation double-tick — removed duplicate RAF loop from AnimationPreview (AnimationPanel is the single timer owner)
  </what-built>
  <how-to-verify>
Run `npm run electron:dev` and check:

1. **Minimap drag (MOST IMPORTANT)**: Load a map. Click and DRAG on the minimap to navigate around the map. Drag rapidly in circles. The app should NOT crash or freeze. The main canvas should update smoothly as you drag on the minimap.

2. **Animation speed**: Look at animated tiles on the map (or in the animation panel). Animations should run at a normal, steady pace — not sped up or doubled. Compare with the 150ms frame duration expectation (~6.7 frames per second). If you have a reference for the correct speed from the game, compare against that.

3. **Animation panel previews**: The animation list in the right panel should still show live animated previews. Selecting an animation should still work normally.

4. **All tools still work**: Quick-test pencil, eraser, zoom, pan, grid toggle. Everything should work as before.
  </how-to-verify>
  <resume-signal>Type "approved" if both issues are fixed, or describe remaining problems.</resume-signal>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with no errors
- Minimap drag-navigate does not crash the app
- Animations run at correct speed (not doubled)
- Only one RAF animation timer in codebase (AnimationPanel.tsx)
- No temporary canvas creation in Minimap draw loop
- All existing tool behavior preserved
- Minimap correctly renders tile colors from cached lookup
</verification>

<success_criteria>
Gap 1 CLOSED: Minimap drag-navigate works without crash (temporary canvas creation eliminated)
Gap 2 CLOSED: Animations run at correct 150ms tick rate (single timer, not doubled)
All Phase 22 requirements (PERF-04, PERF-05, PERF-06) remain satisfied
No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/22-canvas-rendering-optimization/22-02-SUMMARY.md`
</output>
