---
phase: 22-canvas-rendering-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/MapCanvas/MapCanvas.css
  - src/core/editor/EditorState.ts
autonomous: false

must_haves:
  truths:
    - "No phantom grid lines visible between tiles at any zoom level when grid is toggled OFF"
    - "Static tiles only redraw when map data or viewport changes, NOT on every animationFrame tick"
    - "Animated tiles redraw only on animationFrame tick, not on cursor move or tool change"
    - "Grid lines render with 2 stroke calls total (1 beginPath + horizontal lines + vertical lines + 1 stroke), not per-line strokes"
    - "Canvas resize is debounced through requestAnimationFrame, not firing on every ResizeObserver callback"
    - "Grid defaults to OFF on fresh load"
    - "Scrolling/panning feels noticeably smoother than before the refactor"
  artifacts:
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Layered canvas rendering with 4 stacked canvases"
      contains: "staticLayerRef"
    - path: "src/components/MapCanvas/MapCanvas.css"
      provides: "Stacked canvas positioning with image-rendering:pixelated"
      contains: "image-rendering"
    - path: "src/core/editor/EditorState.ts"
      provides: "showGrid defaults to false"
      contains: "showGrid: false"
  key_links:
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "drawStaticLayer useEffect"
      via: "useEffect dependency on map, viewport"
      pattern: "useEffect.*drawStaticLayer"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "drawAnimLayer useEffect"
      via: "useEffect dependency on animationFrame"
      pattern: "useEffect.*drawAnimLayer"
    - from: "src/components/MapCanvas/MapCanvas.tsx"
      to: "ResizeObserver RAF debounce"
      via: "requestAnimationFrame inside ResizeObserver callback"
      pattern: "requestAnimationFrame"
---

<objective>
Refactor MapCanvas from a single monolithic canvas with one draw() function into a 4-layer stacked canvas architecture where each layer redraws independently based on its specific state triggers. Fix the phantom grid lines bug (sub-pixel rendering gaps between tiles). Implement batched grid drawing. Debounce canvas resize via requestAnimationFrame. Change grid default to OFF.

Purpose: Eliminate redundant draw calls (currently redraws ALL content on ANY state change including cursor movement and animation ticks), fix visible rendering bugs, and dramatically improve scroll/pan smoothness.

Output: A fully refactored MapCanvas with 4 stacked canvases (static tiles, animated tiles, overlays, grid), each with independent render triggers, pixel-perfect tile rendering, and smooth scrolling.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-canvas-rendering-optimization/22-RESEARCH.md
@.planning/phases/22-canvas-rendering-optimization/22-CONTEXT.md
@src/components/MapCanvas/MapCanvas.tsx
@src/components/MapCanvas/MapCanvas.css
@src/core/editor/EditorState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-canvas layer architecture with pixel-perfect rendering</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
    src/components/MapCanvas/MapCanvas.css
    src/core/editor/EditorState.ts
  </files>
  <action>
STRUCTURAL CHANGES TO MapCanvas.tsx:

1. Replace single `canvasRef` with 4 canvas refs:
   - `staticLayerRef` (z-index 1): static (non-animated) tiles
   - `animLayerRef` (z-index 2): animated tiles only
   - `overlayLayerRef` (z-index 3): cursor highlight, line preview, selection marching ants, rect drag, tool previews, conveyor preview — ALL interactive overlays
   - `gridLayerRef` (z-index 4): grid lines (topmost so grid is always visible over everything)

2. In the JSX, replace the single `<canvas ref={canvasRef} ...>` with 4 stacked canvases inside the container div. Mouse event handlers (onMouseDown, onMouseMove, onMouseUp, onMouseLeave, onWheel, onContextMenu) go on the TOPMOST canvas (gridLayerRef) since it sits on top and receives pointer events. The other 3 canvases need CSS `pointer-events: none` so clicks pass through.

3. Split the monolithic `draw()` function (lines ~154-492) into 4 separate useCallback functions:

   **drawStaticLayer()**:
   - Get staticLayerRef context
   - Set `ctx.imageSmoothingEnabled = false`
   - Clear canvas with fillStyle '#1a1a2e' (the background color)
   - Loop through visible tiles, draw only NON-animated tiles (tile & 0x8000 === 0)
   - CRITICAL: Use `Math.floor()` on ALL screen coordinates: `const screenX = Math.floor((x - viewport.x) * tilePixels)` and `const screenY = Math.floor((y - viewport.y) * tilePixels)`. This fixes the phantom grid lines bug.
   - Also Math.floor the destination size: `Math.ceil(tilePixels)` for width/height to ensure no gaps between tiles (rounding up by 1 sub-pixel prevents gaps when tilePixels is fractional)
   - Handle the no-tileset placeholder case
   - For animated tiles, draw frame 0 as a static background so there's no flicker before the animation layer paints. Use `const anim = ANIMATION_DEFINITIONS[animId]; const displayTile = anim?.frames[0]` and draw that tile. This way the static layer has complete coverage and the animation layer paints over the top.

   **drawAnimLayer()**:
   - Get animLayerRef context
   - Set `ctx.imageSmoothingEnabled = false`
   - `ctx.clearRect(0, 0, canvas.width, canvas.height)` (transparent background - animation layer sits on top of static)
   - Loop through visible tiles, draw ONLY animated tiles (tile & 0x8000 !== 0)
   - Use the existing animation frame logic (animId, tileFrameOffset, ANIMATION_DEFINITIONS, animationFrame)
   - CRITICAL: Math.floor() on all screen coordinates
   - Math.ceil(tilePixels) for destination size

   **drawOverlayLayer()**:
   - Get overlayLayerRef context
   - `ctx.clearRect(0, 0, canvas.width, canvas.height)` (transparent)
   - Move ALL overlay drawing from the old draw(): line preview (lines 244-288), cursor highlight (291-296), tile selection preview (299-318), game object stamp preview (322-337), warp tool cursor (340-347), wall pencil cursor (350-356), rect drag outline + conveyor preview (359-456), selection marching ants (458-491)
   - This is a direct move — same code, just using overlayLayerRef context instead of the old single canvas context
   - Math.floor() on any tile-to-screen conversions used in overlays

   **drawGridLayer()**:
   - Get gridLayerRef context
   - `ctx.clearRect(0, 0, canvas.width, canvas.height)`
   - If `!showGrid`, return early (just clear)
   - REMOVE the `viewport.zoom >= 0.5` check — grid is always visible at all zoom levels when toggled on (user decision)
   - BATCHED grid drawing: single `ctx.beginPath()`, loop all vertical lines with moveTo/lineTo, loop all horizontal lines with moveTo/lineTo, single `ctx.stroke()`
   - Use `Math.floor()` on grid line coordinates
   - Grid style: `ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'`, `ctx.lineWidth = 1`

4. Change `showGrid: true` to `showGrid: false` on line 189 of EditorState.ts.

CSS CHANGES TO MapCanvas.css:

5. Add `.map-canvas-layer` class for the stacked canvases:
   ```css
   .map-canvas-layer {
     position: absolute;
     top: 0;
     left: 0;
     image-rendering: pixelated;
     image-rendering: crisp-edges;
   }
   ```

6. Add pointer-events rule for non-interactive layers:
   ```css
   .map-canvas-layer.no-events {
     pointer-events: none;
   }
   ```

7. The topmost canvas (grid layer, which receives mouse events) keeps the existing `.map-canvas` cursor styles. Apply both `.map-canvas-layer` and `.map-canvas` classes to it.

IMPORTANT THINGS TO PRESERVE:
- All mouse handler logic (handleMouseDown, handleMouseMove, handleMouseUp, handleMouseLeave, handleWheel) stays EXACTLY the same
- All scrollbar logic stays the same
- All escape key handlers stay the same
- The `canvasRef` references in mouse handlers (screenToTile, getScrollMetrics, etc.) must be updated to reference the topmost interactive canvas (gridLayerRef) since that's what receives events and determines dimensions
- The scrollbar JSX stays exactly the same
  </action>
  <verify>
Run `npm run typecheck` — should pass with no errors. Visually inspect that MapCanvas.tsx has 4 canvas refs, 4 draw functions, and Math.floor on all drawImage coordinates. Verify EditorState.ts has `showGrid: false`.
  </verify>
  <done>
MapCanvas renders 4 stacked canvases. Static tiles draw with Math.floor coordinates and imageSmoothingEnabled=false (no phantom grid lines). Animation layer draws only animated tiles. Overlay layer handles all interactive elements. Grid uses batched single-stroke drawing. Grid defaults to OFF.
  </done>
</task>

<task type="auto">
  <name>Task 2: Layer-specific render triggers and RAF-debounced resize</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
  </files>
  <action>
RENDER TRIGGER WIRING:

1. Replace the old generic `useEffect(() => { draw(); }, [draw])` with 4 SEPARATE useEffect hooks, each triggering only its specific layer:

   ```typescript
   // Static layer: redraw on map data, viewport, or tileset changes
   useEffect(() => {
     drawStaticLayer();
   }, [drawStaticLayer]);
   // drawStaticLayer's useCallback deps: map, viewport, tilesetImage, getVisibleTiles

   // Animation layer: redraw ONLY on animationFrame tick (plus viewport/map for visible tile calculation)
   useEffect(() => {
     drawAnimLayer();
   }, [drawAnimLayer]);
   // drawAnimLayer's useCallback deps: map, viewport, tilesetImage, animationFrame, getVisibleTiles

   // Overlay layer: redraw on tool/cursor/selection/drag state changes
   useEffect(() => {
     drawOverlayLayer();
   }, [drawOverlayLayer]);
   // drawOverlayLayer's useCallback deps: cursorTile, lineState, currentTool, tileSelection, rectDragState, gameObjectToolState, selection, selectionDrag, viewport, animationFrame, tilesetImage

   // Grid layer: redraw on showGrid toggle or viewport change
   useEffect(() => {
     drawGridLayer();
   }, [drawGridLayer]);
   // drawGridLayer's useCallback deps: viewport, showGrid, getVisibleTiles
   ```

   NOTE: The useCallback dependency arrays are what controls WHEN each layer redraws. The useEffect just calls the draw function when it changes (which happens when its deps change). This is the standard React pattern already used in the codebase.

2. IMPORTANT: The overlay layer needs animationFrame in its deps because marching ants use `animationFrame * 0.5` for dash offset. This means the overlay redraws on animation ticks too — that's correct and necessary for animated marching ants.

SPLIT ZUSTAND SUBSCRIPTIONS for better granularity:

3. Split the current single `useShallow` state subscription into layer-aligned groups to minimize re-renders:

   ```typescript
   // Viewport + map (triggers static, anim, grid, overlay redraws)
   const { map, viewport } = useEditorStore(
     useShallow((state) => ({ map: state.map, viewport: state.viewport }))
   );

   // Animation frame (triggers anim + overlay layer only)
   const animationFrame = useEditorStore(state => state.animationFrame);

   // Grid state (triggers grid layer only)
   const showGrid = useEditorStore(state => state.showGrid);

   // Tool/interaction state (triggers overlay layer only)
   const { currentTool, selectedTile, tileSelection, rectDragState, gameObjectToolState, selection } = useEditorStore(
     useShallow((state) => ({
       currentTool: state.currentTool,
       selectedTile: state.selectedTile,
       tileSelection: state.tileSelection,
       rectDragState: state.rectDragState,
       gameObjectToolState: state.gameObjectToolState,
       selection: state.selection
     }))
   );
   ```

   The action subscriptions (setTile, setTiles, etc.) stay exactly as they are — they're already stable refs.

RAF-DEBOUNCED RESIZE:

4. Replace the current ResizeObserver (lines 495-508) with an RAF-debounced version:

   ```typescript
   useEffect(() => {
     const container = containerRef.current;
     if (!container) return;

     let rafId: number | null = null;

     const resizeObserver = new ResizeObserver(() => {
       if (rafId !== null) {
         cancelAnimationFrame(rafId);
       }
       rafId = requestAnimationFrame(() => {
         const width = container.clientWidth;
         const height = container.clientHeight;

         // Update all 4 canvas dimensions
         const canvases = [
           staticLayerRef.current,
           animLayerRef.current,
           overlayLayerRef.current,
           gridLayerRef.current
         ];
         canvases.forEach(canvas => {
           if (canvas) {
             canvas.width = width;
             canvas.height = height;
           }
         });

         // Redraw all layers
         drawStaticLayer();
         drawAnimLayer();
         drawOverlayLayer();
         drawGridLayer();

         rafId = null;
       });
     });

     resizeObserver.observe(container);
     return () => {
       resizeObserver.disconnect();
       if (rafId !== null) cancelAnimationFrame(rafId);
     };
   }, [drawStaticLayer, drawAnimLayer, drawOverlayLayer, drawGridLayer]);
   ```

5. Remove the old resize useEffect and the old `useEffect(() => { draw(); }, [draw])` — they are replaced by the layer-specific effects above.

6. Update `getVisibleTiles()` and `getScrollMetrics()` and `screenToTile()` to use gridLayerRef (the interactive canvas that has the correct dimensions) instead of the old canvasRef.

CRITICAL CORRECTNESS CHECKS:
- The `handleWheel` function calls `canvasRef.current?.getBoundingClientRect()` — update to `gridLayerRef.current?.getBoundingClientRect()`
- The `handleMouseDown` function calls `canvasRef.current?.getBoundingClientRect()` — update to `gridLayerRef.current`
- The `handleMouseMove` function calls `canvasRef.current?.getBoundingClientRect()` — update to `gridLayerRef.current`
- Any other place that reads `canvasRef.current` for dimensions must switch to `gridLayerRef.current`
- Remove the old `canvasRef` entirely — it's replaced by the 4 layer refs
  </action>
  <verify>
Run `npm run typecheck` — should pass. Run `npm run electron:dev` and verify:
1. Open a map — tiles render correctly
2. Toggle grid (G key) — grid appears/disappears correctly
3. Zoom in/out — no phantom lines between tiles when grid is OFF
4. Pan with right-click drag — should feel smoother than before
5. Animated tiles still animate at correct speed
6. Selection marching ants still animate
7. All tools still work (pencil, wall, eraser, fill, picker, conveyor, etc.)
  </verify>
  <done>
Each canvas layer redraws independently based on its specific state triggers. Static layer does NOT redraw on animationFrame ticks. Animation layer does NOT redraw on cursor movement. Resize is RAF-debounced. All existing functionality preserved.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete canvas rendering refactor:
- 4 stacked canvases (static tiles, animated tiles, overlays, grid)
- Pixel-perfect rendering (Math.floor coordinates, imageSmoothingEnabled=false)
- Layer-specific render triggers (each layer only redraws when its state changes)
- RAF-debounced canvas resize
- Batched grid drawing (2 strokes instead of 60+)
- Grid defaults to OFF, visible at all zoom levels when toggled on
  </what-built>
  <how-to-verify>
Run `npm run electron:dev` and check:

1. **Phantom grid lines (MOST IMPORTANT)**: Load a map. With grid toggled OFF, zoom to various levels (0.25x, 0.5x, 1x, 2x, 4x). Look carefully at tile boundaries — there should be NO faint lines between tiles. Compare before/after if possible.

2. **Grid toggle**: Press G to toggle grid ON. Grid should appear at ALL zoom levels (including 0.25x where it was previously hidden). Grid should use thin white lines. Toggle OFF — grid disappears completely.

3. **Grid default**: Close and reopen the app. Grid should be OFF by default.

4. **Scroll/pan smoothness**: Right-click drag to pan around the map. Compare with scrollbar dragging. Both should feel equally smooth. Panning should feel noticeably less choppy than before.

5. **Animations**: Place or view animated tiles. They should animate at the correct speed with global sync. Marching ants on selections should still animate.

6. **All tools**: Quickly test pencil draw, eraser, fill, wall line, wall pencil, conveyor drag, game object placement, picker (I key), SELECT marquee. All should work identically to before.

7. **Zoom to cursor**: Mouse wheel zoom should still center on cursor position correctly.

8. **Resize**: Drag the window to resize. Canvas should resize smoothly without flicker.
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with no errors
- `npm run electron:dev` launches and renders map correctly
- No phantom grid lines at any zoom level with grid OFF
- Grid toggle works at all zoom levels
- Grid defaults to OFF
- Animated tiles render correctly with global sync
- All tools work (pencil, eraser, fill, wall, picker, select, game objects)
- Pan/scroll feels smoother
- Canvas resize is debounced (no flicker during window resize)
- Selection marching ants still animate
</verification>

<success_criteria>
PERF-04: MapCanvas uses 4 layered canvases (static tiles, animated tiles, overlays, grid) with independent render triggers
PERF-05: Grid lines drawn with batched path operations (1 beginPath, all lines, 1 stroke)
PERF-06: Canvas resize debounced via requestAnimationFrame in ResizeObserver callback
Phantom grid lines bug is fixed (Math.floor coordinates + imageSmoothingEnabled=false)
Grid defaults to OFF (showGrid: false in EditorState.ts)
All existing tool behavior preserved identically
</success_criteria>

<output>
After completion, create `.planning/phases/22-canvas-rendering-optimization/22-01-SUMMARY.md`
</output>
