---
phase: 33-document-state-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - src/App.tsx
  - src/components/MapCanvas/MapCanvas.tsx
  - src/components/ToolBar/ToolBar.tsx
  - src/components/Minimap/Minimap.tsx
  - src/components/MapSettingsDialog/MapSettingsDialog.tsx
  - src/components/MapSettingsPanel/MapSettingsPanel.tsx
  - src/components/AnimationPanel/AnimationPanel.tsx
  - src/components/StatusBar/StatusBar.tsx
  - src/components/TilePalette/TilePalette.tsx
  - electron/main.ts
autonomous: true

must_haves:
  truths:
    - "App starts with empty workspace (no document open) and shows a placeholder message"
    - "File > New creates a new document alongside existing open documents"
    - "File > Open opens a file as a new document alongside existing ones"
    - "Title bar shows active document filename and modified state (e.g. 'mymap.lvl *')"
    - "Each document has independent undo/redo — undoing in one does not affect another"
    - "Each document tracks its own viewport position and zoom independently"
    - "Each document tracks its own selection state independently"
    - "Switching active document via setActiveDocument correctly updates all UI components"
    - "Minimap reflects the active document's map and viewport"
    - "canUndo/canRedo selectors read from active document's stacks"
  artifacts:
    - path: "src/App.tsx"
      provides: "Multi-document lifecycle, empty workspace, title bar updates"
      contains: "createDocument"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "Active-document-aware canvas rendering"
      contains: "activeDocumentId"
    - path: "src/components/ToolBar/ToolBar.tsx"
      provides: "Active-document-aware undo/redo state"
      contains: "activeDocumentId"
    - path: "electron/main.ts"
      provides: "IPC handler for setting window title"
      contains: "set-title"
  key_links:
    - from: "src/App.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "createDocument action for new/open"
      pattern: "createDocument"
    - from: "src/App.tsx"
      to: "electron/main.ts"
      via: "IPC set-title for window title updates"
      pattern: "set-title"
    - from: "src/components/ToolBar/ToolBar.tsx"
      to: "src/core/editor/EditorState.ts"
      via: "canUndo/canRedo selectors reading active document stacks"
      pattern: "activeDocumentId"
---

<objective>
Migrate all consumer components to use document-aware state, implement multi-document lifecycle in App.tsx (new, open with multi-doc semantics), update title bar to show filename and dirty state, and make the app start with an empty workspace. After this plan, the app fully supports multiple documents in memory with per-document state isolation.

Purpose: Without component migration, the refactored store from Plan 01 is inert. This plan completes the user-facing behavior: documents can be created, opened, and edited independently. This satisfies all Phase 33 success criteria.

Output: All 10+ components migrated to document-aware state. App starts empty, creates documents on new/open, shows filename in title bar.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-document-state-refactoring/33-RESEARCH.md
@.planning/phases/33-document-state-refactoring/33-CONTEXT.md
@.planning/phases/33-document-state-refactoring/33-01-SUMMARY.md
@src/core/editor/EditorState.ts
@src/core/editor/slices/types.ts
@src/App.tsx
@src/components/MapCanvas/MapCanvas.tsx
@src/components/ToolBar/ToolBar.tsx
@src/components/Minimap/Minimap.tsx
@electron/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate App.tsx for multi-document lifecycle and title bar</name>
  <files>
    src/App.tsx
    electron/main.ts
    electron/preload.ts
  </files>
  <action>
**App.tsx changes:**

1. **Empty workspace on startup:** The app already starts with `map: null` (Plan 01 maintains this with `activeDocumentId: null`). Add a check: when `map` is null AND `activeDocumentId` is null, render a placeholder message in the canvas area instead of MapCanvas. Something like:
```tsx
{activeDocumentId ? (
  <MapCanvas tilesetImage={tilesetImage} onCursorMove={handleCursorMove} />
) : (
  <div className="empty-workspace">
    <p>No document open</p>
    <p>File &gt; New or File &gt; Open to begin</p>
  </div>
)}
```
Style `.empty-workspace` with centered text, subtle color, flex centering.

2. **Multi-document File > New:** Change `handleNewMap` to NOT ask "Discard unsaved changes?" — it should always create a new document alongside existing ones. Simply call `createDocument(createEmptyMap())`. The old behavior was single-document (replace); new behavior is multi-document (add alongside). Remove the `map?.modified` check and `window.confirm`.

3. **Multi-document File > Open:** Change `handleOpenMap` to NOT ask "Discard unsaved changes?" — it opens the file as a new document. Remove the `map?.modified` check. After `mapService.loadMap()` succeeds, call `createDocument(result.map!, result.filePath)` instead of `setMap(result.map!, result.filePath)`.

4. **File > Save:** Update `handleSaveMap` to read from active document. Get the active document from the store: `const activeDoc = documents.get(activeDocumentId)`. Use `activeDoc.map` for saving and `activeDoc.filePath` for the default path. After save, call `markSavedForDocument(activeDocumentId)` or the wrapper `markSaved()`. If no active document, return early.

5. **Title bar updates:** Add an effect that watches `activeDocumentId`, the active document's `filePath`, and `map?.modified` to update the Electron window title. Use IPC:
```typescript
useEffect(() => {
  if (!activeDocumentId) {
    window.electronAPI?.setTitle?.('AC Map Editor');
    return;
  }
  const doc = documents.get(activeDocumentId);
  if (!doc?.map) return;
  const filename = doc.filePath ? path.basename(doc.filePath) : 'Untitled';
  const modified = doc.map.modified ? ' *' : '';
  window.electronAPI?.setTitle?.(`${filename}${modified} - AC Map Editor`);
}, [activeDocumentId, /* re-derive from store */]);
```

Actually, since we can't easily track deep changes via useEffect deps, use a Zustand selector instead:
```typescript
const windowTitle = useEditorStore((state) => {
  if (!state.activeDocumentId) return 'AC Map Editor';
  const doc = state.documents.get(state.activeDocumentId);
  if (!doc?.map) return 'AC Map Editor';
  const filename = doc.filePath
    ? doc.filePath.split(/[\\/]/).pop() || 'Untitled'
    : 'Untitled';
  const modified = doc.map.modified ? ' *' : '';
  return `${filename}${modified} - AC Map Editor`;
});

useEffect(() => {
  document.title = windowTitle;
  // Also set via IPC if available
  if (window.electronAPI?.setTitle) {
    window.electronAPI.setTitle(windowTitle);
  }
}, [windowTitle]);
```

6. **Subscribe to active document state:** Add selectors for `activeDocumentId` and `documents` (via a derived selector) so the component knows when to render MapCanvas vs empty workspace.

7. **Closing documents with unsaved changes:** Add a `closeDocument` handler (not yet wired to UI — Phase 34 adds tabs). When called:
```typescript
const handleCloseDocument = useCallback(async (docId: string) => {
  const doc = useEditorStore.getState().documents.get(docId);
  if (doc?.map?.modified) {
    // 3-button dialog: Save / Don't Save / Cancel (user decision)
    const result = window.confirm('Save changes before closing?');
    // For now, use window.confirm. Phase 34 can upgrade to 3-button dialog.
    if (result) {
      // Save first, then close
      await handleSaveMap();
    }
    // If user clicked Cancel in confirm, they get false = Don't Save behavior
    // This is a simplification; full 3-button dialog deferred to Phase 34 MDI UI
  }
  useEditorStore.getState().closeDocument(docId);
}, [handleSaveMap]);
```

**electron/main.ts changes:**

Add IPC handler for setting window title:
```typescript
ipcMain.on('set-title', (_, title: string) => {
  if (mainWindow) {
    mainWindow.setTitle(title);
  }
});
```

**electron/preload.ts changes:**

Expose the `setTitle` function:
```typescript
setTitle: (title: string) => ipcRenderer.send('set-title', title),
```

Also ensure the TypeScript type for `window.electronAPI` includes `setTitle`.

**App.css changes:**

Add `.empty-workspace` styling:
```css
.empty-workspace {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 14px;
  gap: 4px;
  user-select: none;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Start the app:
1. App starts with empty workspace message (no MapCanvas)
2. File > New creates a document, MapCanvas appears
3. File > New again creates a second document (both in memory)
4. Title bar shows "Untitled - AC Map Editor" for new maps
5. Drawing tiles and seeing "Untitled * - AC Map Editor" in title
6. File > Open opens a .lvl file, title shows filename
  </verify>
  <done>
App starts with empty workspace. File > New and File > Open create new documents alongside existing ones. Title bar reflects active document's filename and dirty state. Close-document handler exists for Phase 34 to wire up.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate remaining components to document-aware selectors</name>
  <files>
    src/components/MapCanvas/MapCanvas.tsx
    src/components/ToolBar/ToolBar.tsx
    src/components/Minimap/Minimap.tsx
    src/components/StatusBar/StatusBar.tsx
    src/components/MapSettingsDialog/MapSettingsDialog.tsx
    src/components/MapSettingsPanel/MapSettingsPanel.tsx
    src/components/AnimationPanel/AnimationPanel.tsx
    src/components/TilePalette/TilePalette.tsx
    src/components/GameObjectToolPanel/GameObjectToolPanel.tsx
    src/components/AnimationPreview/AnimationPreview.tsx
  </files>
  <action>
Most components should already work via the backward-compatible top-level fields from Plan 01. This task verifies and makes targeted updates where needed.

**Components that need updates (document-aware selectors):**

1. **ToolBar.tsx** — `canUndo` and `canRedo` selectors currently read `state.undoStack.length > 0` and `state.redoStack.length > 0`. These are backward-compatible via Plan 01's top-level sync. **Verify they work; if not, update to:**
```typescript
const canUndo = useEditorStore((state) => {
  if (!state.activeDocumentId) return false;
  const doc = state.documents.get(state.activeDocumentId);
  return doc ? doc.undoStack.length > 0 : false;
});
```
Same pattern for canRedo. Also: undo/redo/copy/cut/paste/delete actions should no-op gracefully when no document is open.

2. **MapCanvas.tsx** — The most complex consumer. Currently reads `map`, `viewport`, `selection`, etc. from top-level state. These should work via backward compat. However, there's a direct store mutation at line ~870: `useEditorStore.setState({ map: { ...map } })`. This must be updated to work with the document model. Change to use the wrapper action or call the ForDocument variant. Also review all `get()` calls inside the component for any that assume single-document state.

Key MapCanvas concerns:
- Verify `map`, `viewport`, `selection`, `clipboard`, `isPasting`, `pastePreviewPosition` come through correctly
- The `useEditorStore.setState({ map: { ...map } })` direct mutation (around line 870) needs to become a proper action call. Add a `refreshActiveDocumentMap` wrapper action to EditorState if needed, or use `markModified()`.
- Guard all tool operations against `!map` (which will be null when no document is open)

3. **Minimap.tsx** — Reads `map` and `viewport`. Should work via backward compat. Verify it renders nothing/blank when `map` is null.

4. **StatusBar.tsx** — Reads `viewport`, `currentTool`, `tileSelection`. These are all either global (currentTool, tileSelection) or synced via backward compat (viewport). Should work as-is.

5. **MapSettingsDialog.tsx** — Reads `map` and `updateMapHeader`. Should work via backward compat. Add null check for when no document is open.

6. **MapSettingsPanel.tsx** — Same as MapSettingsDialog.

7. **AnimationPanel.tsx** — Reads `animationFrame` (global), `setSelectedTile` (global), `map` (synced). Should work as-is. Verify map null handling.

8. **TilePalette.tsx** — All global state (`selectedTile`, `tileSelection`, `currentTool`, `wallType`). No changes needed.

9. **GameObjectToolPanel.tsx** — All global state (`currentTool`, `gameObjectToolState`). No changes needed.

10. **AnimationPreview.tsx** — All global state (`animationFrame`, `setSelectedTile`). No changes needed.

**For each component:**
- Read the file to check current selectors
- Verify backward compat handles it OR make minimal targeted changes
- Add `!map` / `!activeDocumentId` null guards where components would crash on empty workspace
- Ensure no direct `setState` calls that bypass the document model

**Specific fixes to make:**

a) **MapCanvas.tsx line ~870:** Replace `useEditorStore.setState({ map: { ...map } })` with a proper action. If this is for triggering a re-render after direct tile mutation (via wallSystem or gameObjectSystem that mutates map.tiles in place), use the wrapper `markModified()` or add a `forceMapRefresh()` action that does `set({ map: { ...map } })` while also syncing to the document.

b) **Null guards:** Every component that reads `map` needs a guard. MapCanvas already conditionally renders based on `map` being present, but verify all other components handle null gracefully.

c) **Conditional rendering in App.tsx:** Already handled in Task 1 — MapCanvas only renders when there's an active document.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Start the app and test:
1. App starts with empty workspace, no crashes
2. File > New — MapCanvas appears, all tools work
3. File > New again — second document created (verify via console.log or store inspection)
4. Pencil, fill, wall, eraser, select, line tools all function
5. Undo/redo works (toolbar buttons enable/disable correctly)
6. Copy/cut/paste selection works
7. Minimap renders active map
8. Settings dialog opens and edits map settings
9. Animation panel shows animations
10. Status bar shows correct info
11. No console errors
  </verify>
  <done>
All 10 consumer components work correctly with the multi-document store. Components handle empty workspace (null map) gracefully. Direct setState calls replaced with proper actions. canUndo/canRedo reflect active document's state. The app is functionally identical to before but now supports multiple documents in memory.
  </done>
</task>

</tasks>

<verification>
Full verification of Phase 33 success criteria:

1. **Multiple documents without shared state:** Open two documents (File > New twice). Edit tiles in one. Switch to the other (via `setActiveDocument` — not yet UI-wired, but testable via devtools). Verify tiles are different.

2. **Independent undo/redo:** In document A, draw tiles and undo. Switch to document B. Verify document B has no undo history. Draw in document B and undo. Switch back to A. Verify A's state is still undone.

3. **Independent file path and dirty flag:** Open a .lvl file (new doc). Open a new empty doc. Verify title bar shows different names as you switch between them.

4. **Independent viewport and selection:** Zoom/scroll in document A. Switch to document B. Verify viewport is at default. Switch back to A. Verify viewport is restored.

5. **Active document pointer:** Switching documents doesn't corrupt state. Creating a new document makes it active. Closing the active document switches to another or shows empty workspace.

6. `npx tsc --noEmit` passes with zero errors.
</verification>

<success_criteria>
- All components render correctly with empty workspace (no active document)
- File > New creates documents alongside existing ones
- File > Open creates documents alongside existing ones
- Title bar shows "filename * - AC Map Editor" pattern
- canUndo/canRedo read from active document
- All tools function identically to before
- No direct store.setState calls that bypass the document model
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-document-state-refactoring/33-02-SUMMARY.md`
</output>
