---
phase: 33-document-state-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/editor/slices/types.ts
  - src/core/editor/slices/documentsSlice.ts
  - src/core/editor/slices/globalSlice.ts
  - src/core/editor/EditorState.ts
  - src/core/editor/index.ts
autonomous: true

must_haves:
  truths:
    - "Store exposes documents Map, activeDocumentId, and all per-document actions scoped by document ID"
    - "Global state (tool, tileset selection, animation frame, UI flags) remains at top level, not inside documents"
    - "Backward-compatible wrapper actions (setTile, pushUndo, commitUndo, undo, redo, etc.) delegate to active document"
    - "Each document has independent undo/redo stacks with 100-entry limit"
    - "Creating a document adds to Map and sets activeDocumentId; closing removes from Map and updates pointer"
  artifacts:
    - path: "src/core/editor/slices/types.ts"
      provides: "DocumentState interface, DocumentId type, Viewport/Selection/ClipboardData/TileSelection types"
      contains: "DocumentState"
    - path: "src/core/editor/slices/documentsSlice.ts"
      provides: "DocumentsSlice with per-document CRUD, undo/redo, tile ops, selection ops"
      exports: ["createDocumentsSlice"]
    - path: "src/core/editor/slices/globalSlice.ts"
      provides: "GlobalSlice with tool, tileset, animation, UI state"
      exports: ["createGlobalSlice"]
    - path: "src/core/editor/EditorState.ts"
      provides: "Merged store combining both slices, backward-compatible exports"
      exports: ["useEditorStore"]
  key_links:
    - from: "src/core/editor/EditorState.ts"
      to: "src/core/editor/slices/documentsSlice.ts"
      via: "createDocumentsSlice spread into create()"
      pattern: "createDocumentsSlice"
    - from: "src/core/editor/EditorState.ts"
      to: "src/core/editor/slices/globalSlice.ts"
      via: "createGlobalSlice spread into create()"
      pattern: "createGlobalSlice"
    - from: "src/core/editor/slices/documentsSlice.ts"
      to: "src/core/editor/slices/types.ts"
      via: "DocumentState type import"
      pattern: "import.*DocumentState"
---

<objective>
Refactor the monolithic EditorState.ts (861 lines) into a slices-based architecture that supports multiple documents. Create DocumentState type, DocumentsSlice (per-document state and actions), GlobalSlice (shared UI state), and merge them into the existing useEditorStore. Provide backward-compatible wrapper actions so existing components continue to work unchanged until migrated in Plan 02.

Purpose: Establish the multi-document data foundation that Phase 33's success criteria require. Without this, documents cannot have independent undo/redo, viewport, selection, or dirty flags.

Output: Four source files (types.ts, documentsSlice.ts, globalSlice.ts, refactored EditorState.ts) that compose into a working store. The app should still function identically with a single document after this plan.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-document-state-refactoring/33-RESEARCH.md
@.planning/phases/33-document-state-refactoring/33-CONTEXT.md
@src/core/editor/EditorState.ts
@src/core/map/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and slices files</name>
  <files>
    src/core/editor/slices/types.ts
    src/core/editor/slices/documentsSlice.ts
    src/core/editor/slices/globalSlice.ts
  </files>
  <action>
Create `src/core/editor/slices/` directory with three files.

**types.ts** - Shared types extracted from EditorState.ts:
- `type DocumentId = string`
- `interface Viewport { x: number; y: number; zoom: number }`
- `interface Selection { startX: number; startY: number; endX: number; endY: number; active: boolean }`
- `interface TileSelection { startCol: number; startRow: number; width: number; height: number }`
- `interface ClipboardData { width: number; height: number; tiles: Uint16Array; originX: number; originY: number }`
- `interface PastePreviewPosition { x: number; y: number }`
- `interface TileDelta { x: number; y: number; oldValue: number; newValue: number }`
- `interface UndoEntry { deltas: TileDelta[]; description: string }`
- `interface DocumentState` containing all per-document fields:
  - `map: MapData | null` — the tile grid and header
  - `filePath: string | null` — source file path
  - `viewport: Viewport` — scroll position and zoom
  - `selection: Selection` — marquee area
  - `clipboard: ClipboardData | null` — copy/cut buffer
  - `isPasting: boolean` — paste preview mode
  - `pastePreviewPosition: PastePreviewPosition | null`
  - `undoStack: UndoEntry[]` — per-document undo
  - `redoStack: UndoEntry[]` — per-document redo
  - `pendingUndoSnapshot: Uint16Array | null` — snapshot-commit pattern
  - `modified: boolean` — dirty flag (separate from map.modified for clarity)
- `function createDefaultDocumentState(): DocumentState` — returns a fresh DocumentState with defaults (null map, empty viewport, etc.)
- `function createDocumentFromMap(map: MapData, filePath?: string): DocumentState` — creates a DocumentState initialized with a map

**documentsSlice.ts** - Per-document state management:
- Import `StateCreator` from zustand
- Import types from `./types`
- Import `MapData, MapHeader, MAP_WIDTH, MAP_HEIGHT, DEFAULT_TILE, createEmptyMap` from `../../map/types`
- Import `wallSystem` from `../../map/WallSystem`
- Import `gameObjectSystem` from `../../map/GameObjectSystem`
- Import bridge/conveyor data from `../../map/GameObjectData`
- Define `DocumentsSlice` interface with:
  - State: `documents: Map<DocumentId, DocumentState>`, `activeDocumentId: DocumentId | null`
  - Document CRUD: `createDocument(map, filePath?) => DocumentId`, `closeDocument(id)`, `setActiveDocument(id)`
  - Per-document tile ops: `setTileForDocument(id, x, y, tile)`, `setTilesForDocument(id, tiles)`, `placeWallForDocument(id, x, y)`, `eraseTileForDocument(id, x, y)`, `fillAreaForDocument(id, x, y)` — note fillArea needs access to the GlobalSlice's tileSelection, use `get()` which returns the full merged state
  - Per-document undo: `pushUndoForDocument(id)`, `commitUndoForDocument(id, description)`, `undoForDocument(id)`, `redoForDocument(id)` — enforce 100-entry limit per stack (user decision), dropping oldest with shift()
  - Per-document viewport: `setViewportForDocument(id, viewport: Partial<Viewport>)`
  - Per-document selection: `setSelectionForDocument(id, selection: Partial<Selection>)`, `clearSelectionForDocument(id)`
  - Per-document clipboard ops: `copySelectionForDocument(id)`, `cutSelectionForDocument(id)`, `deleteSelectionForDocument(id)`, `startPastingForDocument(id)`, `cancelPastingForDocument(id)`, `setPastePreviewPositionForDocument(id, x, y)`, `pasteAtForDocument(id, x, y)`, `mirrorHorizontalForDocument(id)`, `mirrorVerticalForDocument(id)`, `rotateClipboardForDocument(id)`
  - Per-document map ops: `updateMapHeaderForDocument(id, updates: Partial<MapHeader>)`, `markModifiedForDocument(id)`, `markSavedForDocument(id)`
  - Per-document game object ops: `placeGameObjectForDocument(id, x, y) => boolean`, `placeGameObjectRectForDocument(id, x1, y1, x2, y2) => boolean` — these need access to GlobalSlice's currentTool and gameObjectToolState via `get()`
- Implement `createDocumentsSlice` as a `StateCreator`:
  - Use `StateCreator<DocumentsSlice & GlobalSlice, [], [], DocumentsSlice>` typing so it can access global state via `get()`
  - For all per-document mutations, create a new Map (`new Map(state.documents)`) to ensure Zustand reactivity (Research pitfall #2)
  - In `closeDocument`, if closing the active document, set `activeDocumentId` to the first remaining document or null (Research pitfall #1)
  - In `commitUndoForDocument`, enforce 100-entry limit with `shift()` on the undo stack (Research pitfall #3)
  - Port ALL tile/undo/selection/clipboard/gameobject logic from current EditorState.ts, scoped to the specific document ID
  - All actions should capture documentId at invocation time, NOT re-read activeDocumentId later (Research pitfall #4)

IMPORTANT: The undo limit must be 100 entries per user decision (current code uses 50). Update this.

**globalSlice.ts** - Shared UI state:
- Define `GlobalSlice` interface with:
  - State: `currentTool`, `previousTool`, `selectedTile`, `tileSelection`, `wallType`, `animationFrame`, `gameObjectToolState`, `rectDragState`, `customDatLoaded`, `showGrid`, `showAnimations`, `maxUndoLevels` (100)
  - Actions: `setTool`, `restorePreviousTool`, `setSelectedTile`, `setTileSelection`, `getSelectedTileId`, `setWallType`, `advanceAnimationFrame`, `toggleGrid`, `toggleAnimations`, all game object setters (`setGameObjectTeam`, `setWarpSettings`, `setSpawnType`, `setSwitchType`, `setBunkerSettings`, `setHoldingPenType`, `setBridgeDirection`, `setConveyorDirection`, `setFlagPadType`), `setRectDragState`, `loadCustomDat`
- Implement `createGlobalSlice` as `StateCreator<DocumentsSlice & GlobalSlice, [], [], GlobalSlice>`
- Port all global action logic directly from current EditorState.ts (these are unchanged)
- Initial values match current EditorState.ts defaults
  </action>
  <verify>
Run `npx tsc --noEmit` — should produce zero errors. Verify all three files exist:
- `src/core/editor/slices/types.ts` exports DocumentState, DocumentId, Viewport, Selection, etc.
- `src/core/editor/slices/documentsSlice.ts` exports createDocumentsSlice
- `src/core/editor/slices/globalSlice.ts` exports createGlobalSlice
  </verify>
  <done>
Three slice files exist with full type definitions and implementations. DocumentState captures all per-document fields. DocumentsSlice has all per-document actions scoped by ID. GlobalSlice has all shared UI state and actions. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor EditorState.ts with backward-compatible wrappers</name>
  <files>
    src/core/editor/EditorState.ts
    src/core/editor/index.ts
  </files>
  <action>
Rewrite `src/core/editor/EditorState.ts` to compose the two slices and provide backward-compatible wrappers.

**EditorState.ts structure:**

1. Import `create` from 'zustand'
2. Import `createDocumentsSlice`, `DocumentsSlice` from './slices/documentsSlice'
3. Import `createGlobalSlice`, `GlobalSlice` from './slices/globalSlice'
4. Re-export types from './slices/types' for consumers that import from EditorState

5. Define `type EditorState = DocumentsSlice & GlobalSlice`

6. Create the store:
```typescript
export const useEditorStore = create<EditorState>()((...a) => ({
  ...createDocumentsSlice(...a),
  ...createGlobalSlice(...a),
}));
```

7. Add backward-compatible wrapper actions that delegate to the active document. These are added directly to the store interface and implementation so existing components don't break. Each wrapper:
   - Reads `activeDocumentId` from state
   - If null, returns early (no-op)
   - Calls the corresponding `*ForDocument(id, ...)` method

Wrapper actions to add (these go into the store as a third "compat" layer):

```typescript
// These are added after the slice merge, using store methods
// In the create() call, add a third object after the two slices:

// Document lifecycle (replaces old setMap/newMap)
setMap: (map, filePath?) => {
  // Creates a new document from the map, sets it as active
  get().createDocument(map, filePath);
},
newMap: () => {
  const map = createEmptyMap();
  get().createDocument(map);
},

// Tile ops - delegate to active document
setTile: (x, y, tile) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().setTileForDocument(id, x, y, tile);
},
setTiles: (tiles) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().setTilesForDocument(id, tiles);
},
placeWall: (x, y) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().placeWallForDocument(id, x, y);
},
eraseTile: (x, y) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().eraseTileForDocument(id, x, y);
},
fillArea: (x, y) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().fillAreaForDocument(id, x, y);
},

// Undo/redo wrappers
pushUndo: () => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().pushUndoForDocument(id);
},
commitUndo: (description) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().commitUndoForDocument(id, description);
},
undo: () => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().undoForDocument(id);
},
redo: () => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().redoForDocument(id);
},

// Viewport/selection wrappers
setViewport: (viewport) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().setViewportForDocument(id, viewport);
},
setSelection: (selection) => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().setSelectionForDocument(id, selection);
},
clearSelection: () => {
  const id = get().activeDocumentId;
  if (!id) return;
  get().clearSelectionForDocument(id);
},

// Clipboard wrappers
copySelection: () => { ... delegate to active doc ... },
cutSelection: () => { ... },
deleteSelection: () => { ... },
pasteClipboard: () => { ... },
startPasting: () => { ... },
cancelPasting: () => { ... },
setPastePreviewPosition: (x, y) => { ... },
pasteAt: (x, y) => { ... },
mirrorHorizontal: () => { ... },
mirrorVertical: () => { ... },
rotateClipboard: () => { ... },

// Map header/state wrappers
updateMapHeader: (updates) => { ... },
markModified: () => { ... },
markSaved: () => { ... },

// Game object wrappers
placeGameObject: (x, y) => { ... },
placeGameObjectRect: (x1, y1, x2, y2) => { ... },
```

8. Add backward-compatible computed getters via the store. Components currently access `state.map`, `state.viewport`, `state.selection`, etc. directly. To maintain backward compatibility during migration, add these as top-level state fields that are computed from the active document.

**CRITICAL:** Instead of computed getters (which Zustand doesn't natively support), the wrapper actions that modify document state should ALSO update top-level `map`, `viewport`, `selection`, `clipboard`, `isPasting`, `pastePreviewPosition`, `undoStack`, `redoStack`, `pendingUndoSnapshot`, and `filePath` fields. This way, existing selectors like `state => state.map` continue to work.

Approach: Keep the top-level fields (`map`, `viewport`, `selection`, etc.) in the store. Every `*ForDocument` action that updates document state also syncs these top-level fields IF the target document is the active document. And `setActiveDocument` syncs all top-level fields from the newly active document.

This means:
- `setActiveDocument(id)` sets `activeDocumentId = id` and copies all state fields from `documents.get(id)` to the top-level fields
- Every per-document mutation checks `if (id === state.activeDocumentId)` and syncs the relevant top-level field
- `createDocument` and `closeDocument` handle syncing when the active document changes

This provides FULL backward compatibility — zero component changes needed in Plan 01.

9. Update `src/core/editor/index.ts` to also export types:
```typescript
export * from './EditorState';
export * from './slices/types';
```

**IMPORTANT constraints:**
- maxUndoLevels = 100 (user decision, up from current 50)
- App starts with empty workspace: `documents: new Map()`, `activeDocumentId: null`, `map: null`
- `newMap()` calls `createDocument(createEmptyMap())` — creates a new doc alongside existing ones
- `setMap(map, filePath)` calls `createDocument(map, filePath)` — creates a new doc alongside existing ones
- Remove the old undo/redo clearing behavior from setMap/newMap — each document gets fresh stacks on creation
  </action>
  <verify>
Run `npx tsc --noEmit` — must produce zero errors. Then run the app with `npm run electron:dev` and verify:
1. App starts (may show empty workspace since no map is loaded)
2. File > New creates a map that can be edited
3. Pencil tool draws tiles
4. Undo/redo works
5. Fill tool works
6. All tools function identically to before
  </verify>
  <done>
EditorState.ts composes DocumentsSlice + GlobalSlice + backward-compatible wrappers. All existing component selectors (state.map, state.viewport, state.selection, etc.) continue to work. The store supports multiple documents internally while presenting the same API externally. TypeScript compiles with zero errors. App functions identically to before this refactoring.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. App starts and displays correctly
3. File > New creates an editable map
4. All tools (pencil, fill, wall, eraser, select, line, game objects) work
5. Undo/redo operates correctly
6. Copy/cut/paste selection works
7. No console errors related to document state
</verification>

<success_criteria>
- Four new/modified files compose into a working Zustand store
- DocumentState type captures all per-document fields
- Documents are stored in Map<DocumentId, DocumentState>
- Global state remains separate from per-document state
- Backward-compatible wrapper actions keep all existing components working without changes
- Undo stack limit is 100 entries per document (user decision)
- TypeScript strict mode passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-document-state-refactoring/33-01-SUMMARY.md`
</output>
