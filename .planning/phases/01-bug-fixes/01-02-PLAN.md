---
phase: 01-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/AnimationPanel/AnimationPanel.tsx
  - src/components/MapCanvas/MapCanvas.tsx
  - electron/main.ts
autonomous: true

must_haves:
  truths:
    - "User can load animation data from Gfx.dll file"
    - "Animation panel displays real frame data (not placeholders)"
    - "Animated tiles on map cycle through correct frames"
    - "Animation timing is consistent across 60Hz/120Hz displays"
  artifacts:
    - path: "src/components/AnimationPanel/AnimationPanel.tsx"
      provides: "Binary animation data loading from Gfx.dll"
      contains: "getUint16"
    - path: "src/components/MapCanvas/MapCanvas.tsx"
      provides: "RAF-based animation timing"
      contains: "requestAnimationFrame"
  key_links:
    - from: "AnimationPanel handleLoadAnimations"
      to: "window.electronAPI.readFile"
      via: "IPC file read"
      pattern: "electronAPI\\.readFile|openFileDialog"
    - from: "MapCanvas animation rendering"
      to: "animations state"
      via: "useEditorStore"
      pattern: "animations\\[animId\\]"
---

<objective>
Fix animation system to load real data and render with proper timing.

Purpose: The animation panel currently uses hardcoded placeholder data, and animation timing uses setInterval which drifts on high refresh displays. Users need to load real animation definitions from Gfx.dll and see them render consistently.

Output: Animation panel loads 66-byte structures from Gfx.dll at offset 0x642E0, animations render using requestAnimationFrame with timestamp-based frame advancement.
</objective>

<execution_context>
@C:\Users\arcje\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\arcje\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@E:\NewMapEditor\.planning\PROJECT.md
@E:\NewMapEditor\.planning\ROADMAP.md
@E:\NewMapEditor\.planning\phases\01-bug-fixes\01-RESEARCH.md

Key code references:
- AnimationPanel.tsx: lines 42-55 (placeholder generation), 164-176 (load handler)
- MapCanvas.tsx: lines 147-174 (animated tile rendering)
- Animation structure: 66 bytes at offset 0x642E0 in Gfx.dll
- Frame timing: 150ms per frame (SEDIT ANIMFRAME_DURATION)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement binary animation data loading</name>
  <files>src/components/AnimationPanel/AnimationPanel.tsx, electron/main.ts</files>
  <action>
1. Add IPC handler in electron/main.ts for opening DLL files:
   ```typescript
   ipcMain.handle('dialog:openDllFile', async () => {
     const result = await dialog.showOpenDialog(mainWindow!, {
       properties: ['openFile'],
       filters: [
         { name: 'DLL Files', extensions: ['dll'] },
         { name: 'All Files', extensions: ['*'] }
       ]
     });
     if (result.canceled || result.filePaths.length === 0) {
       return null;
     }
     return result.filePaths[0];
   });
   ```

2. Add to preload.ts:
   ```typescript
   openDllDialog: () => ipcRenderer.invoke('dialog:openDllFile'),
   ```
   And update ElectronAPI interface.

3. Replace `handleLoadAnimations` in AnimationPanel.tsx with binary parsing:
   ```typescript
   const handleLoadAnimations = async () => {
     // Open file picker for Gfx.dll
     const filePath = await window.electronAPI.openDllDialog();
     if (!filePath) return;

     const result = await window.electronAPI.readFile(filePath);
     if (!result.success || !result.data) {
       console.error('Failed to read animation file');
       return;
     }

     // Decode base64 to ArrayBuffer
     const binaryString = atob(result.data);
     const bytes = new Uint8Array(binaryString.length);
     for (let i = 0; i < binaryString.length; i++) {
       bytes[i] = binaryString.charCodeAt(i);
     }
     const buffer = bytes.buffer;
     const dataView = new DataView(buffer);

     // Parse 256 animation structures at offset 0x642E0
     const ANIM_OFFSET = 0x642E0;
     const animations: Animation[] = [];

     for (let i = 0; i < 256; i++) {
       const offset = ANIM_OFFSET + (i * 66);

       // Bounds check
       if (offset + 66 > buffer.byteLength) {
         console.warn(`Animation ${i}: offset ${offset} exceeds file size`);
         break;
       }

       const frameCount = dataView.getUint8(offset);
       const speed = dataView.getUint8(offset + 1);
       const frames: number[] = [];

       // Read up to 32 WORD (16-bit little-endian) frame indices
       const actualFrameCount = Math.min(frameCount, 32);
       for (let j = 0; j < actualFrameCount; j++) {
         const frameId = dataView.getUint16(offset + 2 + (j * 2), true); // little-endian
         frames.push(frameId);
       }

       animations.push({
         id: i,
         frameCount: actualFrameCount || 1, // Minimum 1 frame
         speed: speed === 0 ? 255 : speed,
         frames: frames.length > 0 ? frames : [0]
       });
     }

     setAnimations(animations);
   };
   ```

4. Import Animation type at top of AnimationPanel.tsx:
   ```typescript
   import { TILE_SIZE, Animation, ANIMATED_FLAG } from '@core/map';
   ```
   (Animation type should already be imported, verify)
  </action>
  <verify>
1. Run `npm run typecheck` - should pass
2. Run `npm run electron:dev`
3. Click "Load" in Animation panel, select a Gfx.dll file
4. Verify animations array is populated (check console or UI count)
  </verify>
  <done>
- File picker opens for DLL selection
- Binary data parsed correctly (66-byte structures, little-endian WORDs)
- Animation array populated with real frame data
- Edge cases handled (missing file, truncated data)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement timestamp-based animation timing</name>
  <files>src/components/AnimationPanel/AnimationPanel.tsx, src/components/MapCanvas/MapCanvas.tsx</files>
  <action>
1. In AnimationPanel.tsx, replace the setInterval-based timer (lines 34-39) with requestAnimationFrame:
   ```typescript
   // Animation timer using RAF with timestamp deltas
   useEffect(() => {
     let animationId: number;
     let lastFrameTime = 0;
     const FRAME_DURATION = 150; // ms per frame

     const animate = (timestamp: DOMHighResTimeStamp) => {
       if (timestamp - lastFrameTime >= FRAME_DURATION) {
         advanceAnimationFrame();
         lastFrameTime = timestamp;
       }
       animationId = requestAnimationFrame(animate);
     };

     animationId = requestAnimationFrame(animate);

     return () => {
       cancelAnimationFrame(animationId);
     };
   }, [advanceAnimationFrame]);
   ```

2. In MapCanvas.tsx, the animation rendering logic (lines 147-174) already reads from animations state correctly. Verify it uses:
   - `animationFrame` from store for global frame counter
   - `animations[animId]` for the animation data
   - Modulo for frame cycling: `(animationFrame + frameOffset) % anim.frameCount`

3. Ensure MapCanvas re-renders when animationFrame changes. The draw() callback already depends on `animationFrame`, so this should work. Verify in the dependency array (line 258).
  </action>
  <verify>
1. Run `npm run typecheck` - should pass
2. Run `npm run electron:dev`
3. Load animation data (Gfx.dll)
4. Place an animated tile on the map
5. Verify animation cycles smoothly at ~150ms per frame
6. If possible, test on both 60Hz and 120Hz display - timing should be consistent
  </verify>
  <done>
- setInterval replaced with requestAnimationFrame
- Timestamp deltas used for frame advancement (150ms)
- Animation timing consistent regardless of display refresh rate
- Animations pause properly when tab is in background (RAF behavior)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Animation loading from Gfx.dll and timestamp-based rendering</what-built>
  <how-to-verify>
1. Run `npm run electron:dev`
2. Click "Load" in the Animation panel (right side)
3. Navigate to and select a Gfx.dll file (from Continuum installation or provided test file)
4. Verify: Animation panel shows "256 animations loaded" (or actual count)
5. Verify: Animation previews in the panel show real frame sequences (not placeholders)
6. Click on an animation in the panel, then click "Use Animation"
7. Click on the map to place the animated tile
8. Verify: The placed tile animates smoothly on the map
9. Verify: Animation speed is consistent (~6-7 frames per second / 150ms per frame)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with animation loading or rendering</resume-signal>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- Load button opens file picker filtered for DLL files
- Animation data parses correctly from Gfx.dll binary format
- Animation panel displays real frame counts and speeds
- Animated tiles cycle through correct frames on map
- Timing is consistent on different refresh rate displays
</verification>

<success_criteria>
1. User clicks Load, selects Gfx.dll, sees "256 animations loaded"
2. Animation panel shows real frame data (actual frame counts, not always "4 frames")
3. Animated tiles on map cycle through correct frames
4. Animation timing is smooth and consistent (~150ms per frame)
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes/01-02-SUMMARY.md`
</output>
